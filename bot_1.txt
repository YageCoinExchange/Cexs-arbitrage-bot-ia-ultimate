DATOS DEL BOT 

## 1. **Pares a monitorear**
Lista de pares:
LTC/USDT, 
BNB/USDT,
XRP/USDT,
ALGO/USDT,
ANIME/USDT,
APT/USDT,
ARB/USDT,
ATOM/USDT,
AVAX/USDT,
AXL/USDT,
BB/USDT,
BEL/USDT,
BERA/USDT,
BOME/USDT,
BONK/USDT,
C98/USDT,
CAKE/USDT,
CATI/USDT,
CELO/USDT,
CGPT/USDT,
CHZ/USDT,
CYBER/USDT,
DOGS/USDT,
DOT/USDT,
DYDX/USDT,
EGLD/USDT,
ENJ/USDT,
FIDA/USDT,
FLOKI/USDT,
FLOW/USDT,
GMT/USDT,
GMX/USDT,
HAEDAL/USDT,
HBAR/USDT,
HMSTR/USDT,
HOME/USDT,
HYPER/USDT,
ICP/USDT,
ICX/USDT,
INJ/USDT,
IO/USDT,
JUP/USDT,
KAIA/USDT,
KMNO/USDT,
KSM/USDT,
LUNA/USDT,
MAGIC/USDT,
MANTA/USDT,
MBOX/USDT,
MINA/USDT,
NEAR/USDT,
NOT/USDT,
ONE/USDT,
OP/USDT, 
PSG/USDT, 
PYTH/USDT,
RDNT/USDT,
ROSE/USDT,
SCRT/USDT,
SEI/USDT,
SHIB/USDT,
SIGN/USDT,
STX/USDT,
SUI/USDT,
TIA/USDT,
TNSR/USDT,
TON/USDT,
TRUMP/USDT,
TRX/USDT,
WAXP/USDT,
WCT/USDT,
WIF/USDT,
WLD/USDT,
XAI/USDT,
XLM/USDT,
ZIL/USDT,
ZRO/USDT
  
Determinar el activo base:
 (USDT)

## 2. ** Direcciones y Redes de depósito**
-        Direcciónes y Redes soportadas para cada token en ambos exchanges
BINANCE 
USDT= EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb MEMO 163771801 ( TON The Open Network )* 
LTC = LiCH4dMWM6YRHFWYC78hppAk1SwUFkDAK4 ( Litecoin )* 
BNB = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20) )* 
XRP = rNxp4h8apvRis6mJf9Sh8C6iRxfrDWN7AV MEMO 466152795 ( XRP Ripple (xrp) )* 
ALGO = L43SHHRVHAIYHGFGXFBKM7IMZNYT7WSLSMXPHGNH4D5NPYOBIJSK35X5OE ( ALGO Algorand )
ANIME = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( ARBITRUM Arbitrum One )
APT = 0x0b69478291cb55e808a716a046cc0d1ab2981e85778957da3fd519c6061ccb9e ( APT Aptos )
ARB = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( ARBITRUM Arbitrum One )
ATOM = cosmos1j8pp7zvcu9z8vd882m284j29fn2dszh05cqvf9 MEMO 100738176 ( ATOM Cosmos )*
AVAX = X-avax1j2suzh09083n9cyd80dk3lsr0c3e8ry3skk27q ( AVAX Avalanche )
AXL = axelar17ewha7y7fr0xsej6xfep88rq30rse9hgynll78 MEMO 101408734 ( AXL Axelar )*
BB = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BB BounceBit )
BEL = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20) )
BERA = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BERA Berachain )
BOME = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
BONK = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
C98 = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20) )
CAKE = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20) )
CATI = EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb MEMO 163771801 ( TON The Open Network )*
CELO = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( CELO CELO )
CGPT = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20) )
CHZ = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( CHZ2 Chiliz Chain (CAP20) )
CYBER = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( OPTIMISM Optimism )
DOGS = EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb MEMO 163771801 ( TON The Open Network )*
DOT = 12zByesGXudgBh4C6ZRbF82SkEAwxC6viaTZwg6BbkWABuT5 ( DOT Polkadot )
DYDX = dydx1vvl7htcnzc3g0hsrysxf3vvrk6tpx70822ef6g MEMO 100903728 ( DYDX DYDX )*
EGLD = erd1ecw70t7jjw77c6sdmesz2quzlxwv87tv983970wlr8gchy0sqv8sp8ef3k ( EGLD MultiversX eGold )
ENJ = enExKScymYYPkj9tzvgs4UFDCEVCyWuJi7zVAdwuAsF5jokn5 ( ENJ Enjin Relay Chain )
FIDA = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
FLOKI = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20 ) 
FLOW = 0x94ad1c8825ca243d ( FLOW Flow )
GMT = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20 )
GMX = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( ARBITRUM Arbitrum One )
HAEDAL = 0xd03819773837ad71e19c3903561d61a5ae7cb7035ade1c841d84f23040ea79f4 ( SUI Sui )
HBAR = 0.0.1873771 MEMO 103878176
HMSTR = EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb MEMO 163771801 ( TON The Open Network )*
HOME = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
HYPER = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20 )
ICP = 3cb40b0fb786925bc5e4f5cf4e4d7c5d617a70fdefa8e483487d076b65c50151 ( ICP Internet Computer )
ICX = hx5ff80447faff8dfb5193ff420c35b72535282f3d  ( ICX ICON )
INJ = inj1u2rajhqtptzvu23leheta9yg99k3hazf4waf43 MEMO 105901031 ( INJ Injective )*
IO = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
JUP = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
KAIA = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7  ( KAIA Kaia )
KMNO = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa  ( SOL Solana )
KSM = G8AjQrZs9CfPYiTCjkS75r2tHQPqxK1bNagLefLa4QvHGCQ  ( KSM Kusama )
LUNA = terra1frh79vmtur5fmrghz6gfjvfhpa3u2c0uemv4af MEMO 103811345 ( LUNA Terra )
MAGIC = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( ARBITRUM Arbitrum One )
MANTA = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7  ( MANTA Manta Network )
MBOX = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7  ( BSC BNB Smart Chain (BEP20 )
MINA = B62qkTezzMtbX71ZnR74N4JAs1LT4jvacx2aLJR9yPFzdtDqA3dGLQD ( MINA Mina )
NEAR = 836da29a0b7172bf48cb1cb5466d29adc0aac38904a091e64b71e66539ab984b ( NEAR NEAR Protocol )
NOT = EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb MEMO 163771801  ( TON The Open Network )*
ONE = one1hwlkh335c6k6w8eugsj9f2qkjvxuk5q59z0m8s ( ONE Harmony )
OP = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( OPTIMISM Optimism )
PSG = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( CHZ2 Chiliz Chain (CAP20) )
PYTH = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
RDNT = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( ARBITRUM Arbitrum One )
ROSE = oasis1qz0f26wkrt5852xcghrnr52rwgk30jwxcq3lwcee ( ROSE Oasis Network )
SCRT = secret13fh085csr7w7e866r402cqa9xp42trsch7w269 MEMO 101301675 ( SCRT Secret )
SEI = sei1zrqryvr8m40yqej95lcqzw7y0sf0662cxh0kcv MEMO 100286985 ( SEI SEI )
SHIB = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20 )
SIGN = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( BSC BNB Smart Chain (BEP20 )
STX = SP2TA4FGB43WVAS8MVS6YCWTSN2BZNQ1ASGEAKSDD MEMO 103289850 ( STX Stacks )
SUI = 0xd03819773837ad71e19c3903561d61a5ae7cb7035ade1c841d84f23040ea79f4 ( SUI Sui )
TIA =  celestia1fd3mclxp4e2fh0wpau3eg55x2fsm7yjxzg29j2 MEMO 105643806  ( TIA Celestia ) 
TON = EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb MEMO 163771801  ( TON The Open Network ) 
TRUMP = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa  ( SOL Solana )
TRX = TNZx9MUo2Db4xLT9zVe17NqwconpaaWwDq  ( TRX Tron (TRC20) ) 
WAXP = waxonbinance MEMO 106691034 ( WAX WAX  ) 
WIF = 9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa ( SOL Solana )
WCT = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( OPTIMISM Optimism )
WLD = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( OPTIMISM Optimism )XAI =  
XLM = GABFQIK63R2NETJM7T673EAMZN4RJLLGP3OFUEJU5SZVTGWUKULZJNL6 MEMO 380362871  ( XLM Stellar Network ) 
ZIL = zil1ldwp360uz36800cr5n73gtm0fjxmrn8sr4r3uq ( ZIL Zilliqa ) 
ZRO = 0xe5b10a8fa449155d5b4b657dab4e856815d52bd7 ( ARBITRUM Arbitrum One )


BYBIT  
USDT= UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB ( TON )*           
LTC = LLCxH3L5fn9ejTPVk3nWTJcqvvTWsu2LbJ ( LTC ) * 
BNB = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )*
XRP = rJn2zAPdFA193sixJwuFixRkYDUtx3apQh MEMO 501350199 (XRP)*
ALGO = U5EPBBGTH4ZHEJMSYWRRBEOTOORYTSTSTYZITGDYM2KUQPDXWTHFDJPFVY ( ALGO )
ANIME = 0x4231d188a91481a8c3d39d444b7451436babee94 ( ARBI )
APT = 0x9f5ade930d03eb3fd1f0906f4e7edaddc458ac71260bf985bb61cfb61ac09191 ( APTOS )
ARB = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Arbitrum One )
ATOM = cosmos1c8dskmuz2wj29tg3rygt8mzg92f09gwcqqyexa ( ATOM )
AVAX = X-avax1unlvn8ef6lpjsac0t37t9za6astc8a55pugnm2( AVAX )
AXL = axelar1yzsury9fldydgk425gmphy2zyehh3emc43ds6x MEMO 10048670 ( AXL)
BB = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BounceBit )
BEL = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
BERA = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Berachain )
BOME = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
BONK = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
C98 = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
CAKE = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
CATI = UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB ( TON )
CELO = 0x4231d188a91481a8c3d39d444b7451436babee94 ( CELO )
CGPT = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
CHZ = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Chiliz Chain )
CYBER = 0x4231d188a91481a8c3d39d444b7451436babee94 ( OP Mainnet )
DOGS = UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB ( TON )
DOT = 13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm ( DOT )
DYDX = dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq MEMO 10178277 ( DYDX )
EGLD = erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4 ( EGLD )
ENJ = enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i ( Enjin )
FIDA = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
FLOKI = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
FLOW = 0xdbb61e402a382eb3 ( FLOW )
GMT = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
GMX = 0x4231d188a91481a8c3d39d444b7451436babee94 ( AVAXC )
HAEDAL = 0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c ( SUI )
HBAR = 0.0.615422 MEMO 10067078 ( HBAR ) 
HMSTR = UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB ( TON ) 
HOME = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
HYPER = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
ICP = dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a ( ICP ) 
ICX = hx8c278a658331a569b640e925ac55a70a8e5534b6 ( ICX )
INJ = inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n MEMO 10014232 ( INJ )
IO = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
JUP = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
KAIA = 0x4231d188a91481a8c3d39d444b7451436babee94 ( KAIA )
KMNO = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
KSM = GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV ( KSM )
LUNA = terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s ( Terra )
MAGIC = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Arbitrum One )
MANTA = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Manta Pacific Mainnet )
MBOX = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
MINA = B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW ( MINA )
NEAR = 7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef ( NEAR )
NOT = UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB ( TON )
ONE = one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3 ( ONE )
OP = 0x4231d188a91481a8c3d39d444b7451436babee94 ( OP Mainnet )
PSG = 0x4231d188a91481a8c3d39d444b7451436babee94 (Chiliz Chain)
PYTH = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
RDNT = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Arbitrum One )
ROSE = oasis1qqgk0fmqlmcr5k0d0rgknw7e6a7hlc0t3qljrnhe ( ROSE )
SCRT = secret1tsz8v9k75jeqtl4exnf0qye5nme840h5n0pldk MEMO 10120271 ( SCRT )
SEI = sei10czwjwhcjdjexgz9ecn2xma5at9t04dfaxsf4t MEMO 10124250 ( SEI )
SHIB = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
SIGN = 0x4231d188a91481a8c3d39d444b7451436babee94 ( BSC (BEP20) )
STX = SP27ANV45PCAG98PGFA2GVN9K7QYY1KWWS1V6RFSX MEMO 10167021 ( STX )
SUI = 0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c ( SUI )
TIA = celestia12stggm53c5wzqdz6w5xn6tkrj56phnzktj7d5w ( Celestia )
TON = UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB ( TON )
TRUMP = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
TRX = TAF6zJUsa3yja8p5XQTWhMaY3QXxZmZdGN ( TRX Tron (TRC20) )
WAXP = bybitwaxonly MEMO 10068817 ( WAX )
WCT = 0x4231d188a91481a8c3d39d444b7451436babee94 ( OP Mainnet )
WIF = 3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8 ( Solana )
WLD = 0x4231d188a91481a8c3d39d444b7451436babee94 ( OP Mainnet )
XAI = 0x4231d188a91481a8c3d39d444b7451436babee94 ( Arbitrum One )
XLM = GDT7ARDYZRBXXYOCSQ3MUMISTITSSRWZI6KR2A5L5Q3KB4QIZHGYMTIH MEMO 11088858 ( Stellar Lumens )
ZIL = zil1f5xpvwltm6uheftrlrhjtxcv392uuxtejekpjs ( ZIL )
ZRO = 0x4231d188a91481a8c3d39d444b7451436babee94 ( AVAXC )

## 3.   ** Fees y mínimos de retiro (≈$) y mínimos de depósito para cada red/token         
BINANCE
USDT=  Comisión de la red 0.3 USDT( ≈ 0,30 $) e Importe del retiro 5 USDT como mínimo** / Depósito mín.: 0,002 USDT**
LTC =  Comisión de la red 0,0001 LTC( ≈ 0,01 $) e Importe del retiro 0.002 LTC como minimo* /Depósito mín.: 0,002 LTC*
BNB =  comisión de la red 0.00001 BNB( ≈ 0,01 $) e Importe del retiro 0.0005 como mínimo* /Depósito mín.: 0,000003 BNB*
XRP =  comisión de la red 0.2 XRP( ≈ 0,43 $) e Importe del retiro 2 XRP como minimo* /Depósito mín.: 0,001 XRP*
ALGO = comisión de la red 0,008 ALGO( ≈ 0,001 $) e Importe del retiro 10 ALGO como minimo* /Depósito mín.: 0,007 ALGO
ANIME = Comisión de la red 7,74 ANIME( ≈ 0,17 $) e Importe del retiro 16 ANIME como minimo* /Depósito mín.:  0,00000001 ANIME                           
APT = Comisión de la red 0,016 APT( ≈ 0,17 $) e Importe del retiro 0,06 APT como minimo* /Depósito mín.: 0,00015 APT
ARB = Comisión de la red 0,56 ARB( ≈ 0,17 $) e Importe del retiro 1,12 ARB como minimo*/Depósito mín.: 0,01 ARB
ATOM = Comisión de la red 0,02 ATOM( ≈ 0,08 $) e Importe del retiro 0,04 ATOM como minimo*/Depósito mín.: 0,00016 ATOM**
AVAX = Comisión de la red 0,008 AVAX( ≈ 0,15 $) e Importe del retiro 0,1 AVAX como minimo*/Depósito mín.: 0,00005 AVAX**
AXL = Comisión de la red 0,02 AXL( ≈ 0,01 $) e Importe del retiro 1 AXL como minimo*/Depósito mín.: 0,0015 AXL**
BB = Comisión de la red 0,05 BB( ≈ 0,001 $) e Importe del retiro 1 BB como minimo* /Depósito mín.: 0,06 BB**
BEL = Comisión de la red 0,051 BE( ≈ 0,01 $) e Importe del retiro 0,1 BE como minimo*  /Depósito mín.: 0,002 BEL**
BERA = Comisión de la red 0,001 BERA( ≈ 0,001 $) e Importe del retiro 0,1 BERA como minimo*/Depósito mín.: 0,00000002 BERA**
BOME = Comisión de la red 380,00 BOME( ≈ 0,59 $) e Importe del retiro 760 BOME como minimo*/Depósito mín.: 0,02 BOME**
BONK = Comisión de la red 41 657,00 BONK( ≈ 0,59 $) e Importe del retiro 83314,00 BONK como minimo*/Depósito mín.: 0,02 BONK**
C98 = Comisión de la red 0,26 C98( ≈ 0,01 $) e Importe del retiro 0,52 C98 como minimo* /Depósito mín.: 0,007 C98**
CAKE = Comisión de la red 0,0057 CAKE( ≈ 0,01 $) e Importe del retiro 0,011 CAKE como minimo*/Depósito mín.: 0,0006 CAKE**
CATI = Comisión de la red 1,08 CATI( ≈ 0,08 $) e Importe del retiro 2,16 CATI como minimo*/Depósito mín.: 0,00000002 CATI**
CELO = Comisión de la red 0,003 CELO( ≈ 0,001 $) e Importe del retiro 0,018 CELO como minimo*/Depósito mín.: 0,02 CELO**
CGPT = Comisión de la red 0,14 CGPT( ≈ 0,01 $) e Importe del retiro 0,28 CGPT como minimo*/Depósito mín.: 0,00000002 CGPT**
CHZ = Comisión de la red 1,00 CHZ( ≈ 0,01 $) e Importe del retiro 2 CHZ como minimo*/Depósito mín.: 0,0001 CHZ**
CYBER = Comisión de la red 0,019 CYBER( ≈ 0,03 $) e Importe del retiro 0,038 CYBER como minimo*/Depósito mín.: 0,0003 CYBER**
DOGS = Comisión de la red 100,00 DOGS( ≈ 0,01 $) e Importe del retiro 1000 DOGS como minimo*/Depósito mín.: 0,02 DOGS**
DOT =  Comisión de la red 0,08 DOT( ≈ 0,30 $) e Importe del retiro 1,3 DOT como minimo*/Depósito mín.: 1,05 DOT** 
DYDX = Comisión de la red 0,01 DYDX( ≈ 0,01 $) e Importe del retiro 0,1 DYDX como minimo*/Depósito mín.: 0,0009 DYDX**
EGLD = Comisión de la red 8,99 FIDA( ≈ 0,01 $) e Importe del retiro 0,0015 EGLD como minimo*/Depósito mín.: 0,00004 EGLD**
ENJ = Comisión de la red 0,0003 ENJ( ≈ 0,001 $) e Importe del retiro 1 ENJ como minimo*/Depósito mín.: 0,006 ENJ
FIDA = Comisión de la red 0,0003 ENJ( ≈ 0,58 $) e Importe del retiro 17 FIDA como minimo*/Depósito mín.: 0,005 FIDA
FLOKI = Comisión de la red 175,00 FLOKI( ≈ 0,01 $) e Importe del retiro 350,00 FLOKI como minimo*/Depósito mín.: 0,01 FLOKI
FLOW = Comisión de la red 0,0001 FLOW( ≈ 0,001 $) e Importe del retiro 2,7 FLOW como minimo*/Depósito mín.: 0,0018 FLOW
GMT = Comisión de la red 0,29 GMT( ≈ 0,01 $) e Importe del retiro 0,58 GMT como minimo*/Depósito mín.: 0,008 GMT
GMX =  Comisión de la red 0,005 GMX( ≈ 0,01 $) e Importe del retiro 0,01 GMX como minimo*/Depósito mín.: 0,00005 GMX
HAEDAL = Comisión de la red 1,44 HAEDAL( ≈ 0,18 $) e Importe del retiro 2,88 HAEDAL como minimo*/Depósito mín.: 0,00000002 HAEDAL
HBAR = Comisión de la red 0,06 HBAR( ≈ 0,01 $) e Importe del retiro 2 HBAR como minimo*/Depósito mín.: 0,013 HBAR
HMSTR = Comisión de la red 108,00 HMSTR( ≈ 0,09 $) e Importe del retiro 216,00 HMSTR como minimo*/Depósito mín.: 0,02 HMSTR
HOME =  Comisión de la red 0,55 HOME( ≈ 0,01 $) e Importe del retiro 1,1 HOME como minimo*/Depósito mín.: 0,000002 HOME
HYPER = Comisión de la red 0,12 HYPER( ≈ 0,01 $) e Importe del retiro 0,24 HYPER como minimo*/Depósito mín.: 0,00000002 HYPER
ICP = Comisión de la red 0,0003 ICP( ≈ 0,0001 $) e Importe del retiro 0,001 ICP como minimo*/Depósito mín.: 0,0002 ICP
ICX = Comisión de la red 0,02 ICX( ≈ 0,0001 $) e Importe del retiro 0,04 ICX como minimo*/Depósito mín.: 0,008 ICX
INJ = Comisión de la red 0,01 INJ( ≈ 0,11 $) e Importe del retiro 0,1 INJ como minimo*/Depósito mín.: 0,00005 INJ 
IO = Comisión de la red 0,81 IO( ≈ 0,58 $) e Importe del retiro 1,62 IO como minimo*/Depósito mín.: 0,0005 IO
JUP = Comisión de la red 1,48 JUP( ≈ 0,59 $) e Importe del retiro 2,96 JUP como minimo*/Depósito mín.: 0,0013 JUP
KAIA = Comisión de la red 0,005 KAIA( ≈ 0,01 $) e Importe del retiro 100 KAIA como minimo*/Depósito mín.: 0,008 KAIA
KMNO = Comisión de la red 8,85 KMNO( ≈ 0,58 $) e Importe del retiro 17 KMNO como minimo*/Depósito mín.: 0,000002 KMNO
KSM = Comisión de la red 0,01 KSM( ≈ 0,14 $) e Importe del retiro 0,4 KSM como minimo*/Depósito mín.: 0,001 KSM
LUNA = Comisión de la red 0,01 LUNA( ≈ 0,001 $) e Importe del retiro 1 LUNA como minimo*/Depósito mín.: 0,0026 LUNA
MAGIC = Comisión de la red 1,15 MAGIC( ≈ 0,17 $) e Importe del retiro 2,3 MAGIC como minimo*/Depósito mín.: 0,003 MAGIC
MANTA = Comisión de la red 0,15 MANTA( ≈ 0,03 $) e Importe del retiro 0,42 MANTA como minimo*/Depósito mín.: 0,0012 MANTA
MBOX = Comisión de la red 0,29 MBOX( ≈ 0,01 $) e Importe del retiro 0,58 MBOX como minimo*/Depósito mín.: 0,0046 MBOX
MINA = Comisión de la red 0,90 MINA( ≈ 0,15 $) e Importe del retiro 5 MINA como minimo*/Depósito mín.: 0,004 MINA
NEAR = Comisión de la red 0,018 NEAR( ≈ 0,04 $) e Importe del retiro 6 NEAR como minimo*/Depósito mín.: 0,0002 NEAR
NOT = Comisión de la red 44,00 NOT( ≈ 0,09 $) e Importe del retiro 88,00 NOT como minimo*/Depósito mín.: 0,01 NOT
ONE = Comisión de la red 0,10 ONE( ≈ 0,001 $) e Importe del retiro 60 ONE como minimo*/Depósito mín.: 0,07 ONE
OP =  Comisión de la red 0,045 OP( ≈ 0,02 $) e Importe del retiro 0,09 OP como minimo*/Depósito mín.: 0,0006 OP
PSG = Comisión de la red 0,00 PSG( ≈ 0,001 $) e Importe del retiro 1  PSG como minimo*/Depósito mín.: 0,00000002 PSG
PYTH = Comisión de la red 0,00 PSG( ≈ 0,001 $) e Importe del retiro 1  PSG como minimo*/Depósito mín.: 0,004 PYTH
RDNT = Comisión de la red 8,26 RDNT( ≈ 0,17 $) e Importe del retiro 16  RDNT como minimo*/Depósito mín.: 0,03 RDN
ROSE = Comisión de la red 0,10 ROSE( ≈ 0,001 $) e Importe del retiro 1  ROSE como minimo*/Depósito mín.: 0,013 ROSE
SCRT = Comisión de la red 0,10 SCRT( ≈ 0,02 $) e Importe del retiro 5  SCRT como minimo*/Depósito mín.: 0,005 SCRT
SEI = Comisión de la red 0,40 SEI( ≈ 0,07 $) e Importe del retiro 5 SEI como minimo*/Depósito mín.: 0,004 SEI
SHIB = Comisión de la red 1 112,00 SHIB( ≈ 0,01 $) e Importe del retiro 2224,00 SHIB como minimo*/Depósito mín.: 1.1 SHIB
SIGN = Comisión de la red 0,19 SIGN( ≈ 0,01 $) e Importe del retiro 0,38 SIGN como minimo*/Depósito mín.: 0,00000003 SIGN
STX = Comisión de la red 1,00 STX( ≈ 0,60 $) e Importe del retiro 5 STX como minimo*/Depósito mín.: 0,0006 STX
SUI = Comisión de la red 0,06 SUI( ≈ 0,17 $) e Importe del retiro 1 SUI como minimo*/Depósito mín.: 0,0013 SUI
TIA = Comisión de la red 0,10 TIA( ≈ 0,17 $) e Importe del retiro 0,4 TIA como minimo*/Depósito mín.: 0,00015 TIA
TON = Comisión de la red 0,02 TON( ≈ 0,06 $) e Importe del retiro 0,4 TON como minimo*/Depósito mín.: 0,00000001 TON
TRUMP = Comisión de la red 0,062 TRUMP( ≈ 0,57 $) e Importe del retiro 0,12 TRUMP como minimo*/Depósito mín.: 0,000002 TRUMP
TRX = Comisión de la red 1,00 TRX( ≈ 0,27 $) e Importe del retiro 30,00 TRX como minimo*/Depósito mín.: 1 TRX    
WAXP = Comisión de la red 0,20 WAXP( ≈ 0,001 $) e Importe del retiro 7 WAXP como minimo*/Depósito mín.: 2 WAXP
WIF =  Comisión de la red 0,76 WIF( ≈ 0,001 $) e Importe del retiro 1,52 WIF como minimo*/Depósito mín.: 0,0006 WIF                                          
WCT = Comisión de la red 0,069 WCT( ≈ 0,001 $) e Importe del retiro 0,14 WCT como minimo*/Depósito mín.: 0,00000002 WCT
WLD = Comisión de la red 0,028 WLD( ≈ 0,03 $) e Importe del retiro 0,056 WLD como minimo*/Depósito mín.: 0,0004 WLD
XAI = Comisión de la red 3,25 XAI( ≈ 0,17 $) e Importe del retiro 6,5 XAI como minimo*/Depósito mín.: 0,0029 XAI
XLM = Comisión de la red 0,01 XLM( ≈ 0,001 $) e Importe del retiro 25 XLM como minimo*/Depósito mín.: 0,02 XLM
ZIL = Comisión de la red 1,00 ZIL( ≈ 0,01 $) e Importe del retiro 2,00 ZIL como minimo*/Depósito mín.: 0,07 ZIL
ZRO = Comisión de la red 0,04 ZRO( ≈ 0,07 $) e Importe del retiro 0,08 ZROL como minimo* /Depósito mín.: 0,00026 ZRO


BYBIT
USDT=  Comisión de la red 0.3 USDT( ≈ 0,30 $) e Importe del retiro 1 USDC como minimo* / Depósito mín.: 0,001 USDT*  
LTC =  Comisión de la red 0.0001 LTC e Importe del retiro 0.001 LTC como minimo* / Depósito mín.: 0,00000001 LTC*
BNB =  Comisión de la red 0.0002 BNB e Importe del retiro 0.0002 BNB como minimo*  / Depósito mín.: 0,000 BNB*
XRP =  Comisión de la red 0.2 XRP XRP e Importe del retiro 1.2 XRP como minimo*  / Depósito mín.: 0.01 XRP*
ALGO = Comisión de la red 0.01 ALGO e Importe del retiro 10 ALGO como minimo* / Depósito mín.: 1 ALGO
ANIME = Comisión de la red 16 ANIME ( ≈ 0,37 $) e Importe del retiro 30 ANIME como minimo* /Depósito mín.: 1 ANIME
APT = Comisión de la red 0.01 APT( ≈ 0,04 $) e Importe del retiro 0.01 APT como minimo* /Depósito mín.: 1 APT
ARB = Comisión de la red 0.4 ARB( ≈ 0,12 $) e Importe del retiro 0.4 ARB como minimo* /Depósito mín.:  0.00000001 ARB
ATOM = Comisión de la red 0.005 ATOM( ≈ 0,02 $) e Importe del retiro 0.015 ATOM como minimo* /Depósito mín.: 0.0001 ATOM       
AVAX = Comisión de la red 0.008 AVAX( ≈ 0,15 $) e Importe del retiro 0.008 AVAX como minimo* /Depósito mín.: 0 AVAX
AXL =  Comisión de la red 0.005 AXL( ≈ 0,005 $) e Importe del retiro 0.005 AXL como minimo* /  Depósito mín.: 0 AXL
BB = Comisión de la red 1 BB( ≈ 0,09 $) e Importe del retiro 1 BB como minimo* / Depósito mín.: 0 BB
BEL = Comisión de la red 0.12 BEL( ≈ 0,03 $) e Importe del retiro 0.12 BEL como minimo* / Depósito mín.: 0 BEL
BERA = Comisión de la red 0.000001 BERA( ≈ 0,01 $) e Importe del retiro 0.00001 BERA como minimo* /Depósito mín.: 0 BERA
BOME = Comisión de la red 400 BOME( ≈ 0,64 $) e Importe del retiro 200 BOME como minimo* / Depósito mín.: 0 BOME
BONK = Comisión de la red 40,000 BONK( ≈ 0,58 $) e Importe del retiro 50,000 BONK como minimo* /Depósito mín.: 0 BONK
C98 = Comisión de la red 0.3 C98( ≈ 0,01 $) e Importe del retiro 0.3 C98 como minimo* /Depósito mín.: 0 C98
CAKE = Comisión de la red 0.023 CAKE( ≈ 0,05 $) e Importe del retiro 0.023 CAKE como minimo* /Depósito mín.: 0 CAKE
CATI = Comisión de la red 0.3 CATI( ≈ 0,02 $) e Importe del retiro 0.3 CATI como minimo* /Depósito mín.: 0 CAT
CELO = Comisión de la red 0.001 CELO( ≈ 0,01 $) e Importe del retiro 0.002 CELO como minimo* /Depósito mín.: 0 CELO
CGPT = Comisión de la red 2 CGPT( ≈ 0,18 $) e Importe del retiro 2 CGPT como minimo* /Depósito mín.: 0 CGPT
CHZ =  Comisión de la red 0 CHZ( ≈ 0,01 $) e Importe del retiro  0,0002 CHZ como minimo* /Depósito mín.: 0 CHZ
CYBER = Comisión de la red 0.1 CYBER( ≈ 0,13 $) e Importe del retiro 0.1 CYBER como minimo* /Depósito mín.: 0 CYBER 
DOGS = Comisión de la red 50 DOGS( ≈ 0,01 $) e Importe del retiro 50 DOGS como minimo* /Depósito mín.: 0 DOGS
DOT = Comisión de la red 0.08 DOT( ≈ 0,30 $) e Importe del retiro 2 DOT como minimo* /Depósito mín.: 1.05 DOT
DYDX = Comisión de la red 0.2 DYDX( ≈ 0,10 $) e Importe del retiro 0.2 DYDX como minimo* /Depósito mín.: 0.000000000000000001 DYDX
EGLD = Comisión de la red 0.001 EGLD( ≈ 0,001 $) e Importe del retiro 0.01 EGLD como minimo* /Depósito mín.: 0 EGLD
ENJ = Comisión de la red 0.001 ENJ( ≈ 0,001 $) e Importe del retiro 0.1 ENJ como minimo* /Depósito mín.: 0 ENJ
FIDA = Comisión de la red 7 FIDA( ≈ 0,47 $) e Importe del retiro 1.5 FIDA como minimo* /Depósito mín.: 0 FIDA
FLOKI = Comisión de la red 2,617 FLOKI( ≈ 0,19 $) e Importe del retiro 2,617 FLOKI como minimo* /Depósito mín.: 0 FLOKI
FLOW = Comisión de la red 0.01 FLOW( ≈ 0,01 $) e Importe del retiro 0.01 FLOW como minimo* /Depósito mín.: 0 FLOW
GMT = Comisión de la red 0.25 GMT( ≈ 0,01 $) e Importe del retiro 0.25 GMT como minimo* /Depósito mín.: 0 GMT
GMX = Comisión de la red 0.006 GMX( ≈ 0,09 $) e Importe del retiro 0.006 GMX como minimo* /Depósito mín.: 0 GMX
HAEDAL = Comisión de la red 1 HAEDAL( ≈ 0,11 $) e Importe del retiro 1 HAEDAL como minimo* /Depósito mín.: 0 HAEDAL
HBAR = Comisión de la red 1 HBAR( ≈ 0,15 $) e Importe del retiro 2 HBAR como minimo* /Depósito mín.: 0 HBAR
HMSTR = Comisión de la red 80 HMSTR( ≈ 0,06 $) e Importe del retiro 80 HMSTR como minimo* /Depósito mín.: 0 HMSTR
HOME = Comisión de la red 20 HOME( ≈ 0,48 $) e Importe del retiro 40 HOME como minimo* /Depósito mín.: 0 HOME
HYPER = Comisión de la red 5 HYPER( ≈ 0,54 $) e Importe del retiro 10 HYPER como minimo* /Depósito mín.: 0 HYPER
ICP =  Comisión de la red 0.0003 ICP( ≈ 0,01 $) e Importe del retiro 0.0003 ICP como minimo* /Depósito mín.: 0 ICP
ICX = Comisión de la red 0.02 ICX( ≈ 0,02 $) e Importe del retiro 0.02 ICX como minimo* /Depósito mín.: 0 ICX 
INJ = Comisión de la red 0.008 INJ( ≈ 0,08 $) e Importe del retiro 0.008 INJ como minimo* /Depósito mín.: 0.000000000000000001 INJ
IO = Comisión de la red 1 IO( ≈ 0,68 $) e Importe del retiro 0.02 IO como minimo* /Depósito mín.: 0 IO
JUP = Comisión de la red 0.8 JUP( ≈ 0,31 $) e Importe del retiro 0.5 JUP como minimo* /Depósito mín.: 0 JUP
KAIA = Comisión de la red 0.1 KAIA( ≈ 0,01 $) e Importe del retiro 0.1 KAIAP como minimo* /Depósito mín.: 0 KAIA
KMNO = Comisión de la red 10 KMNO( ≈ 0,66 $) e Importe del retiro 10 KMNO como minimo* /Depósito mín.: 0 KMNO
KSM = Comisión de la red 0.01 KSM( ≈ 0,14 $) e Importe del retiro 0.01 KSM como minimo* /Depósito mín.: 0 KSM
LUNA = Comisión de la red 0.01 LUNA( ≈ 0,14 $) e Importe del retiro 0.01 LUNA como minimo* /Depósito mín.: 0 LUNA
MAGIC = Comisión de la red 0.3 MAGIC( ≈ 0,04 $) e Importe del retiro 0.3 MAGIC como minimo* /Depósito mín.: 12 MAGIC
MANTA = Comisión de la red 1 MANTA( ≈ 0,19 $) e Importe del retiro 2 MANTA como minimo* /Depósito mín.: 0 MANTA
MBOX = Comisión de la red 1 MBOX( ≈ 0,04 $) e Importe del retiro 1 MBOX como minimo* /Depósito mín.: 0 MBOX
MINA = Comisión de la red 0.5 MINA( ≈ 0,08 $) e Importe del retiro 2.5 MINA como minimo* /Depósito mín.: 0 MINA
NEAR = Comisión de la red 0.01 NEAR( ≈ 0,02 $) e Importe del retiro 0.2 NEAR como minimo* /Depósito mín.: 0 NEAR
NOT = Comisión de la red 30 NOT( ≈ 0,05 $) e Importe del retiro 30 NOT como minimo* /Depósito mín.: 0 NOT
ONE = Comisión de la red 0.1 ONE( ≈ 0,01 $) e Importe del retiro 60 ONE como minimo* /Depósito mín.: 0 ONE
OP = Comisión de la red 0.1 OP( ≈ 0,05 $) e Importe del retiro 0.1 OP como minimo* /Depósito mín.: 0 OP
PSG = Comisión de la red 0 PSG( ≈ 0,001 $) e Importe del retiro 0 PSG como minimo* /Depósito mín.: 0 PSG
PYTH = Comisión de la red 3 PYTH( ≈ 0,29 $) e Importe del retiro 2 PYTH como minimo* /Depósito mín.: 0 PYTH
RDNT = Comisión de la red 0.3 RDNT( ≈ 0,01 $) e Importe del retiro 0.3 RDNT como minimo* /Depósito mín.: 0 RDNT
ROSE = Comisión de la red 0.1 ROSE( ≈ 0,01 $) e Importe del retiro 0.1 ROSE como minimo* /Depósito mín.: 0 ROSE
SCRT = Comisión de la red 0.1 SCRT( ≈ 0,001 $) e Importe del retiro 0.1 SCRT como minimo* /Depósito mín.: 0 SCRT
SEI = Comisión de la red 0.2 SEI( ≈ 0,003 $) e Importe del retiro 0.2 SEI como minimo* /Depósito mín.: 0 SEI 
SHIB = Comisión de la red 7,000 SHIB( ≈ 0,008 $) e Importe del retiro 7,000 SHIB como minimo* /Depósito mín.: 0 SHIB
SIGN = Comisión de la red 1 SIGN( ≈ 0,006 $) e Importe del retiro 1 SIGN como minimo* /Depósito mín.: 0 SIGN
STX = Comisión de la red 1 STX( ≈ 0,061 $) e Importe del retiro 2 STX como minimo* /Depósito mín.: 0 STX
SUI = Comisión de la red 0.02 SUI( ≈ 0,05 $) e Importe del retiro 0.02 SUI como minimo* /Depósito mín.: 0 SUI
TIA = Comisión de la red 0.1 TIA( ≈ 0,16 $) e Importe del retiro 0.1 TIA como minimo* /Depósito mín.: 0 TIA 
TON = Comisión de la red 0.02 TON( ≈ 0,05 $) e Importe del retiro 0.02 TON como minimo* /Depósito mín.: 0.00000001 TON
TRUMP = Comisión de la red 0.05 TRUMP( ≈ 0,47 $) e Importe del retiro 0.1 TRUMP como minimo* /Depósito mín.: 0 TRUMP
TRX = Comisión de la red 1 TRX( ≈ 0,27 $) e Importe del retiro 1 TRX como minimo* /Depósito mín.: 1 TRX
WAXP = Comisión de la red 2 WAXP ( ≈ 0,04 $) e Importe del retiro 2 WAXP como minimo* /Depósito mín.: 0 WAXP
WIF = Comisión de la red 0.6 WIF ( ≈ 0,46 $) e Importe del retiro 0.6 WIF como minimo* /Depósito mín.: 0 WIF                                            WCT = Comisión de la red 1 WCT ( ≈ 0,35 $) e Importe del retiro 2 WCT como minimo* /Depósito mín.: 0 WCT
WLD =  Comisión de la red 0.2 WLD ( ≈ 0,18 $) e Importe del retiro 0.2 WLD como minimo* /Depósito mín.: 0 WLD
XAI = Comisión de la red 0.1 XAI ( ≈ 0,01 $) e Importe del retiro 0.2 XAI como minimo* /Depósito mín.: 0 XAI
XLM = Comisión de la red 0.02 XLM ( ≈ 0,01 $) e Importe del retiro 8 XLM como minimo* /Depósito mín.: 0 XLM
ZIL = Comisión de la red 0.2 ZIL ( ≈ 0,01 $) e Importe del retiro 0.4 ZIL como minimo* /Depósito mín.: 0 ZIL
ZRO = Comisión de la red 0.1 ZRO ( ≈ 0,18 $) e Importe del retiro 0.1 ZRO como minimo* /Depósito mín.: 0 ZRO



## 4. **Comisiones**
- Fee de trading en Binance y BYBIT para cada par
BINANCE 0.1% 
BYBIT   0.1%

- Fee (si existe) de depósito en ambos exchanges
BINANCE 0
BYBIT  0

## 5. **Balances iniciales**
- Cuánto capital tienes en USDT y/o en otros activos en cada exchange
BINANCE 20
BYBIT  20

## 6. **Umbrales y control de riesgo**
- Monto mínimo/máximo por operación
BINANCE 10
BYBIT  10

- Spread mínimo necesario para ejecutar arbitraje (porcentaje o cantidad neta)

- Slippage máximo tolerado
que me recomiendas ?
## 7. **Límites y reglas del exchange**
- Límites de retiro por día/mes
BINANCE NINGUNO 
BYBIT NINGUNO
- Límites de trading
BINANCE NINGUNO
BYBIT  NINGUNO
- Restricciones/regulaciones por país
BINANCE NINGUNO
BYBIT NINGUNO

===================================================================================================================================
BACKEND

ROUTES:

const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();
const configPath = path.join(__dirname, '..', 'config.js');

// GET config (ya lo tienes)
router.get('/config', (req, res) => {
  // Si usas module.exports = { ... }, haz require dinámico
  delete require.cache[require.resolve(configPath)];
  const config = require(configPath);
  res.json(config);
});

// PUT config (GUARDAR)
router.put('/config', express.json(), (req, res) => {
  const newConfig = req.body;
  // OJO: Sobreescribe config.js. Haz backup antes de producción.
  const fileContents = "module.exports = " + JSON.stringify(newConfig, null, 2);
  fs.writeFile(configPath, fileContents, (err) => {
    if (err) {
      console.error("Error guardando config.js:", err);
      return res.status(500).json({ error: "Error guardando configuración." });
    }
    res.json({ ok: true });
  });
});

module.exports = router;

------------------------------------------------------------------------------------------------------------

router.post('/rebalance', async (req, res) => {
  const { amount, fromExchange, toExchange, token } = req.body;
  try {
    if (amount && fromExchange && toExchange) {
      await portfolioManager.rebalanceCustom({ amount: Number(amount), fromExchange, toExchange, token });
      return res.json({ success: true, message: `Rebalanceo manual de ${amount} de ${fromExchange} a ${toExchange} ejecutado.` });
    } else {
      await portfolioManager.rebalancePortfolio();
      return res.json({ success: true, message: "Rebalanceo auto ejecutado." });
    }
  } catch (err) {
    console.error(err)
    return res.status(500).json({ success: false, message: err.message });
  }
});

----------------------------------------------------------------------------------------------------------------

const express = require("express");
const router = express.Router();
const path = require("path");
const configPath = path.join(__dirname, "..", "config.js");
const fs = require("fs");

// Cargar config como objeto JS común
function loadConfig() {
  delete require.cache[require.resolve(configPath)];
  return require(configPath);
}

// Guardar config sobrescribiendo el archivo config.js
function saveConfig(newConfig) {
  fs.writeFileSync(
    configPath,
    "module.exports = " + JSON.stringify(newConfig, null, 2) + ";"
  );
}

// GET /api/risk
router.get("/", (req, res) => {
  try {
    const config = loadConfig();
    res.json(config.RISK_MANAGEMENT || {});
  } catch (e) {
    res.status(500).json({ error: "No se pudo leer la configuración de riesgo", details: String(e) });
  }
});

// PUT /api/risk
router.put("/", (req, res) => {
  try {
    const config = loadConfig();
    config.RISK_MANAGEMENT = req.body;
    saveConfig(config);
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: "No se pudo guardar la configuración de riesgo", details: String(e) });
  }
});

module.exports = router;
-----------------------------------------------------------------------------------------------------
SRC

SRC/AI:

// ========== MÓDULO DE ASESOR DE TRADING CON IA ==========
// Soporte para IA heurística y Machine Learning avanzado (TensorFlow.js)
// Requiere: npm install @tensorflow/tfjs-node
const config = require('../strategies/config')
const EventEmitter = require('events');

let tf = null; // TensorFlow.js para Node

class AITradingAdvisor extends EventEmitter {
  constructor() {
    super();
    this.model = null
    this.modelType = config.AI_TRADING && config.AI_TRADING.MODE === "ml" ? "ml" : "heuristic";
    this.initialized = false
    this.marketData = {
      priceHistory: new Map(),
      volatilityHistory: new Map(),
      spreadHistory: new Map(),
      profitHistory: [],
    }

    this.initialize()
  }

  async initialize() {
    try {
      // Cargar modelo ML si está activado, sino heurístico
      this.model = await this.createModel()
      this.initialized = true
      console.log(`✅ Módulo de IA inicializado (${this.modelType})`)
    } catch (error) {
      console.error("❌ Error inicializando módulo de IA:", error.message)
    }
  }

  // ----------- ML avanzado ----------------
  async loadMLModel() {
    try {
      tf = require('@tensorflow/tfjs-node');
      // Asegúrate de tener model.json y archivos .bin en el path configurado
      this.model = await tf.loadLayersModel(`file://${config.AI_TRADING.MODEL_PATH}/model.json`);
      this.modelType = "ml";
      console.log("✅ Modelo ML (TensorFlow.js) cargado correctamente");
    } catch (err) {
      console.error("❌ Error cargando modelo ML, usando heurística. Detalle:", err.message);
      this.modelType = "heuristic";
      this.model = await this.createHeuristicModel();
    }
  }

  // ----------- Alternador de motor -----------
  async createModel() {
    if (config.AI_TRADING && config.AI_TRADING.MODE === "ml") {
      await this.loadMLModel();
      return this.model;
    }
    return this.createHeuristicModel();
  }

  createHeuristicModel() {
    console.log("🤖 Usando modelo heurístico simplificado (sin TensorFlow)");
    return {
      predict: (inputData) => {
        // Lógica heurística simple
        const [spread, volatility, hour, dayOfWeek, lastProfit, marketTrend] = inputData.dataSync
          ? inputData.dataSync()
          : inputData[0]

        let probability = 0.5 // Base

        // Ajustar por spread
        if (spread > 0.5) probability += 0.2
        if (spread > 1.0) probability += 0.1

        // Ajustar por volatilidad
        if (volatility < 2.0) probability += 0.1
        if (volatility > 5.0) probability -= 0.2

        // Ajustar por hora del día
        if (hour >= 8 && hour <= 16) probability += 0.1 // Horario activo

        // Ajustar por tendencia de mercado
        if (marketTrend > 0) probability += 0.1

        return { dataSync: () => [Math.min(0.95, Math.max(0.05, probability))] }
      },
    }
  }

  // Registrar datos de mercado para entrenamiento
  recordMarketData(pair, buyPrice, sellPrice, spread, volatility, wasSuccessful = null) {
    const now = new Date()
    const timestamp = now.getTime()
    const hour = now.getHours()
    const dayOfWeek = now.getDay()

    // Registrar precios
    if (!this.marketData.priceHistory.has(pair)) {
      this.marketData.priceHistory.set(pair, [])
    }
    this.marketData.priceHistory.get(pair).push({ buyPrice, sellPrice, timestamp })

    // Registrar spread
    if (!this.marketData.spreadHistory.has(pair)) {
      this.marketData.spreadHistory.set(pair, [])
    }
    this.marketData.spreadHistory.get(pair).push({ spread, timestamp })

    // Registrar volatilidad
    if (!this.marketData.volatilityHistory.has(pair)) {
      this.marketData.volatilityHistory.set(pair, [])
    }
    this.marketData.volatilityHistory.get(pair).push({ volatility, timestamp })

    // Registrar resultado si está disponible
    if (wasSuccessful !== null) {
      this.marketData.profitHistory.push({
        pair,
        spread,
        volatility,
        hour,
        dayOfWeek,
        wasSuccessful,
        timestamp,
      })
    }

    // Limitar el tamaño del historial
    this.pruneHistoricalData()
  }

  pruneHistoricalData() {
    const MAX_HISTORY_ITEMS = 1000
    const ONE_WEEK_MS = 7 * 24 * 60 * 60 * 1000
    const cutoffTime = Date.now() - ONE_WEEK_MS

    // Eliminar datos antiguos
    for (const [pair, history] of this.marketData.priceHistory.entries()) {
      this.marketData.priceHistory.set(
        pair,
        history.filter((item) => item.timestamp > cutoffTime).slice(-MAX_HISTORY_ITEMS),
      )
    }

    for (const [pair, history] of this.marketData.spreadHistory.entries()) {
      this.marketData.spreadHistory.set(
        pair,
        history.filter((item) => item.timestamp > cutoffTime).slice(-MAX_HISTORY_ITEMS),
      )
    }

    for (const [pair, history] of this.marketData.volatilityHistory.entries()) {
      this.marketData.volatilityHistory.set(
        pair,
        history.filter((item) => item.timestamp > cutoffTime).slice(-MAX_HISTORY_ITEMS),
      )
    }

    this.marketData.profitHistory = this.marketData.profitHistory
      .filter((item) => item.timestamp > cutoffTime)
      .slice(-MAX_HISTORY_ITEMS)
  }

  async trainModel() {
    if (this.marketData.profitHistory.length < 10) {
      return { success: false, message: "Datos insuficientes para entrenar el modelo heurístico" }
    }

    // Simular entrenamiento con heurísticas
    const recentSuccessRate = this.getRecentProfitTrend()

    console.log(`🤖 Modelo heurístico actualizado con ${this.marketData.profitHistory.length} datos históricos`)

    return {
      success: true,
      accuracy: (recentSuccessRate + 1) / 2, // Convertir de -1,1 a 0,1
      loss: 1 - (recentSuccessRate + 1) / 2,
    }
  }

  getRecentProfitTrend() {
    // Calcular tendencia de ganancias recientes (-1 a 1)
    const recentProfits = this.marketData.profitHistory.slice(-10)
    if (recentProfits.length < 5) return 0

    const successCount = recentProfits.filter((p) => p.wasSuccessful).length
    return (successCount / recentProfits.length) * 2 - 1
  }

  getMarketTrend(pair) {
    // Calcular tendencia del mercado (-1 a 1)
    const priceHistory = this.marketData.priceHistory.get(pair)
    if (!priceHistory || priceHistory.length < 10) return 0

    const recentPrices = priceHistory.slice(-10).map((p) => (p.buyPrice + p.sellPrice) / 2)
    const firstPrice = recentPrices[0]
    const lastPrice = recentPrices[recentPrices.length - 1]

    return (lastPrice - firstPrice) / firstPrice
  }

  // Ahora alterna ML y heurística
  async predictOpportunitySuccess(opportunity) {
    if (!this.initialized) {
      return { probability: 0.5, confidence: "LOW", engine: this.modelType }
    }

    try {
      const now = new Date()
      const hour = now.getHours()
      const dayOfWeek = now.getDay()

      // Preparar datos de entrada igual para ambos motores
      const inputData = [
        opportunity.grossProfit,
        this.getVolatility(opportunity.pair),
        hour / 24,
        dayOfWeek / 6,
        this.getRecentProfitTrend(),
        this.getMarketTrend(opportunity.pair),
      ]

      let probability = 0.5;

      if (this.modelType === "ml" && this.model && tf) {
        // ML: Usa tensor
        const inputTensor = tf.tensor2d([inputData]);
        const prediction = this.model.predict(inputTensor);
        probability = prediction.dataSync()[0];
      } else {
        // Heurístico
        const prediction = this.model.predict([inputData])
        probability = prediction.dataSync()[0]
      }

      // Determinar nivel de confianza
      let confidence = "MEDIUM"
      if (probability > 0.8 || probability < 0.2) {
        confidence = "HIGH"
      } else if (probability > 0.4 && probability < 0.6) {
        confidence = "LOW"
      }

      return { probability, confidence, engine: this.modelType }
    } catch (error) {
      console.error("Error en predicción:", error)
      return { probability: 0.5, confidence: "LOW", engine: this.modelType }
    }
  }

  getVolatility(pair) {
    const volatilityHistory = this.marketData.volatilityHistory.get(pair)
    if (!volatilityHistory || volatilityHistory.length === 0) return 0

    // Obtener volatilidad más reciente
    return volatilityHistory[volatilityHistory.length - 1].volatility
  }

  async generateTradingSuggestions(bot) {
    try {
      // Obtener oportunidades actuales
      const opportunities = await bot.findArbitrageOpportunities()

      // Analizar cada oportunidad con IA
      const enhancedOpportunities = await Promise.all(
        opportunities.map(async (opportunity) => {
          // Predecir probabilidad de éxito
          const prediction = await this.predictOpportunitySuccess(opportunity)

          // Calcular tamaño óptimo basado en confianza
          const optimalSize = this.calculateOptimalSize(opportunity, prediction.probability, prediction.confidence)

          // Analizar mejor momento para ejecutar
          const timing = this.analyzeTradingTiming(opportunity.pair)

          return {
            ...opportunity,
            aiPrediction: {
              successProbability: prediction.probability,
              confidence: prediction.confidence,
              optimalSize,
              recommendedTiming: timing.recommendation,
              reasoning: this.generateReasoning(opportunity, prediction, timing),
              engine: prediction.engine // Para saber si fue ML o heurístico
            },
          }
        }),
      )

      // Ordenar por probabilidad de éxito ajustada por profit
      const sortedOpportunities = enhancedOpportunities
        .filter((o) => o.profitable)
        .sort((a, b) => {
          const scoreA = a.aiPrediction.successProbability * a.finalProfit
          const scoreB = b.aiPrediction.successProbability * b.finalProfit
          return scoreB - scoreA
        })

      // Generar recomendaciones generales
      const generalRecommendations = this.generateGeneralRecommendations(bot)

      return {
        opportunities: sortedOpportunities,
        generalRecommendations,
        marketInsights: this.generateMarketInsights(),
        lastUpdated: new Date().toISOString(),
      }
    } catch (error) {
      console.error("Error generando sugerencias de trading:", error)
      return {
        opportunities: [],
        generalRecommendations: [
          {
            type: "ERROR",
            message: `Error generando sugerencias: ${error.message}`,
            importance: "HIGH",
          },
        ],
        lastUpdated: new Date().toISOString(),
      }
    }
  }

  calculateOptimalSize(opportunity, probability, confidence) {
    // Base: tamaño mínimo del par
    let size = opportunity.tradeAmount

    // Ajustar según probabilidad de éxito
    if (probability > 0.8) {
      // Alta probabilidad de éxito
      size = Math.min(size * 1.5, opportunity.pair.maxTradeAmount)
    } else if (probability < 0.4) {
      // Baja probabilidad de éxito
      size = Math.max(size * 0.5, opportunity.pair.minTradeAmount)
    }

    // Ajustar según nivel de confianza
    if (confidence === "LOW") {
      size = Math.max(size * 0.7, opportunity.pair.minTradeAmount)
    }

    return Number.parseFloat(size.toFixed(2))
  }

  analyzeTradingTiming(pair) {
    const now = new Date()
    const hour = now.getHours()

    // Analizar patrones históricos por hora
    const hourlySuccessRate = this.calculateHourlySuccessRate()
    const currentHourRate = hourlySuccessRate[hour] || 0.5

    let recommendation = "NEUTRAL"
    let reason = ""

    if (currentHourRate > 0.7) {
      recommendation = "EXECUTE_NOW"
      reason = `Alta tasa de éxito histórica (${(currentHourRate * 100).toFixed(1)}%) para esta hora del día`
    } else if (currentHourRate < 0.3) {
      recommendation = "WAIT"
      reason = `Baja tasa de éxito histórica (${(currentHourRate * 100).toFixed(1)}%) para esta hora del día`
    }

    // Verificar volatilidad reciente
    const recentVolatility = this.getRecentVolatility(pair)
    if (recentVolatility > 3.0) {
      recommendation = "WAIT"
      reason = `Alta volatilidad reciente (${recentVolatility.toFixed(1)}%)`
    }

    return { recommendation, reason }
  }

  calculateHourlySuccessRate() {
    const hourlyStats = Array(24)
      .fill(0)
      .map(() => ({ success: 0, total: 0 }))

    // Calcular estadísticas por hora
    this.marketData.profitHistory.forEach((item) => {
      const hour = new Date(item.timestamp).getHours()
      hourlyStats[hour].total++
      if (item.wasSuccessful) {
        hourlyStats[hour].success++
      }
    })

    // Calcular tasas de éxito
    return hourlyStats.map((stats) => (stats.total > 0 ? stats.success / stats.total : 0.5))
  }

  getRecentVolatility(pair) {
    const volatilityHistory = this.marketData.volatilityHistory.get(pair)
    if (!volatilityHistory || volatilityHistory.length < 5) return 0

    // Calcular volatilidad promedio de las últimas 5 mediciones
    const recentVolatilities = volatilityHistory.slice(-5).map((v) => v.volatility)
    return recentVolatilities.reduce((sum, vol) => sum + vol, 0) / recentVolatilities.length
  }

  generateReasoning(opportunity, prediction, timing) {
    const reasoning = []

    // Análisis de probabilidad
    if (prediction.probability > 0.8) {
      reasoning.push(`Alta probabilidad de éxito (${(prediction.probability * 100).toFixed(1)}%)`)
    } else if (prediction.probability < 0.4) {
      reasoning.push(`Baja probabilidad de éxito (${(prediction.probability * 100).toFixed(1)}%)`)
    } else {
      reasoning.push(`Probabilidad moderada de éxito (${(prediction.probability * 100).toFixed(1)}%)`)
    }

    // Análisis de profit
    if (opportunity.finalProfit > opportunity.pair.minProfit * 2) {
      reasoning.push(`Profit potencial alto (${opportunity.finalProfit.toFixed(2)}%)`)
    } else {
      reasoning.push(`Profit potencial moderado (${opportunity.finalProfit.toFixed(2)}%)`)
    }

    // Análisis de timing
    reasoning.push(timing.reason)

    // Análisis de riesgo
    const riskLevel = this.assessRiskLevel(opportunity)
    reasoning.push(`Nivel de riesgo: ${riskLevel.level} (${riskLevel.reason})`)

    return reasoning
  }

  assessRiskLevel(opportunity) {
    // Evaluar nivel de riesgo basado en múltiples factores
    let riskScore = 0
    const reasons = []

    // Factor 1: Volatilidad
    const volatility = this.getVolatility(opportunity.pair)
    if (volatility > 4.0) {
      riskScore += 2
      reasons.push(`alta volatilidad (${volatility.toFixed(1)}%)`)
    } else if (volatility > 2.0) {
      riskScore += 1
      reasons.push(`volatilidad moderada (${volatility.toFixed(1)}%)`)
    }

    // Factor 2: Spread sospechoso
    if (opportunity.grossProfit > config.SECURITY.SUSPICIOUS_PROFIT_THRESHOLD * 0.8) {
      riskScore += 2
      reasons.push(`spread inusualmente alto (${opportunity.grossProfit.toFixed(2)}%)`)
    }

    // Factor 3: Historial del par
    const pairHistory = this.getPairSuccessRate(opportunity.pair)
    if (pairHistory.rate < 0.4 && pairHistory.total > 5) {
      riskScore += 1
      reasons.push(`historial de éxito bajo (${(pairHistory.rate * 100).toFixed(1)}%)`)
    }

    // Determinar nivel
    let level = "BAJO"
    if (riskScore >= 3) {
      level = "ALTO"
    } else if (riskScore >= 1) {
      level = "MEDIO"
    }

    return {
      level,
      reason: reasons.length > 0 ? reasons.join(", ") : "sin factores de riesgo significativos",
    }
  }

  getPairSuccessRate(pair) {
    const pairHistory = this.marketData.profitHistory.filter((item) => item.pair === pair)

    if (pairHistory.length === 0) {
      return { rate: 0.5, total: 0 }
    }

    const successCount = pairHistory.filter((item) => item.wasSuccessful).length
    return {
      rate: successCount / pairHistory.length,
      total: pairHistory.length,
    }
  }

  generateGeneralRecommendations(bot) {
    const recommendations = []

    // Recomendación 1: Basada en rendimiento reciente
    const recentPerformance = this.analyzeRecentPerformance()
    if (recentPerformance.profitRate < 0.3 && recentPerformance.tradeCount > 5) {
      recommendations.push({
        type: "STRATEGY_ADJUSTMENT",
        message: `Considere ajustar parámetros de trading. Tasa de éxito reciente: ${(recentPerformance.profitRate * 100).toFixed(1)}%`,
        importance: "HIGH",
      })
    }

    // Recomendación 2: Basada en volatilidad del mercado
    const marketVolatility = this.getAverageMarketVolatility()
    if (marketVolatility > 4.0) {
      recommendations.push({
        type: "RISK_WARNING",
        message: `Alta volatilidad del mercado (${marketVolatility.toFixed(1)}%). Considere reducir tamaños de operación`,
        importance: "HIGH",
      })
    }

    // Recomendación 3: Oportunidad de rebalanceo
    if (bot.riskManager) {
      const imbalance = this.detectExchangeImbalance(bot)
      if (imbalance.detected) {
        recommendations.push({
          type: "REBALANCE",
          message: `Desbalance detectado: ${imbalance.message}`,
          importance: "MEDIUM",
        })
      }
    }

    // Recomendación 4: Mejores pares para trading
    const bestPairs = this.identifyBestPerformingPairs()
    if (bestPairs.length > 0) {
      recommendations.push({
        type: "PAIR_SUGGESTION",
        message: `Mejores pares por rendimiento: ${bestPairs.map((p) => p.pair).join(", ")}`,
        importance: "MEDIUM",
      })
    }

    return recommendations
  }

  analyzeRecentPerformance() {
    // Analizar rendimiento de las últimas 10 operaciones
    const recentTrades = this.marketData.profitHistory.slice(-10)

    if (recentTrades.length === 0) {
      return { profitRate: 0.5, tradeCount: 0 }
    }

    const successCount = recentTrades.filter((trade) => trade.wasSuccessful).length
    return {
      profitRate: successCount / recentTrades.length,
      tradeCount: recentTrades.length,
    }
  }

  getAverageMarketVolatility() {
    let totalVolatility = 0
    let pairCount = 0

    for (const [pair, history] of this.marketData.volatilityHistory.entries()) {
      if (history.length > 0) {
        // Obtener volatilidad promedio de las últimas 5 mediciones
        const recentVolatilities = history.slice(-5).map((v) => v.volatility)
        const avgVolatility = recentVolatilities.reduce((sum, vol) => sum + vol, 0) / recentVolatilities.length

        totalVolatility += avgVolatility
        pairCount++
      }
    }

    return pairCount > 0 ? totalVolatility / pairCount : 0
  }

  detectExchangeImbalance(bot) {
    try {
      // Verificar si hay un desbalance significativo entre exchanges
      const binanceBalance = bot.balanceCache.get("BINANCE")
      const kucoinBalance = bot.balanceCache.get("KUCOIN")

      if (!binanceBalance || !kucoinBalance) {
        return { detected: false }
      }

      const binanceUsdt = binanceBalance.balances.USDT?.total || 0
      const kucoinUsdt = kucoinBalance.balances.USDT?.total || 0

      const totalUsdt = binanceUsdt + kucoinUsdt
      const threshold = totalUsdt * 0.3 // 30% de desbalance

      if (Math.abs(binanceUsdt - kucoinUsdt) > threshold) {
        const fromExchange = binanceUsdt > kucoinUsdt ? "Binance" : "KuCoin"
        const toExchange = binanceUsdt > kucoinUsdt ? "KuCoin" : "Binance"
        const amount = Math.abs(binanceUsdt - kucoinUsdt) / 2

        return {
          detected: true,
          message: `Considere transferir ~${amount.toFixed(2)} USDT de ${fromExchange} a ${toExchange}`,
        }
      }

      return { detected: false }
    } catch (error) {
      console.error("Error detectando desbalance:", error)
      return { detected: false }
    }
  }

  identifyBestPerformingPairs() {
    const pairStats = new Map()

    // Recopilar estadísticas por par
    this.marketData.profitHistory.forEach((item) => {
      if (!pairStats.has(item.pair)) {
        pairStats.set(item.pair, { success: 0, total: 0 })
      }

      const stats = pairStats.get(item.pair)
      stats.total++
      if (item.wasSuccessful) {
        stats.success++
      }
    })

    // Convertir a array y calcular tasas
    const pairPerformance = Array.from(pairStats.entries())
      .map(([pair, stats]) => ({
        pair,
        successRate: stats.total > 0 ? stats.success / stats.total : 0,
        tradeCount: stats.total,
      }))
      .filter((item) => item.tradeCount >= 5) // Mínimo 5 operaciones

    // Ordenar por tasa de éxito
    pairPerformance.sort((a, b) => b.successRate - a.successRate)

    // Devolver los 3 mejores
    return pairPerformance.slice(0, 3)
  }

  generateMarketInsights() {
    return {
      marketVolatility: this.getAverageMarketVolatility(),
      bestTradingHours: this.identifyBestTradingHours(),
      recentTrends: this.identifyRecentTrends(),
      lastUpdated: new Date().toISOString(),
    }
  }

  identifyBestTradingHours() {
    const hourlySuccessRate = this.calculateHourlySuccessRate()

    // Encontrar las mejores horas (top 3)
    const hourRanking = hourlySuccessRate
      .map((rate, hour) => ({ hour, rate }))
      .filter((item) => item.rate > 0) // Solo horas con datos
      .sort((a, b) => b.rate - a.rate)
      .slice(0, 3)

    return hourRanking.map((item) => ({
      hour: item.hour,
      successRate: item.rate,
      formattedHour: `${item.hour}:00 - ${item.hour + 1}:00`,
    }))
  }

  identifyRecentTrends() {
    const trends = []

    // Analizar tendencias de precios por par
    for (const [pair, history] of this.marketData.priceHistory.entries()) {
      if (history.length < 10) continue

      // Obtener precios recientes
      const recentPrices = history.slice(-10).map((p) => (p.buyPrice + p.sellPrice) / 2)

      // Calcular tendencia
      const firstPrice = recentPrices[0]
      const lastPrice = recentPrices[recentPrices.length - 1]
      const percentChange = ((lastPrice - firstPrice) / firstPrice) * 100

      // Determinar dirección
      let direction = "NEUTRAL"
      if (percentChange > 1.0) {
        direction = "UP"
      } else if (percentChange < -1.0) {
        direction = "DOWN"
      }

      trends.push({
        pair,
        direction,
        percentChange,
        strength: Math.abs(percentChange) > 3.0 ? "STRONG" : "MODERATE",
      })
    }

    return trends
  }

  // ======= AGREGADO PARA DASHBOARD (RECOMENDACIONES SIMPLES) =======
  /**
   * Devuelve recomendaciones actuales simples para el dashboard.
   * (Puedes mejorar esta función para mostrar aún más información si lo deseas)
   */
  getCurrentRecommendations() {
    // Ejemplo básico usando heurística y datos simulados
    const now = new Date()
    const hour = now.getHours()
    const recs = []

    // Ejemplo de recomendación por horario
    if (hour >= 8 && hour <= 16) {
      recs.push({ texto: "Mayor volumen: operar con más confianza", probabilidad: 80 })
    } else {
      recs.push({ texto: "Mercado lento: precaución al operar", probabilidad: 55 })
    }

    // Ejemplo de profit reciente
    const perf = this.analyzeRecentPerformance()
    if (perf.profitRate > 0.7) {
      recs.push({ texto: "El bot está en racha positiva", probabilidad: Math.round(perf.profitRate * 100) })
    } else if (perf.profitRate < 0.3) {
      recs.push({ texto: "Racha negativa: considere cambiar la estrategia", probabilidad: Math.round((1 - perf.profitRate) * 100) })
    } else {
      recs.push({ texto: "Rendimiento estable, mantener parámetros", probabilidad: 60 })
    }

    // Sugerencia de par
    const bestPairs = this.identifyBestPerformingPairs()
    if (bestPairs.length > 0) {
      recs.push({ texto: `Mejores pares: ${bestPairs.map((p) => p.pair).join(", ")}`, probabilidad: 65 })
    }

    return recs
  }
}

module.exports = new AITradingAdvisor()

--------------------------------------------------------------------------------------------------------------

// ========== MOTOR DE MACHINE LEARNING AVANZADO ==========
const fs = require('fs').promises
const path = require('path')
const config = require("../strategies/config")

class MLEngine {
  constructor() {
    this.models = new Map()
    this.trainingData = []
    this.predictions = []
    this.modelAccuracy = new Map()
    this.featureImportance = new Map()
    this.lastTraining = 0
    this.minTrainingInterval = 3600000 // 1 hora
    
    this.initializeModels()
  }

  initializeModels() {
    // Modelo de predicción de precios
    this.models.set('PRICE_PREDICTION', {
      name: 'Predicción de Precios',
      type: 'REGRESSION',
      features: ['price', 'volume', 'rsi', 'macd', 'bollinger_position'],
      accuracy: 0.0,
      predictions: 0,
      correct: 0,
      lastTrained: 0,
    })

    // Modelo de detección de oportunidades
    this.models.set('OPPORTUNITY_DETECTION', {
      name: 'Detección de Oportunidades',
      type: 'CLASSIFICATION',
      features: ['spread', 'volume_ratio', 'price_volatility', 'market_sentiment'],
      accuracy: 0.0,
      predictions: 0,
      correct: 0,
      lastTrained: 0,
    })

    // Modelo de gestión de riesgo
    this.models.set('RISK_ASSESSMENT', {
      name: 'Evaluación de Riesgo',
      type: 'CLASSIFICATION',
      features: ['volatility', 'correlation', 'market_cap', 'liquidity'],
      accuracy: 0.0,
      predictions: 0,
      correct: 0,
      lastTrained: 0,
    })

    console.log('🤖 Modelos de ML inicializados:', Array.from(this.models.keys()))
  }

  async collectTrainingData(marketData, opportunity, result) {
    const features = this.extractFeatures(marketData, opportunity)
    
    const trainingPoint = {
      timestamp: Date.now(),
      features,
      opportunity,
      result,
      profit: result.profit || 0,
      success: result.success || false,
      executionTime: result.executionTime || 0,
    }

    this.trainingData.push(trainingPoint)

    // Mantener solo los últimos 10,000 puntos de datos
    if (this.trainingData.length > 10000) {
      this.trainingData = this.trainingData.slice(-10000)
    }

    // Entrenar modelos periódicamente
    if (this.shouldRetrain()) {
      await this.retrainModels()
    }
  }

  extractFeatures(marketData, opportunity) {
    return {
      // Características de precio
      price: opportunity.buyPrice,
      priceChange24h: marketData.priceChange24h || 0,
      volume24h: marketData.volume24h || 0,
      
      // Características técnicas
      rsi: this.calculateRSI(marketData.prices || []),
      macd: this.calculateMACD(marketData.prices || []),
      bollingerPosition: this.calculateBollingerPosition(marketData.prices || []),
      
      // Características de oportunidad
      spread: opportunity.finalProfit,
      volumeRatio: this.calculateVolumeRatio(marketData),
      priceVolatility: this.calculateVolatility(marketData.prices || []),
      
      // Características de mercado
      marketSentiment: this.calculateMarketSentiment(marketData),
      liquidity: marketData.liquidity || 0,
      correlation: this.calculateCorrelation(marketData),
      
      // Características temporales
      hourOfDay: new Date().getHours(),
      dayOfWeek: new Date().getDay(),
      isWeekend: [0, 6].includes(new Date().getDay()),
    }
  }

  calculateRSI(prices, period = 14) {
    if (prices.length < period + 1) return 50

    let gains = 0
    let losses = 0

    for (let i = 1; i <= period; i++) {
      const change = prices[prices.length - i] - prices[prices.length - i - 1]
      if (change > 0) gains += change
      else losses += Math.abs(change)
    }

    const avgGain = gains / period
    const avgLoss = losses / period
    
    if (avgLoss === 0) return 100
    
    const rs = avgGain / avgLoss
    return 100 - (100 / (1 + rs))
  }

  calculateMACD(prices, fastPeriod = 12, slowPeriod = 26) {
    if (prices.length < slowPeriod) return 0

    const fastEMA = this.calculateEMA(prices, fastPeriod)
    const slowEMA = this.calculateEMA(prices, slowPeriod)
    
    return fastEMA - slowEMA
  }

  calculateEMA(prices, period) {
    if (prices.length === 0) return 0
    
    const multiplier = 2 / (period + 1)
    let ema = prices[0]
    
    for (let i = 1; i < prices.length; i++) {
      ema = (prices[i] * multiplier) + (ema * (1 - multiplier))
    }
    
    return ema
  }

  calculateBollingerPosition(prices, period = 20) {
    if (prices.length < period) return 0.5

    const recentPrices = prices.slice(-period)
    const sma = recentPrices.reduce((a, b) => a + b) / period
    const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period
    const stdDev = Math.sqrt(variance)
    
    const currentPrice = prices[prices.length - 1]
    const upperBand = sma + (2 * stdDev)
    const lowerBand = sma - (2 * stdDev)
    
    // Posición entre 0 (banda inferior) y 1 (banda superior)
    return (currentPrice - lowerBand) / (upperBand - lowerBand)
  }

  calculateVolumeRatio(marketData) {
    const currentVolume = marketData.volume24h || 0
    const avgVolume = marketData.avgVolume || currentVolume
    return avgVolume > 0 ? currentVolume / avgVolume : 1
  }

  calculateVolatility(prices, period = 20) {
    if (prices.length < period) return 0

    const recentPrices = prices.slice(-period)
    const returns = []
    
    for (let i = 1; i < recentPrices.length; i++) {
      returns.push((recentPrices[i] - recentPrices[i-1]) / recentPrices[i-1])
    }
    
    const avgReturn = returns.reduce((a, b) => a + b) / returns.length
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
    
    return Math.sqrt(variance) * Math.sqrt(365) // Volatilidad anualizada
  }

  calculateMarketSentiment(marketData) {
    // Sentimiento simplificado basado en varios factores
    let sentiment = 0.5 // Neutral

    // Ajustar por cambio de precio
    if (marketData.priceChange24h > 0) sentiment += 0.1
    else if (marketData.priceChange24h < 0) sentiment -= 0.1

    // Ajustar por volumen
    const volumeRatio = this.calculateVolumeRatio(marketData)
    if (volumeRatio > 1.2) sentiment += 0.1
    else if (volumeRatio < 0.8) sentiment -= 0.1

    return Math.max(0, Math.min(1, sentiment))
  }

  calculateCorrelation(marketData) {
    // Correlación simplificada - en producción usar datos reales de múltiples activos
    return marketData.correlation || 0.5
  }

  shouldRetrain() {
    const now = Date.now()
    const hasEnoughData = this.trainingData.length >= 100
    const timeToRetrain = now - this.lastTraining > this.minTrainingInterval
    
    return hasEnoughData && timeToRetrain
  }

  async retrainModels() {
    console.log('🔄 Reentrenando modelos de ML...')
    
    try {
      for (const [modelName, model] of this.models.entries()) {
        await this.trainModel(modelName, model)
      }
      
      this.lastTraining = Date.now()
      console.log('✅ Modelos reentrenados exitosamente')
      
      // Guardar modelos entrenados
      await this.saveModels()
      
    } catch (error) {
      console.error('❌ Error reentrenando modelos:', error)
    }
  }

  async trainModel(modelName, model) {
    // Preparar datos de entrenamiento
    const trainingSet = this.prepareTrainingData(model)
    
    if (trainingSet.length < 50) {
      console.log(`⚠️ Datos insuficientes para entrenar ${modelName}`)
      return
    }

    // Simulación de entrenamiento (en producción usar TensorFlow.js o similar)
    const accuracy = this.simulateTraining(trainingSet, model)
    
    // Actualizar métricas del modelo
    model.accuracy = accuracy
    model.lastTrained = Date.now()
    
    console.log(`📊 Modelo ${modelName} entrenado - Precisión: ${(accuracy * 100).toFixed(2)}%`)
  }

  prepareTrainingData(model) {
    return this.trainingData
      .filter(point => point.features && point.result)
      .map(point => ({
        features: model.features.map(feature => point.features[feature] || 0),
        target: this.getTarget(point, model.type),
      }))
  }

  getTarget(dataPoint, modelType) {
    switch (modelType) {
      case 'REGRESSION':
        return dataPoint.profit || 0
      case 'CLASSIFICATION':
        return dataPoint.success ? 1 : 0
      default:
        return 0
    }
  }

  simulateTraining(trainingSet, model) {
    // Simulación simple de entrenamiento
    // En producción, aquí iría el algoritmo real de ML
    
    const correctPredictions = trainingSet.filter(point => {
      const prediction = this.makeSimplePrediction(point.features, model)
      const actual = point.target
      
      if (model.type === 'CLASSIFICATION') {
        return (prediction > 0.5 && actual === 1) || (prediction <= 0.5 && actual === 0)
      } else {
        return Math.abs(prediction - actual) < Math.abs(actual) * 0.1 // 10% de tolerancia
      }
    }).length

    return correctPredictions / trainingSet.length
  }

  makeSimplePrediction(features, model) {
    // Predicción simple basada en pesos aleatorios
    // En producción usar modelo entrenado real
    
    const weights = model.weights || features.map(() => Math.random() - 0.5)
    if (!model.weights) model.weights = weights
    
    let prediction = 0
    for (let i = 0; i < features.length; i++) {
      prediction += features[i] * weights[i]
    }
    
    return model.type === 'CLASSIFICATION' ? this.sigmoid(prediction) : prediction
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x))
  }

  async predictOpportunitySuccess(opportunity, marketData) {
    const features = this.extractFeatures(marketData, opportunity)
    const model = this.models.get('OPPORTUNITY_DETECTION')
    
    if (!model || model.accuracy < 0.6) {
      return { confidence: 0.5, prediction: 'UNCERTAIN', reason: 'Modelo no entrenado suficientemente' }
    }

    const featureVector = model.features.map(feature => features[feature] || 0)
    const prediction = this.makeSimplePrediction(featureVector, model)
    
    // Actualizar estadísticas del modelo
    model.predictions++
    
    return {
      confidence: prediction,
      prediction: prediction > 0.7 ? 'SUCCESS' : prediction < 0.3 ? 'FAILURE' : 'UNCERTAIN',
      reason: this.explainPrediction(featureVector, model),
      modelAccuracy: model.accuracy,
    }
  }

  async predictPriceMovement(pair, marketData, timeframe = '1h') {
    const features = this.extractFeatures(marketData, { pair })
    const model = this.models.get('PRICE_PREDICTION')
    
    if (!model || model.accuracy < 0.6) {
      return { direction: 'NEUTRAL', confidence: 0.5, change: 0 }
    }

    const featureVector = model.features.map(feature => features[feature] || 0)
    const prediction = this.makeSimplePrediction(featureVector, model)
    
    return {
      direction: prediction > 0.01 ? 'UP' : prediction < -0.01 ? 'DOWN' : 'NEUTRAL',
      confidence: Math.abs(prediction),
      change: prediction,
      timeframe,
    }
  }

  async assessRisk(opportunity, marketData) {
    const features = this.extractFeatures(marketData, opportunity)
    const model = this.models.get('RISK_ASSESSMENT')
    
    if (!model || model.accuracy < 0.6) {
      return { risk: 'MEDIUM', confidence: 0.5, factors: [] }
    }

    const featureVector = model.features.map(feature => features[feature] || 0)
    const riskScore = this.makeSimplePrediction(featureVector, model)
    
    const riskLevel = riskScore > 0.7 ? 'HIGH' : riskScore < 0.3 ? 'LOW' : 'MEDIUM'
    
    return {
      risk: riskLevel,
      score: riskScore,
      confidence: model.accuracy,
      factors: this.identifyRiskFactors(features),
    }
  }

  explainPrediction(features, model) {
    const weights = model.weights || []
    const contributions = features.map((feature, i) => ({
      feature: model.features[i],
      value: feature,
      weight: weights[i] || 0,
      contribution: feature * (weights[i] || 0),
    }))

    contributions.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution))
    
    const topFactors = contributions.slice(0, 3)
    return `Factores principales: ${topFactors.map(f => f.feature).join(', ')}`
  }

  identifyRiskFactors(features) {
    const factors = []
    
    if (features.priceVolatility > 0.3) factors.push('Alta volatilidad')
    if (features.volumeRatio < 0.5) factors.push('Volumen bajo')
    if (features.rsi > 80) factors.push('Sobrecompra (RSI)')
    if (features.rsi < 20) factors.push('Sobreventa (RSI)')
    if (features.spread < 0.2) factors.push('Spread muy bajo')
    
    return factors
  }

  async saveModels() {
    try {
      const modelsData = {
        models: Object.fromEntries(this.models),
        lastTraining: this.lastTraining,
        trainingDataCount: this.trainingData.length,
      }
      
      const modelsPath = path.join(__dirname, 'models.json')
      await fs.writeFile(modelsPath, JSON.stringify(modelsData, null, 2))
      
      console.log('💾 Modelos guardados exitosamente')
    } catch (error) {
      console.error('❌ Error guardando modelos:', error)
    }
  }

  async loadModels() {
    try {
      const modelsPath = path.join(__dirname, 'models.json')
      const data = await fs.readFile(modelsPath, 'utf8')
      const modelsData = JSON.parse(data)
      
      this.models = new Map(Object.entries(modelsData.models))
      this.lastTraining = modelsData.lastTraining || 0
      
      console.log('📂 Modelos cargados exitosamente')
    } catch (error) {
      console.log('ℹ️ No se encontraron modelos guardados, usando configuración por defecto')
    }
  }

  getModelStats() {
    const stats = {}
    
    for (const [name, model] of this.models.entries()) {
      stats[name] = {
        name: model.name,
        type: model.type,
        accuracy: model.accuracy,
        predictions: model.predictions,
        lastTrained: model.lastTrained,
        features: model.features.length,
      }
    }
    
    return {
      models: stats,
      trainingDataPoints: this.trainingData.length,
      lastTraining: this.lastTraining,
      nextTraining: this.lastTraining + this.minTrainingInterval,
    }
  }
}

module.exports = { MLEngine }

---------------------------------------------------------------------------------------------------------------

const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');

/**
 * Asesor de Trading con IA
 * Utiliza modelos de machine learning para analizar oportunidades y hacer recomendaciones
 */
class AITradingAdvisor extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.enabled = config.AI_TRADING.ENABLED;
        this.modelPath = config.AI_TRADING.MODEL_PATH;
        this.trainingDataDays = config.AI_TRADING.TRAINING_DATA_DAYS;
        this.predictionHorizon = config.AI_TRADING.PREDICTION_HORIZON;
        this.features = config.AI_TRADING.FEATURES;
        this.models = config.AI_TRADING.MODELS;
        this.autoRetrain = config.AI_TRADING.AUTO_RETRAIN;
        this.retrainThreshold = config.AI_TRADING.RETRAIN_THRESHOLD;
        
        this.priceModel = null;
        this.opportunityModel = null;
        this.riskModel = null;
        
        this.marketData = [];
        this.lastPredictions = {};
        this.modelAccuracy = {
            priceModel: 0,
            opportunityModel: 0,
            riskModel: 0
        };
        
        this.logger = console;
    }
    
    /**
     * Inicializa el asesor de IA
     */
    async initialize() {
        if (!this.enabled) {
            this.logger.info('AI Trading Advisor deshabilitado');
            return;
        }
        
        this.logger.info('Inicializando AI Trading Advisor...');
        
        try {
            // Crear directorio de modelos si no existe
            await this.ensureModelDirectory();
            
            // Cargar modelos existentes o crear nuevos
            await this.loadModels();
            
            this.logger.info('AI Trading Advisor inicializado correctamente');
        } catch (error) {
            this.logger.error('Error inicializando AI Trading Advisor:', error);
            throw error;
        }
    }
    
    /**
     * Asegura que el directorio de modelos exista
     */
    async ensureModelDirectory() {
        try {
            await fs.mkdir(this.modelPath, { recursive: true });
        } catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
    }
    
    /**
     * Carga los modelos de ML o crea nuevos si no existen
     */
    async loadModels() {
        try {
            // En una implementación real, aquí cargaríamos modelos de TensorFlow.js, ONNX, etc.
            // Para esta implementación, usaremos modelos simulados
            
            this.priceModel = await this.loadOrCreateModel('price_prediction');
            this.opportunityModel = await this.loadOrCreateModel('opportunity_scoring');
            this.riskModel = await this.loadOrCreateModel('risk_assessment');
            
            this.logger.info('Modelos cargados correctamente');
        } catch (error) {
            this.logger.error('Error cargando modelos:', error);
            throw error;
        }
    }
    
    /**
     * Carga un modelo específico o crea uno nuevo
     * @param {string} modelType - Tipo de modelo
     * @returns {Object} - Modelo cargado
     */
    async loadOrCreateModel(modelType) {
        const modelFilePath = path.join(this.modelPath, `${modelType}.json`);
        
        try {
            // Intentar cargar el modelo
            const modelData = await fs.readFile(modelFilePath, 'utf8');
            const model = JSON.parse(modelData);
            this.logger.info(`Modelo ${modelType} cargado correctamente`);
            return model;
        } catch (error) {
            // Si el modelo no existe, crear uno nuevo
            if (error.code === 'ENOENT') {
                this.logger.info(`Modelo ${modelType} no encontrado, creando uno nuevo...`);
                const newModel = await this.createModel(modelType);
                
                // Guardar el nuevo modelo
                await fs.writeFile(modelFilePath, JSON.stringify(newModel, null, 2));
                
                return newModel;
            }
            
            throw error;
        }
    }
    
    /**
     * Crea un nuevo modelo
     * @param {string} modelType - Tipo de modelo
     * @returns {Object} - Nuevo modelo
     */
    async createModel(modelType) {
        // En una implementación real, aquí crearíamos y entrenaríamos un modelo real
        // Para esta implementación, usaremos un modelo simulado
        
        switch (modelType) {
            case 'price_prediction':
                return {
                    type: 'lstm',
                    version: '1.0.0',
                    created: new Date().toISOString(),
                    weights: this.generateRandomWeights(100),
                    biases: this.generateRandomWeights(10),
                    config: this.models.PRICE_PREDICTION
                };
                
            case 'opportunity_scoring':
                return {
                    type: 'random_forest',
                    version: '1.0.0',
                    created: new Date().toISOString(),
                    trees: this.generateRandomTrees(this.models.OPPORTUNITY_SCORING.nEstimators),
                    config: this.models.OPPORTUNITY_SCORING
                };
                
            case 'risk_assessment':
                return {
                    type: 'gradient_boosting',
                    version: '1.0.0',
                    created: new Date().toISOString(),
                    trees: this.generateRandomTrees(this.models.RISK_ASSESSMENT.nEstimators),
                    config: this.models.RISK_ASSESSMENT
                };
                
            default:
                throw new Error(`Tipo de modelo desconocido: ${modelType}`);
        }
    }
    
    /**
     * Genera pesos aleatorios para simular un modelo
     * @param {number} size - Tamaño del array
     * @returns {Array} - Array de pesos aleatorios
     */
    generateRandomWeights(size) {
        return Array.from({ length: size }, () => Math.random() * 2 - 1);
    }
    
    /**
     * Genera árboles aleatorios para simular un modelo de bosque
     * @param {number} numTrees - Número de árboles
     * @returns {Array} - Array de árboles aleatorios
     */
    generateRandomTrees(numTrees) {
        return Array.from({ length: numTrees }, () => ({
            depth: Math.floor(Math.random() * 10) + 3,
            nodes: Math.floor(Math.random() * 100) + 20,
            weights: this.generateRandomWeights(20)
        }));
    }
    
    /**
     * Analiza oportunidades de arbitraje usando IA
     * @param {Array} opportunities - Lista de oportunidades
     * @returns {Array} - Oportunidades analizadas con recomendaciones
     */
    async analyzeOpportunities(opportunities) {
        if (!this.enabled || !opportunities.length) {
            return opportunities;
        }
        
        try {
            // Preparar datos para el análisis
            const preparedData = this.prepareDataForAnalysis(opportunities);
            
            // Predecir precios futuros
            const pricePredictions = await this.predictPrices(preparedData);
            
            // Evaluar oportunidades
            const scoredOpportunities = await this.scoreOpportunities(opportunities, pricePredictions);
            
            // Evaluar riesgos
            const riskAssessment = await this.assessRisks(scoredOpportunities);
            
            // Generar recomendaciones
            const recommendedOpportunities = this.generateRecommendations(riskAssessment);
            
            // Evaluar si se necesita cambiar de estrategia
            const strategyRecommendation = this.recommendStrategy(recommendedOpportunities);
            if (strategyRecommendation) {
                this.emit('recommendation', strategyRecommendation);
            }
            
            return recommendedOpportunities;
        } catch (error) {
            this.logger.error('Error analizando oportunidades con IA:', error);
            return opportunities; // Devolver oportunidades originales en caso de error
        }
    }
    
    /**
     * Prepara los datos para el análisis
     * @param {Array} opportunities - Lista de oportunidades
     * @returns {Object} - Datos preparados
     */
    prepareDataForAnalysis(opportunities) {
        // Extraer pares únicos
        const uniquePairs = [...new Set(opportunities.map(opp => opp.pair))];
        
        // Preparar datos por par
        const preparedData = {};
        
        for (const pair of uniquePairs) {
            const pairOpportunities = opportunities.filter(opp => opp.pair === pair);
            
            preparedData[pair] = {
                prices: pairOpportunities.map(opp => ({
                    exchange: opp.exchanges[0],
                    price: opp.buyPrice
                })),
                volumes: pairOpportunities.map(opp => ({
                    exchange: opp.exchanges[0],
                    volume: opp.volume || 1000 // Valor por defecto si no hay volumen
                })),
                spreads: pairOpportunities.map(opp => opp.profitPercentage),
                timestamp: Date.now()
            };
        }
        
        return preparedData;
    }
    
    /**
     * Predice precios futuros
     * @param {Object} data - Datos preparados
     * @returns {Object} - Predicciones de precios
     */
    async predictPrices(data) {
        // En una implementación real, aquí usaríamos el modelo LSTM para predecir precios
        // Para esta implementación, usaremos predicciones simuladas
        
        const predictions = {};
        
        for (const pair in data) {
            predictions[pair] = {};
            
            for (const priceData of data[pair].prices) {
                const exchange = priceData.exchange;
                const currentPrice = priceData.price;
                
                // Simular predicción con una variación aleatoria de ±2%
                const randomFactor = 1 + (Math.random() * 0.04 - 0.02);
                predictions[pair][exchange] = currentPrice * randomFactor;
            }
        }
        
        return predictions;
    }
    
    /**
     * Evalúa y puntúa oportunidades
     * @param {Array} opportunities - Lista de oportunidades
     * @param {Object} pricePredictions - Predicciones de precios
     * @returns {Array} - Oportunidades puntuadas
     */
    async scoreOpportunities(opportunities, pricePredictions) {
        return opportunities.map(opportunity => {
            const { pair, exchanges } = opportunity;
            
            // Obtener predicciones para este par y exchanges
            const buyExchange = exchanges[0];
            const sellExchange = exchanges[1];
            
            let predictedProfit = opportunity.profitPercentage;
            
            // Si tenemos predicciones para ambos exchanges, calcular ganancia predicha
            if (pricePredictions[pair] && 
                pricePredictions[pair][buyExchange] && 
                pricePredictions[pair][sellExchange]) {
                
                const predictedBuyPrice = pricePredictions[pair][buyExchange];
                const predictedSellPrice = pricePredictions[pair][sellExchange];
                
                predictedProfit = ((predictedSellPrice - predictedBuyPrice) / predictedBuyPrice) * 100;
            }
            
            // Calcular puntuación basada en ganancia actual y predicha
            const score = this.calculateOpportunityScore(opportunity, predictedProfit);
            
            return {
                ...opportunity,
                aiScore: score,
                predictedProfit
            };
        });
    }
    
    /**
     * Calcula la puntuación de una oportunidad
     * @param {Object} opportunity - Oportunidad de arbitraje
     * @param {number} predictedProfit - Ganancia predicha
     * @returns {number} - Puntuación (0-100)
     */
    calculateOpportunityScore(opportunity, predictedProfit) {
        // Factores para la puntuación
        const currentProfitWeight = 0.4;
        const predictedProfitWeight = 0.3;
        const volumeWeight = 0.15;
        const exchangeReliabilityWeight = 0.15;
        
        // Normalizar ganancia actual (0-100)
        const normalizedCurrentProfit = Math.min(opportunity.profitPercentage * 20, 100);
        
        // Normalizar ganancia predicha (0-100)
        const normalizedPredictedProfit = Math.min(predictedProfit * 20, 100);
        
        // Normalizar volumen (asumiendo que mayor volumen es mejor, hasta cierto punto)
        const volume = opportunity.volume || 1000; // Valor por defecto
        const normalizedVolume = Math.min(volume / 10000 * 100, 100);
        
        // Fiabilidad de exchanges (valores simulados)
        const exchangeReliability = {
            'Binance': 95,
            'Coinbase': 90,
            'Kraken': 85,
            'Kucoin': 80
        };
        
        // Calcular fiabilidad promedio de los exchanges involucrados
        const avgExchangeReliability = opportunity.exchanges.reduce((sum, exchange) => {
            return sum + (exchangeReliability[exchange] || 70);
        }, 0) / opportunity.exchanges.length;
        
        // Calcular puntuación final
        const score = (
            normalizedCurrentProfit * currentProfitWeight +
            normalizedPredictedProfit * predictedProfitWeight +
            normalizedVolume * volumeWeight +
            avgExchangeReliability * exchangeReliabilityWeight
        );
        
        return Math.round(score);
    }
    
    /**
     * Evalúa los riesgos de las oportunidades
     * @param {Array} opportunities - Oportunidades puntuadas
     * @returns {Array} - Oportunidades con evaluación de riesgo
     */
    async assessRisks(opportunities) {
        return opportunities.map(opportunity => {
            // En una implementación real, aquí usaríamos el modelo de evaluación de riesgos
            // Para esta implementación, usaremos una evaluación simulada
            
            // Factores de riesgo
            const volatilityRisk = Math.random() * 40; // 0-40
            const liquidityRisk = Math.random() * 30; // 0-30
            const exchangeRisk = Math.random() * 20; // 0-20
            const timingRisk = Math.random() * 10; // 0-10
            
            // Riesgo total (0-100)
            const totalRisk = volatilityRisk + liquidityRisk + exchangeRisk + timingRisk;
            
            // Categoría de riesgo
            let riskCategory;
            if (totalRisk < 30) {
                riskCategory = 'low';
            } else if (totalRisk < 60) {
                riskCategory = 'medium';
            } else {
                riskCategory = 'high';
            }
            
            return {
                ...opportunity,
                riskAssessment: {
                    volatilityRisk,
                    liquidityRisk,
                    exchangeRisk,
                    timingRisk,
                    totalRisk,
                    riskCategory
                }
            };
        });
    }
    
    /**
     * Genera recomendaciones finales
     * @param {Array} opportunities - Oportunidades con evaluación de riesgo
     * @returns {Array} - Oportunidades con recomendaciones
     */
    generateRecommendations(opportunities) {
        return opportunities.map(opportunity => {
            // Calcular puntuación final (score - riesgo)
            const finalScore = opportunity.aiScore - (opportunity.riskAssessment.totalRisk / 2);
            
            // Determinar acción recomendada
            let action;
            if (finalScore >= 70) {
                action = 'execute'; // Ejecutar inmediatamente
            } else if (finalScore >= 50) {
                action = 'monitor'; // Monitorear para posible ejecución
            } else {
                action = 'ignore'; // Ignorar esta oportunidad
            }
            
            // Determinar tamaño de inversión recomendado
            let recommendedSize;
            if (finalScore >= 80) {
                recommendedSize = 1.0; // 100% del tamaño máximo
            } else if (finalScore >= 70) {
                recommendedSize = 0.75; // 75% del tamaño máximo
            } else if (finalScore >= 60) {
                recommendedSize = 0.5; // 50% del tamaño máximo
            } else {
                recommendedSize = 0.25; // 25% del tamaño máximo
            }
            
            return {
                ...opportunity,
                aiRecommendation: {
                    finalScore,
                    action,
                    recommendedSize,
                    confidence: finalScore / 100,
                    reasoning: this.generateReasoning(opportunity, finalScore)
                }
            };
        });
    }
    
    /**
     * Genera un razonamiento para la recomendación
     * @param {Object} opportunity - Oportunidad evaluada
     * @param {number} finalScore - Puntuación final
     * @returns {string} - Razonamiento
     */
    generateReasoning(opportunity, finalScore) {
        const { profitPercentage, predictedProfit, riskAssessment } = opportunity;
        
        if (finalScore >= 70) {
            return `Alta probabilidad de ganancia (${profitPercentage.toFixed(2)}% actual, ${predictedProfit.toFixed(2)}% predicha) con riesgo ${riskAssessment.riskCategory}.`;
        } else if (finalScore >= 50) {
            return `Ganancia moderada (${profitPercentage.toFixed(2)}%) con algunas señales de precaución. Riesgo ${riskAssessment.riskCategory}.`;
        } else {
            return `Baja probabilidad de éxito. Ganancia insuficiente (${profitPercentage.toFixed(2)}%) para el nivel de riesgo ${riskAssessment.riskCategory}.`;
        }
    }
    
    /**
     * Recomienda cambios de estrategia basados en el análisis
     * @param {Array} opportunities - Oportunidades analizadas
     * @returns {Object|null} - Recomendación de estrategia o null
     */
    recommendStrategy(opportunities) {
        // Contar oportunidades por estrategia
        const strategyCounts = {};
        const strategyScores = {};
        
        for (const opp of opportunities) {
            if (!opp.strategy) continue;
            
            if (!strategyCounts[opp.strategy]) {
                strategyCounts[opp.strategy] = 0;
                strategyScores[opp.strategy] = 0;
            }
            
            strategyCounts[opp.strategy]++;
            strategyScores[opp.strategy] += opp.aiRecommendation.finalScore;
        }
        
        // Calcular puntuación promedio por estrategia
        for (const strategy in strategyCounts) {
            strategyScores[strategy] /= strategyCounts[strategy];
        }
        
        // Encontrar la estrategia con mejor puntuación
        let bestStrategy = null;
        let bestScore = 0;
        
        for (const strategy in strategyScores) {
            if (strategyScores[strategy] > bestScore) {
                bestScore = strategyScores[strategy];
                bestStrategy = strategy;
            }
        }
        
        // Si la mejor estrategia tiene una puntuación significativamente mejor, recomendarla
        if (bestStrategy && bestScore > 60) {
            return {
                suggestedStrategy: bestStrategy,
                score: bestScore,
                reason: `La estrategia ${bestStrategy} muestra el mejor rendimiento con una puntuación de ${bestScore.toFixed(2)}.`
            };
        }
        
        return null;
    }
    
    /**
     * Actualiza los datos de mercado para entrenamiento
     * @param {Object} marketData - Nuevos datos de mercado
     */
    updateMarketData(marketData) {
        this.marketData.push({
            ...marketData,
            timestamp: Date.now()
        });
        
        // Mantener solo los datos de los últimos N días
        const cutoffTime = Date.now() - (this.trainingDataDays * 24 * 60 * 60 * 1000);
        this.marketData = this.marketData.filter(data => data.timestamp >= cutoffTime);
        
        // Verificar si es necesario reentrenar
        if (this.autoRetrain && this.shouldRetrain()) {
            this.retrainModels();
        }
    }
    
    /**
     * Determina si es necesario reentrenar los modelos
     * @returns {boolean} - True si se debe reentrenar
     */
    shouldRetrain() {
        // Verificar si hay suficientes datos nuevos
        if (this.marketData.length < 1000) {
            return false;
        }
        
        // Verificar si la precisión ha caído por debajo del umbral
        for (const model in this.modelAccuracy) {
            if (this.modelAccuracy[model] < 1 - this.retrainThreshold) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Reentrenar los modelos con nuevos datos
     */
    async retrainModels() {
        this.logger.info('Reentrenando modelos de IA...');
        
        try {
            // En una implementación real, aquí reentrenaremos los modelos
            // Para esta implementación, simularemos el reentrenamiento
            
            // Simular reentrenamiento del modelo de predicción de precios
            await this.retrainPriceModel();
            
            // Simular reentrenamiento del modelo de puntuación de oportunidades
            await this.retrainOpportunityModel();
            
            // Simular reentrenamiento del modelo de evaluación de riesgos
            await this.retrainRiskModel();
            
            this.logger.info('Modelos reentrenados correctamente');
        } catch (error) {
            this.logger.error('Error reentrenando modelos:', error);
        }
    }
    
    /**
     * Reentrenar el modelo de predicción de precios
     */
    async retrainPriceModel() {
        // Simular reentrenamiento
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Actualizar modelo simulado
        this.priceModel.version = `${parseFloat(this.priceModel.version) + 0.1}.0`;
        this.priceModel.updated = new Date().toISOString();
        this.priceModel.weights = this.generateRandomWeights(100);
        this.priceModel.biases = this.generateRandomWeights(10);
        
        // Simular mejora en precisión
        this.modelAccuracy.priceModel = 0.85 + Math.random() * 0.1;
        
        // Guardar modelo actualizado
        await fs.writeFile(
            path.join(this.modelPath, 'price_prediction.json'),
            JSON.stringify(this.priceModel, null, 2)
        );
    }
    
    /**
     * Reentrenar el modelo de puntuación de oportunidades
     */
    async retrainOpportunityModel() {
        // Simular reentrenamiento
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Actualizar modelo simulado
        this.opportunityModel.version = `${parseFloat(this.opportunityModel.version) + 0.1}.0`;
        this.opportunityModel.updated = new Date().toISOString();
        this.opportunityModel.trees = this.generateRandomTrees(this.models.OPPORTUNITY_SCORING.nEstimators);
        
        // Simular mejora en precisión
        this.modelAccuracy.opportunityModel = 0.82 + Math.random() * 0.12;
        
        // Guardar modelo actualizado
        await fs.writeFile(
            path.join(this.modelPath, 'opportunity_scoring.json'),
            JSON.stringify(this.opportunityModel, null, 2)
        );
    }
    
    /**
     * Reentrenar el modelo de evaluación de riesgos
     */
    async retrainRiskModel() {
        // Simular reentrenamiento
        await new Promise(resolve => setTimeout(resolve, 600));
        
        // Actualizar modelo simulado
        this.riskModel.version = `${parseFloat(this.riskModel.version) + 0.1}.0`;
        this.riskModel.updated = new Date().toISOString();
        this.riskModel.trees = this.generateRandomTrees(this.models.RISK_ASSESSMENT.nEstimators);
        
        // Simular mejora en precisión
        this.modelAccuracy.riskModel = 0.8 + Math.random() * 0.15;
        
        // Guardar modelo actualizado
        await fs.writeFile(
            path.join(this.modelPath, 'risk_assessment.json'),
            JSON.stringify(this.riskModel, null, 2)
        );
    }
    
    /**
     * Obtiene el estado actual del asesor de IA
     * @returns {Object} - Estado del asesor
     */
    getStatus() {
        return {
            enabled: this.enabled,
            models: {
                priceModel: {
                    version: this.priceModel?.version || 'N/A',
                    accuracy: this.modelAccuracy.priceModel || 0
                },
                opportunityModel: {
                    version: this.opportunityModel?.version || 'N/A',
                    accuracy: this.modelAccuracy.opportunityModel || 0
                },
                riskModel: {
                    version: this.riskModel?.version || 'N/A',
                    accuracy: this.modelAccuracy.riskModel || 0
                }
            },
            dataPoints: this.marketData.length,
            lastUpdated: this.marketData.length ? new Date(Math.max(...this.marketData.map(d => d.timestamp))).toISOString() : 'N/A'
        };
    }
}

module.exports = AITradingAdvisor;

-----------------------------------------------------------------------------------------------------------------------

ALERTS

const https = require("https")
const EventEmitter = require("events")
const nodemailer = require("nodemailer")
const axios = require("axios")

/**
 * Gestor de Alertas para el Bot de Arbitraje
 */
class AlertManager extends EventEmitter {
  constructor(config) {
    super()
    this.config = config
    this.enabled = config.ALERTS.ENABLED
    this.channels = config.ALERTS.CHANNELS
    this.alertTypes = config.ALERTS.ALERT_TYPES

    this.emailTransporter = null
    this.alertHistory = []
    this.alertQueue = []
    this.isProcessingQueue = false

    this.logger = console

    // ======= AGREGADO DASHBOARD: historial reciente de anomalías =======
    this.anomalies = []
    // ======= FIN AGREGADO =======
  }

  /**
   * Inicializa el gestor de alertas
   */
  async initialize() {
    if (!this.enabled) {
      this.logger.info("Alert Manager deshabilitado")
      return
    }

    this.logger.info("Inicializando Alert Manager...")

    try {
      // Inicializar transportador de email
      if (this.channels.EMAIL.enabled) {
        await this.initializeEmailTransporter()
      }

      // Verificar configuración de Telegram
      if (this.channels.TELEGRAM.enabled) {
        await this.verifyTelegramConfig()
      }

      // Iniciar procesamiento de cola
      this.startQueueProcessor()

      // Programar resumen diario
      this.scheduleDailySummary()

      this.logger.info("Alert Manager inicializado correctamente")

      // ENVIAR MENSAJE DE PRUEBA AL INICIALIZAR - CAMBIADO A BOT_STARTED
      await this.sendAlert("BOT_STARTED", "🤖 Bot de Arbitraje iniciado correctamente")
    } catch (error) {
      this.logger.error("Error inicializando Alert Manager:", error)
      throw error
    }
  }

  /**
   * Inicializa el transportador de email
   */
  async initializeEmailTransporter() {
    try {
      this.emailTransporter = nodemailer.createTransport(this.channels.EMAIL.smtp)

      // Verificar configuración
      await this.emailTransporter.verify()
      this.logger.info("Transportador de email configurado correctamente")
    } catch (error) {
      this.logger.error("Error configurando email:", error)
      this.channels.EMAIL.enabled = false
    }
  }

  /**
   * Verifica la configuración de Telegram
   */
  async verifyTelegramConfig() {
    try {
      const { botToken, chatId } = this.channels.TELEGRAM

      // VERIFICAR QUE LAS VARIABLES ESTÉN CONFIGURADAS
      this.logger.info("=== VERIFICANDO CONFIGURACIÓN DE TELEGRAM ===")
      this.logger.info("Bot Token:", botToken ? "CONFIGURADO" : "NO CONFIGURADO")
      this.logger.info("Chat ID:", chatId ? "CONFIGURADO" : "NO CONFIGURADO")

      if (!botToken || botToken === "") {
        throw new Error("TELEGRAM_BOT_TOKEN no está configurado en las variables de entorno")
      }

      if (!chatId || chatId === "") {
        throw new Error("TELEGRAM_CHAT_ID no está configurado en las variables de entorno")
      }

      // Verificar que el bot esté activo
      const response = await axios.get(`https://api.telegram.org/bot${botToken}/getMe`)

      if (response.data.ok) {
        this.logger.info(`✅ Bot de Telegram verificado: ${response.data.result.username}`)
      } else {
        throw new Error("Token de bot de Telegram inválido")
      }
    } catch (error) {
      this.logger.error("❌ Error verificando Telegram:", error.message)
      // NO DESHABILITAR TELEGRAM, SOLO MOSTRAR EL ERROR
      // this.channels.TELEGRAM.enabled = false;
    }
  }

  /**
   * Inicia el procesador de cola de alertas
   */
  startQueueProcessor() {
    setInterval(async () => {
      if (!this.isProcessingQueue && this.alertQueue.length > 0) {
        await this.processAlertQueue()
      }
    }, 1000)
  }

  /**
   * Procesa la cola de alertas
   */
  async processAlertQueue() {
    this.isProcessingQueue = true

    while (this.alertQueue.length > 0) {
      const alert = this.alertQueue.shift()

      try {
        await this.sendAlertToChannels(alert)
      } catch (error) {
        this.logger.error("Error procesando alerta:", error)
      }

      // Pequeña pausa entre alertas
      await new Promise((resolve) => setTimeout(resolve, 100))
    }

    this.isProcessingQueue = false
  }

  /**
   * Programa el resumen diario
   */
  scheduleDailySummary() {
    if (!this.alertTypes.DAILY_SUMMARY.enabled) {
      return
    }

    const summaryTime = this.alertTypes.DAILY_SUMMARY.time || "23:59"
    const [hours, minutes] = summaryTime.split(":").map(Number)

    // Calcular tiempo hasta el próximo resumen
    const now = new Date()
    const nextSummary = new Date()
    nextSummary.setHours(hours, minutes, 0, 0)

    if (nextSummary <= now) {
      nextSummary.setDate(nextSummary.getDate() + 1)
    }

    const timeUntilSummary = nextSummary.getTime() - now.getTime()

    setTimeout(() => {
      this.sendDailySummary()

      // Programar para el día siguiente
      setInterval(
        () => {
          this.sendDailySummary()
        },
        24 * 60 * 60 * 1000,
      )
    }, timeUntilSummary)
  }

  /**
   * Envía una alerta
   * @param {string} type - Tipo de alerta ('info', 'warning', 'error', 'trade', 'risk')
   * @param {string} message - Mensaje de la alerta
   * @param {Object} data - Datos adicionales
   */
  async sendAlert(type, message, data = {}) {
    if (!this.enabled) {
      this.logger.info("Alertas deshabilitadas, no se enviará:", message)
      return
    }

    // BUSCAR CONFIGURACIÓN DE ALERTA O USAR VALORES POR DEFECTO
    const alertConfig = this.alertTypes[type.toUpperCase()] || {
      enabled: true,
      channels: ["telegram"],
      priority: "medium",
    }

    if (!alertConfig.enabled) {
      this.logger.info(`Tipo de alerta ${type} deshabilitado`)
      return
    }

    // Crear objeto de alerta
    const alert = {
      id: this.generateAlertId(),
      type,
      message,
      data,
      timestamp: new Date(),
      priority: alertConfig.priority || "medium",
      channels: alertConfig.channels || ["telegram"],
    }

    this.logger.info(`📢 Enviando alerta: ${type} - ${message}`)

    // Añadir a la cola
    this.alertQueue.push(alert)

    // Añadir al historial
    this.alertHistory.push(alert)

    // ======= AGREGADO DASHBOARD: guardar anomalías si corresponde =======
    if (type && (type.toUpperCase().includes("ANOMALY") || type.toUpperCase().includes("ANOMALIA") || type.toUpperCase().includes("RISK") || type.toUpperCase().includes("VOLATILIDAD") || type.toUpperCase().includes("OPPORTUNITY"))) {
      this.anomalies.push({
        tipo: type,
        descripcion: message,
        timestamp: new Date().toLocaleString(),
        data: data || {},
      })
      if (this.anomalies.length > 100) {
        this.anomalies.shift()
      }
    }
    // ======= FIN AGREGADO DASHBOARD =======

    // Mantener solo las últimas 1000 alertas
    if (this.alertHistory.length > 1000) {
      this.alertHistory.shift()
    }

    // Emitir evento
    this.emit("alertSent", alert)
  }

  /**
   * Envía una alerta a todos los canales configurados
   */
  async sendAlertToChannels(alert) {
    const promises = []

    for (const channel of alert.channels) {
      switch (channel.toLowerCase()) {
        case "email":
          if (this.channels.EMAIL.enabled) {
            promises.push(this.sendEmailAlert(alert))
          }
          break

        case "telegram":
          if (this.channels.TELEGRAM.enabled) {
            promises.push(this.sendTelegramAlert(alert))
          }
          break

        case "discord":
          if (this.channels.DISCORD.enabled) {
            promises.push(this.sendDiscordAlert(alert))
          }
          break

        case "slack":
          if (this.channels.SLACK.enabled) {
            promises.push(this.sendSlackAlert(alert))
          }
          break
      }
    }

    // Esperar a que se envíen todas las alertas
    const results = await Promise.allSettled(promises)

    // MOSTRAR RESULTADOS DE CADA CANAL
    results.forEach((result, index) => {
      if (result.status === "rejected") {
        this.logger.error(`Error enviando alerta por ${alert.channels[index]}:`, result.reason.message)
      }
    })
  }

  /**
   * Envía alerta por email
   */
  async sendEmailAlert(alert) {
    if (!this.emailTransporter) {
      throw new Error("Transportador de email no inicializado")
    }

    const subject = this.formatEmailSubject(alert)
    const html = this.formatEmailBody(alert)

    const mailOptions = {
      from: this.channels.EMAIL.from,
      to: this.channels.EMAIL.to,
      subject,
      html,
    }

    await this.emailTransporter.sendMail(mailOptions)
    this.logger.info(`✅ Alerta enviada por email: ${alert.type}`)
  }

  /**
   * Envía alerta por Telegram
   */
  async sendTelegramAlert(alert) {
    try {
      const { botToken, chatId, parseMode } = this.channels.TELEGRAM

      // VERIFICAR CONFIGURACIÓN ANTES DE ENVIAR
      if (!botToken || botToken === "") {
        throw new Error("TELEGRAM_BOT_TOKEN no configurado")
      }

      if (!chatId || chatId === "") {
        throw new Error("TELEGRAM_CHAT_ID no configurado")
      }

      const message = this.formatTelegramMessage(alert)
      const url = `https://api.telegram.org/bot${botToken}/sendMessage`

      this.logger.info("📱 Enviando mensaje a Telegram...")

      const response = await axios.post(url, {
        chat_id: chatId,
        text: message,
        parse_mode: parseMode || "HTML",
      })

      if (response.data.ok) {
        this.logger.info(`✅ Alerta enviada por Telegram: ${alert.type}`)
      } else {
        throw new Error(`Error de Telegram: ${response.data.description}`)
      }
    } catch (error) {
      this.logger.error("❌ Error enviando alerta por Telegram:", error.message)

      if (error.response) {
        this.logger.error("Respuesta de Telegram:", error.response.data)
      }

      throw error
    }
  }

  /**
   * Envía alerta por Discord
   */
  async sendDiscordAlert(alert) {
    const { webhookUrl } = this.channels.DISCORD
    const embed = this.formatDiscordEmbed(alert)

    await axios.post(webhookUrl, {
      embeds: [embed],
    })

    this.logger.info(`✅ Alerta enviada por Discord: ${alert.type}`)
  }

  /**
   * Envía alerta por Slack
   */
  async sendSlackAlert(alert) {
    const { webhookUrl } = this.channels.SLACK
    const payload = this.formatSlackMessage(alert)

    await axios.post(webhookUrl, payload)

    this.logger.info(`✅ Alerta enviada por Slack: ${alert.type}`)
  }

  /**
   * Formatea el asunto del email
   */
  formatEmailSubject(alert) {
    const priorityEmoji = {
      low: "🔵",
      medium: "🟡",
      high: "🟠",
      critical: "🔴",
    }

    const emoji = priorityEmoji[alert.priority] || "🔵"
    return `${emoji} Bot de Arbitraje - ${alert.type.toUpperCase()}`
  }

  /**
   * Formatea el cuerpo del email
   */
  formatEmailBody(alert) {
    return `
      <html>
      <body style="font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5;">
        <div style="max-width: 600px; margin: 0 auto; background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h2 style="color: #333; margin-top: 0;">Bot de Arbitraje CEX</h2>
          
          <div style="background-color: ${this.getPriorityColor(alert.priority)}; color: white; padding: 10px; border-radius: 4px; margin: 20px 0;">
            <strong>Tipo:</strong> ${alert.type.toUpperCase()}
          </div>
          
          <div style="margin: 20px 0;">
            <strong>Mensaje:</strong><br>
            ${alert.message}
          </div>
          
          <div style="margin: 20px 0;">
            <strong>Timestamp:</strong> ${alert.timestamp.toLocaleString()}
          </div>
          
          ${
            alert.data && Object.keys(alert.data).length > 0
              ? `
          <div style="margin: 20px 0;">
            <strong>Datos adicionales:</strong><br>
            <pre style="background-color: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto;">${JSON.stringify(alert.data, null, 2)}</pre>
          </div>
          `
              : ""
          }
          
          <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
          
          <p style="color: #666; font-size: 12px; margin: 0;">
            Esta es una notificación automática del Bot de Arbitraje CEX.
          </p>
        </div>
      </body>
      </html>
    `
  }

  /**
   * Formatea el mensaje de Telegram
   */
  formatTelegramMessage(alert) {
    const priorityEmoji = {
      low: "🔵",
      medium: "🟡",
      high: "🟠",
      critical: "🔴",
    }

    const emoji = priorityEmoji[alert.priority] || "🔵"

    let message = `${emoji} <b>Bot de Arbitraje CEX</b>\n\n`
    message += `<b>Tipo:</b> ${alert.type.toUpperCase()}\n`
    message += `<b>Mensaje:</b> ${alert.message}\n`
    message += `<b>Timestamp:</b> ${alert.timestamp.toLocaleString()}\n`

    if (alert.data && Object.keys(alert.data).length > 0) {
      message += `\n<b>Datos:</b>\n`
      for (const [key, value] of Object.entries(alert.data)) {
        message += `• ${key}: ${value}\n`
      }
    }

    return message
  }

  /**
   * Formatea el embed de Discord
   */
  formatDiscordEmbed(alert) {
    const color = this.getPriorityColorHex(alert.priority)

    const embed = {
      title: `Bot de Arbitraje CEX - ${alert.type.toUpperCase()}`,
      description: alert.message,
      color: Number.parseInt(color.replace("#", ""), 16),
      timestamp: alert.timestamp.toISOString(),
      fields: [],
    }

    if (alert.data && Object.keys(alert.data).length > 0) {
      for (const [key, value] of Object.entries(alert.data)) {
        embed.fields.push({
          name: key,
          value: String(value),
          inline: true,
        })
      }
    }

    return embed
  }

  /**
   * Formatea el mensaje de Slack
   */
  formatSlackMessage(alert) {
    const color = this.getPriorityColor(alert.priority)

    const attachment = {
      color,
      title: `Bot de Arbitraje CEX - ${alert.type.toUpperCase()}`,
      text: alert.message,
      timestamp: Math.floor(alert.timestamp.getTime() / 1000),
      fields: [],
    }

    if (alert.data && Object.keys(alert.data).length > 0) {
      for (const [key, value] of Object.entries(alert.data)) {
        attachment.fields.push({
          title: key,
          value: String(value),
          short: true,
        })
      }
    }

    return {
      attachments: [attachment],
    }
  }

  /**
   * Obtiene el color según la prioridad
   */
  getPriorityColor(priority) {
    const colors = {
      low: "#007bff",
      medium: "#ffc107",
      high: "#fd7e14",
      critical: "#dc3545",
    }

    return colors[priority] || colors.medium
  }

  /**
   * Obtiene el color hexadecimal según la prioridad
   */
  getPriorityColorHex(priority) {
    const colors = {
      low: "#007bff",
      medium: "#ffc107",
      high: "#fd7e14",
      critical: "#dc3545",
    }

    return colors[priority] || colors.medium
  }

  /**
   * Envía el resumen diario
   */
  async sendDailySummary() {
    try {
      // Obtener alertas del día
      const today = new Date()
      today.setHours(0, 0, 0, 0)

      const todayAlerts = this.alertHistory.filter((alert) => new Date(alert.timestamp) >= today)

      // Agrupar por tipo
      const alertsByType = {}
      for (const alert of todayAlerts) {
        if (!alertsByType[alert.type]) {
          alertsByType[alert.type] = 0
        }
        alertsByType[alert.type]++
      }

      // Crear mensaje de resumen
      let summary = `📊 Resumen diario del Bot de Arbitraje CEX\n\n`
      summary += `Total de alertas: ${todayAlerts.length}\n\n`

      if (Object.keys(alertsByType).length > 0) {
        summary += `Alertas por tipo:\n`
        for (const [type, count] of Object.entries(alertsByType)) {
          summary += `• ${type}: ${count}\n`
        }
      } else {
        summary += `No se generaron alertas hoy.`
      }

      // Enviar resumen
      await this.sendAlert("DAILY_SUMMARY", summary)
    } catch (error) {
      this.logger.error("Error enviando resumen diario:", error)
    }
  }

  /**
   * Genera un ID único para la alerta
   */
  generateAlertId() {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * Obtiene el historial de alertas
   */
  getAlertHistory(limit = 100) {
    return this.alertHistory.slice(-limit)
  }

  /**
   * Obtiene estadísticas de alertas
   */
  getAlertStatistics() {
    const stats = {
      total: this.alertHistory.length,
      byType: {},
      byPriority: {},
      last24Hours: 0,
    }

    const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000)

    for (const alert of this.alertHistory) {
      // Por tipo
      if (!stats.byType[alert.type]) {
        stats.byType[alert.type] = 0
      }
      stats.byType[alert.type]++

      // Por prioridad
      if (!stats.byPriority[alert.priority]) {
        stats.byPriority[alert.priority] = 0
      }
      stats.byPriority[alert.priority]++

      // Últimas 24 horas
      if (new Date(alert.timestamp) >= last24Hours) {
        stats.last24Hours++
      }
    }

    return stats
  }

  // ======= AGREGADO DASHBOARD: método para anomalias recientes =======
  getRecentAnomalies(limit = 25) {
    return this.anomalies.slice(-limit)
  }
  // ======= FIN AGREGADO DASHBOARD =======
}

module.exports = AlertManager
----------------------------------------------------------------------------------------------------------

const nodemailer = require('nodemailer');

/**
 * Gestor de Email para el Bot de Arbitraje
 */
class EmailManager {
  constructor(config) {
    this.config = config;
    this.emailConfig = config.ALERTS.CHANNELS.EMAIL;
    this.transporter = null;
    this.logger = console;
  }

  /**
   * Inicializa el gestor de email
   */
  async initialize() {
    if (!this.emailConfig.enabled) {
      this.logger.info('Email deshabilitado en la configuración');
      return;
    }

    try {
      this.logger.info('Inicializando EmailManager...');
      
      // Crear transporter
      this.transporter = nodemailer.createTransporter({
        host: this.emailConfig.smtp.host,
        port: this.emailConfig.smtp.port,
        secure: this.emailConfig.smtp.secure,
        auth: {
          user: this.emailConfig.smtp.auth.user,
          pass: this.emailConfig.smtp.auth.pass,
        },
      });

      // Verificar conexión
      await this.transporter.verify();
      this.logger.info('✅ Conexión de email verificada correctamente');
      
      // Enviar email de prueba
      await this.sendTestEmail();
      
    } catch (error) {
      this.logger.error('❌ Error inicializando EmailManager:', error.message);
      throw error;
    }
  }

  /**
   * Envía un email de prueba
   */
  async sendTestEmail() {
    try {
      const testMessage = {
        from: this.emailConfig.from,
        to: this.emailConfig.to,
        subject: '🤖 Bot de Arbitraje - Test de Conexión',
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #2563eb;">🤖 Bot de Arbitraje CEX</h2>
            <p>Este es un mensaje de prueba para verificar que las notificaciones por email funcionan correctamente.</p>
            <div style="background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <p><strong>Fecha:</strong> ${new Date().toLocaleString()}</p>
              <p><strong>Estado:</strong> ✅ Conexión exitosa</p>
            </div>
            <p style="color: #6b7280; font-size: 12px;">
              Este mensaje fue enviado automáticamente por el sistema de alertas.
            </p>
          </div>
        `
      };

      await this.transporter.sendMail(testMessage);
      this.logger.info('✅ Email de prueba enviado correctamente');
      
    } catch (error) {
      this.logger.error('❌ Error enviando email de prueba:', error.message);
      throw error;
    }
  }

  /**
   * Envía un email de alerta
   * @param {string} type - Tipo de alerta
   * @param {string} message - Mensaje de la alerta
   * @param {Object} data - Datos adicionales
   */
  async sendAlert(type, message, data = {}) {
    if (!this.emailConfig.enabled || !this.transporter) {
      return;
    }

    try {
      const emailContent = this.formatEmailContent(type, message, data);
      
      const mailOptions = {
        from: this.emailConfig.from,
        to: this.emailConfig.to,
        subject: emailContent.subject,
        html: emailContent.html
      };

      await this.transporter.sendMail(mailOptions);
      this.logger.info(`📧 Email enviado: ${type} - ${message}`);
      
    } catch (error) {
      this.logger.error('❌ Error enviando email:', error.message);
    }
  }

  /**
   * Formatea el contenido del email según el tipo
   * @param {string} type - Tipo de alerta
   * @param {string} message - Mensaje
   * @param {Object} data - Datos adicionales
   * @returns {Object} - Contenido formateado
   */
  formatEmailContent(type, message, data) {
    const timestamp = new Date().toLocaleString();
    let emoji = '📢';
    let color = '#6b7280';
    let priority = 'Normal';

    switch (type) {
      case 'info':
        emoji = 'ℹ️';
        color = '#2563eb';
        priority = 'Información';
        break;
      case 'warning':
        emoji = '⚠️';
        color = '#f59e0b';
        priority = 'Advertencia';
        break;
      case 'error':
        emoji = '❌';
        color = '#dc2626';
        priority = 'Error';
        break;
      case 'trade':
        emoji = '💰';
        color = '#059669';
        priority = 'Operación';
        break;
      case 'risk':
        emoji = '🚨';
        color = '#dc2626';
        priority = 'Riesgo Alto';
        break;
      case 'profit':
        emoji = '💵';
        color = '#059669';
        priority = 'Ganancia';
        break;
      case 'balance':
        emoji = '💳';
        color = '#7c3aed';
        priority = 'Balance';
        break;
    }

    const subject = `${emoji} Bot Arbitraje - ${priority}: ${message.substring(0, 50)}...`;

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #ffffff;">
        <div style="background-color: ${color}; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0; font-size: 24px;">${emoji} Bot de Arbitraje CEX</h1>
          <p style="margin: 5px 0 0 0; opacity: 0.9;">Alerta de ${priority}</p>
        </div>
        
        <div style="padding: 30px;">
          <div style="background-color: #f9fafb; border-left: 4px solid ${color}; padding: 15px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; color: ${color};">Mensaje:</h3>
            <p style="margin: 0; font-size: 16px; line-height: 1.5;">${message}</p>
          </div>

          ${data.details ? `
            <div style="background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin: 0 0 10px 0; color: #374151;">Detalles:</h4>
              <pre style="margin: 0; font-family: monospace; font-size: 12px; white-space: pre-wrap;">${JSON.stringify(data.details, null, 2)}</pre>
            </div>
          ` : ''}

          ${data.balances ? `
            <div style="background-color: #ecfdf5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin: 0 0 10px 0; color: #065f46;">💳 Balances Actuales:</h4>
              ${Object.entries(data.balances).map(([exchange, balance]) => 
                `<p style="margin: 5px 0;"><strong>${exchange}:</strong> $${balance.toFixed(2)}</p>`
              ).join('')}
            </div>
          ` : ''}

          ${data.profit ? `
            <div style="background-color: #ecfdf5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin: 0 0 10px 0; color: #065f46;">💰 Información de Ganancia:</h4>
              <p style="margin: 5px 0;"><strong>Ganancia:</strong> $${data.profit.toFixed(2)}</p>
              <p style="margin: 5px 0;"><strong>Porcentaje:</strong> ${data.profitPercentage?.toFixed(2)}%</p>
            </div>
          ` : ''}

          <div style="border-top: 1px solid #e5e7eb; padding-top: 15px; margin-top: 20px;">
            <p style="margin: 0; color: #6b7280; font-size: 12px;">
              <strong>Fecha:</strong> ${timestamp}<br>
              <strong>Tipo:</strong> ${priority}<br>
              <strong>Sistema:</strong> Bot de Arbitraje CEX con IA
            </p>
          </div>
        </div>

        <div style="background-color: #f9fafb; padding: 15px; text-align: center; border-top: 1px solid #e5e7eb;">
          <p style="margin: 0; color: #6b7280; font-size: 11px;">
            Este mensaje fue enviado automáticamente por el sistema de alertas del Bot de Arbitraje.
          </p>
        </div>
      </div>
    `;

    return { subject, html };
  }

  /**
   * Envía resumen diario por email
   * @param {Object} stats - Estadísticas del día
   */
  async sendDailySummary(stats) {
    const data = {
      details: stats,
      balances: stats.balances,
      profit: stats.totalProfit
    };

    const message = `Resumen diario del bot de arbitraje:
    
💰 Ganancia Total: $${stats.totalProfit.toFixed(2)}
📈 Operaciones Exitosas: ${stats.successfulTrades}
📉 Operaciones Fallidas: ${stats.failedTrades}
🎯 Tasa de Éxito: ${((stats.successfulTrades / (stats.totalTrades || 1)) * 100).toFixed(1)}%
⚡ Latencia Promedio: ${stats.averageLatency}`;

    await this.sendAlert('info', message, data);
  }
}

module.exports = EmailManager;
---------------------------------------------------------------------------------------------------------------

BACKTESTING

// ========== MOTOR DE BACKTESTING HISTÓRICO ==========
const fs = require('fs').promises
const path = require('path')
const config = require("../strategies/config") // ✅ CORRECTO

class BacktestEngine {
  constructor(strategyManager) {
    this.strategyManager = strategyManager
    this.historicalData = new Map()
    this.backtestResults = []
    this.isRunning = false
  }

  async loadHistoricalData(pair, startDate, endDate) {
    try {
      const dataPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, `${pair.replace('/', '_')}.json`)
      
      // Intentar cargar datos existentes
      try {
        const data = await fs.readFile(dataPath, 'utf8')
        const historicalData = JSON.parse(data)
        
        // Filtrar por rango de fechas
        const filteredData = historicalData.filter(point => {
          const timestamp = new Date(point.timestamp).getTime()
          return timestamp >= startDate.getTime() && timestamp <= endDate.getTime()
        })
        
        this.historicalData.set(pair, filteredData)
        console.log(`📊 Cargados ${filteredData.length} puntos de datos históricos para ${pair}`)
        
        return filteredData
      } catch (fileError) {
        // Si no hay datos históricos, generar datos simulados
        console.log(`⚠️ No se encontraron datos históricos para ${pair}, generando datos simulados...`)
        const simulatedData = this.generateSimulatedData(pair, startDate, endDate)
        this.historicalData.set(pair, simulatedData)
        
        // Guardar datos simulados para uso futuro
        await this.saveHistoricalData(pair, simulatedData)
        
        return simulatedData
      }
    } catch (error) {
      console.error(`❌ Error cargando datos históricos para ${pair}:`, error)
      throw error
    }
  }

  generateSimulatedData(pair, startDate, endDate) {
    const data = []
    const basePrice = this.getBasePriceForPair(pair)
    let currentPrice = basePrice
    
    const totalMinutes = (endDate.getTime() - startDate.getTime()) / (1000 * 60)
    const interval = 5 // 5 minutos entre puntos de datos
    
    for (let i = 0; i < totalMinutes; i += interval) {
      const timestamp = new Date(startDate.getTime() + i * 60 * 1000)
      
      // Simular movimiento de precio con volatilidad
      const volatility = 0.02 // 2% volatilidad
      const randomChange = (Math.random() - 0.5) * volatility
      currentPrice *= (1 + randomChange)
      
      // Simular datos de ambos exchanges con spread
      const spread = (Math.random() * 0.01) + 0.001 // 0.1% - 1.1% spread
      const binancePrice = currentPrice * (1 - spread / 2)
      const kucoinPrice = currentPrice * (1 + spread / 2)
      
      data.push({
        timestamp: timestamp.toISOString(),
        pair,
        binance: {
          price: binancePrice,
          volume: Math.random() * 1000000,
        },
        kucoin: {
          price: kucoinPrice,
          volume: Math.random() * 800000,
        },
        spread: ((kucoinPrice - binancePrice) / binancePrice) * 100,
        volatility: this.calculateVolatility(data.slice(-20).map(d => d.binance.price)),
      })
    }
    
    return data
  }

  getBasePriceForPair(pair) {
    const basePrices = {
      'POL/USDT': 0.45,
      'USDC/USDT': 1.0,
      'BTC/USDT': 45000,
      'ETH/USDT': 3000,
    }
    return basePrices[pair] || 1.0
  }

  calculateVolatility(prices) {
    if (prices.length < 2) return 0
    
    const returns = []
    for (let i = 1; i < prices.length; i++) {
      returns.push((prices[i] - prices[i-1]) / prices[i-1])
    }
    
    const avgReturn = returns.reduce((a, b) => a + b) / returns.length
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
    
    return Math.sqrt(variance)
  }

  async runBacktest(options = {}) {
    const {
      pairs = config.TRADING_PAIRS.map(p => p.symbol),
      startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 días atrás
      endDate = new Date(),
      initialBalance = config.BACKTESTING.INITIAL_BALANCE_SIM,
      strategy = 'BALANCED',
      maxTrades = 100,
    } = options

    if (this.isRunning) {
      throw new Error('Ya hay un backtest en ejecución')
    }

    this.isRunning = true
    console.log(`🔄 Iniciando backtest: ${startDate.toDateString()} - ${endDate.toDateString()}`)

    try {
      const results = {
        id: Date.now(),
        startDate,
        endDate,
        strategy,
        initialBalance,
        pairs,
        trades: [],
        performance: {},
        summary: {},
        timestamp: new Date(),
      }

      // Cargar datos históricos para todos los pares
      for (const pair of pairs) {
        await this.loadHistoricalData(pair, startDate, endDate)
      }

      // Simular trading
      const simulation = await this.simulateTrading(results, maxTrades)
      results.trades = simulation.trades
      results.performance = simulation.performance
      results.summary = this.calculateSummary(simulation)

      this.backtestResults.push(results)
      
      console.log(`✅ Backtest completado: ${results.trades.length} trades simulados`)
      console.log(`📊 Rendimiento: ${results.summary.totalReturn.toFixed(2)}%`)

      // Guardar resultados
      await this.saveBacktestResults(results)

      return results
    } catch (error) {
      console.error('❌ Error en backtest:', error)
      throw error
    } finally {
      this.isRunning = false
    }
  }

  async simulateTrading(backtestConfig, maxTrades) {
    const trades = []
    let currentBalance = backtestConfig.initialBalance
    let totalFees = 0
    const balanceHistory = []

    // Obtener todos los puntos de datos ordenados por tiempo
    const allDataPoints = []
    for (const pair of backtestConfig.pairs) {
      const pairData = this.historicalData.get(pair) || []
      pairData.forEach(point => {
        allDataPoints.push({ ...point, pair })
      })
    }

    allDataPoints.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))

    console.log(`📈 Simulando trading con ${allDataPoints.length} puntos de datos...`)

    for (let i = 0; i < allDataPoints.length && trades.length < maxTrades; i++) {
      const dataPoint = allDataPoints[i]
      
      // Simular detección de oportunidad
      const opportunity = this.simulateOpportunityDetection(dataPoint)
      
      if (opportunity && opportunity.profitable) {
        // Evaluar con la estrategia seleccionada
        const evaluatedOpp = this.strategyManager.strategies.get(backtestConfig.strategy)?.evaluate(opportunity)
        
        if (evaluatedOpp && currentBalance >= evaluatedOpp.tradeAmount) {
          // Simular ejecución del trade
          const tradeResult = this.simulateTradeExecution(evaluatedOpp, dataPoint)
          
          if (tradeResult.success) {
            const fees = evaluatedOpp.tradeAmount * (config.BACKTESTING.FEE_PERCENTAGE_SIM / 100)
            const netProfit = tradeResult.profit - fees
            
            currentBalance += netProfit
            totalFees += fees
            
            trades.push({
              timestamp: dataPoint.timestamp,
              pair: dataPoint.pair,
              type: 'ARBITRAGE',
              amount: evaluatedOpp.tradeAmount,
              profit: netProfit,
              fees,
              balance: currentBalance,
              strategy: backtestConfig.strategy,
              confidence: evaluatedOpp.confidence,
            })
          }
        }
      }

      // Registrar balance cada 100 puntos
      if (i % 100 === 0) {
        balanceHistory.push({
          timestamp: dataPoint.timestamp,
          balance: currentBalance,
        })
      }
    }

    return {
      trades,
      performance: {
        initialBalance: backtestConfig.initialBalance,
        finalBalance: currentBalance,
        totalFees,
        balanceHistory,
      }
    }
  }

  simulateOpportunityDetection(dataPoint) {
    const binancePrice = dataPoint.binance.price
    const kucoinPrice = dataPoint.kucoin.price
    
    if (!binancePrice || !kucoinPrice) return null

    // Calcular oportunidad de arbitraje
    const spread = Math.abs(kucoinPrice - binancePrice)
    const spreadPercent = (spread / Math.min(binancePrice, kucoinPrice)) * 100
    
    // Determinar dirección del arbitraje
    const buyExchange = binancePrice < kucoinPrice ? 'BINANCE' : 'KUCOIN'
    const sellExchange = binancePrice < kucoinPrice ? 'KUCOIN' : 'BINANCE'
    const buyPrice = Math.min(binancePrice, kucoinPrice)
    const sellPrice = Math.max(binancePrice, kucoinPrice)
    
    // Simular fees y costos
    const tradingFees = 0.2 // 0.2% total en fees
    const netProfit = spreadPercent - tradingFees
    
    return {
      pair: dataPoint.pair,
      buyExchange,
      sellExchange,
      buyPrice,
      sellPrice,
      spread: spreadPercent,
      finalProfit: netProfit,
      profitable: netProfit > 0.1, // Mínimo 0.1% profit
      confidence: Math.min(0.9, Math.max(0.1, netProfit / 2)), // Confianza basada en profit
      tradeAmount: 50, // Monto fijo para simulación
      timestamp: new Date(dataPoint.timestamp).getTime(),
    }
  }

  simulateTradeExecution(opportunity, dataPoint) {
    // Simular éxito/fallo basado en condiciones de mercado
    const volatility = dataPoint.volatility || 0
    const volume = Math.min(dataPoint.binance.volume, dataPoint.kucoin.volume)
    
    // Factores que afectan el éxito
    let successProbability = 0.8 // Base 80%
    
    // Reducir probabilidad con alta volatilidad
    if (volatility > 0.05) successProbability -= 0.2
    
    // Reducir probabilidad con bajo volumen
    if (volume < 100000) successProbability -= 0.1
    
    // Aumentar probabilidad con alto profit
    if (opportunity.finalProfit > 1.0) successProbability += 0.1
    
    const success = Math.random() < successProbability
    
    if (success) {
      // Simular slippage
      const slippage = Math.random() * 0.1 // Hasta 0.1% slippage
      const actualProfit = (opportunity.finalProfit - slippage) * opportunity.tradeAmount / 100
      
      return {
        success: true,
        profit: Math.max(0, actualProfit),
        executionTime: Math.random() * 30000 + 5000, // 5-35 segundos
      }
    } else {
      return {
        success: false,
        profit: 0,
        reason: 'Fallo en ejecución simulada',
      }
    }
  }

  calculateSummary(simulation) {
    const { trades, performance } = simulation
    const { initialBalance, finalBalance, totalFees } = performance
    
    const successfulTrades = trades.filter(t => t.profit > 0)
    const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0)
    const totalReturn = ((finalBalance - initialBalance) / initialBalance) * 100
    
    const profitableTrades = trades.filter(t => t.profit > 0)
    const losingTrades = trades.filter(t => t.profit <= 0)
    
    const avgProfit = profitableTrades.length > 0 
      ? profitableTrades.reduce((sum, t) => sum + t.profit, 0) / profitableTrades.length 
      : 0
    
    const avgLoss = losingTrades.length > 0 
      ? Math.abs(losingTrades.reduce((sum, t) => sum + t.profit, 0)) / losingTrades.length 
      : 0

    const maxDrawdown = this.calculateMaxDrawdown(performance.balanceHistory)
    const sharpeRatio = this.calculateSharpeRatio(trades)
    
    return {
      totalTrades: trades.length,
      successfulTrades: successfulTrades.length,
      successRate: trades.length > 0 ? (successfulTrades.length / trades.length) * 100 : 0,
      totalProfit,
      totalReturn,
      totalFees,
      avgProfit,
      avgLoss,
      profitFactor: avgLoss > 0 ? avgProfit / avgLoss : 0,
      maxDrawdown,
      sharpeRatio,
      finalBalance,
      roi: totalReturn,
    }
  }

  calculateMaxDrawdown(balanceHistory) {
    if (balanceHistory.length < 2) return 0
    
    let maxDrawdown = 0
    let peak = balanceHistory[0].balance
    
    for (const point of balanceHistory) {
      if (point.balance > peak) {
        peak = point.balance
      } else {
        const drawdown = ((peak - point.balance) / peak) * 100
        maxDrawdown = Math.max(maxDrawdown, drawdown)
      }
    }
    
    return maxDrawdown
  }

  calculateSharpeRatio(trades) {
    if (trades.length < 2) return 0
    
    const returns = trades.map(t => (t.profit / t.amount) * 100)
    const avgReturn = returns.reduce((a, b) => a + b) / returns.length
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
    const stdDev = Math.sqrt(variance)
    
    return stdDev > 0 ? avgReturn / stdDev : 0
  }

  async saveHistoricalData(pair, data) {
    try {
      const dataPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, `${pair.replace('/', '_')}.json`)
      
      // Crear directorio si no existe
      await fs.mkdir(path.dirname(dataPath), { recursive: true })
      
      await fs.writeFile(dataPath, JSON.stringify(data, null, 2))
      console.log(`💾 Datos históricos guardados para ${pair}`)
    } catch (error) {
      console.error(`❌ Error guardando datos históricos para ${pair}:`, error)
    }
  }

  async saveBacktestResults(results) {
    try {
      const resultsPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, 'backtest_results.json')
      
      // Cargar resultados existentes
      let existingResults = []
      try {
        const data = await fs.readFile(resultsPath, 'utf8')
        existingResults = JSON.parse(data)
      } catch (error) {
        // Archivo no existe, usar array vacío
      }
      
      existingResults.push(results)
      
      // Mantener solo los últimos 50 resultados
      if (existingResults.length > 50) {
        existingResults = existingResults.slice(-50)
      }
      
      await fs.writeFile(resultsPath, JSON.stringify(existingResults, null, 2))
      console.log('💾 Resultados de backtest guardados')
    } catch (error) {
      console.error('❌ Error guardando resultados de backtest:', error)
    }
  }

  async getBacktestHistory() {
    try {
      const resultsPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, 'backtest_results.json')
      const data = await fs.readFile(resultsPath, 'utf8')
      return JSON.parse(data)
    } catch (error) {
      return []
    }
  }

  compareStrategies(backtestResults) {
    const strategyPerformance = new Map()
    
    for (const result of backtestResults) {
      const strategy = result.strategy
      if (!strategyPerformance.has(strategy)) {
        strategyPerformance.set(strategy, {
          backtests: 0,
          avgReturn: 0,
          avgSharpe: 0,
          avgSuccessRate: 0,
          totalReturn: 0,
        })
      }
      
      const perf = strategyPerformance.get(strategy)
      perf.backtests++
      perf.totalReturn += result.summary.totalReturn
      perf.avgReturn = perf.totalReturn / perf.backtests
      perf.avgSharpe = (perf.avgSharpe * (perf.backtests - 1) + result.summary.sharpeRatio) / perf.backtests
      perf.avgSuccessRate = (perf.avgSuccessRate * (perf.backtests - 1) + result.summary.successRate) / perf.backtests
    }
    
    return Object.fromEntries(strategyPerformance)
  }
}

module.exports = { BacktestEngine }
---------------------------------------------------------------------------------------------------------
const fs = require('fs').promises;
const path = require('path');
const EventEmitter = require('events');

/**
 * Motor de Backtesting
 * Permite probar estrategias con datos históricos
 */
class BacktestEngine extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.enabled = config.BACKTESTING.ENABLED;
        this.dataSource = config.BACKTESTING.DATA_SOURCE;
        this.defaultPeriod = config.BACKTESTING.DEFAULT_PERIOD;
        this.commissionRate = config.BACKTESTING.COMMISSION_RATE;
        this.slippageRate = config.BACKTESTING.SLIPPAGE_RATE;
        this.initialCapital = config.BACKTESTING.INITIAL_CAPITAL;
        this.benchmark = config.BACKTESTING.BENCHMARK;
        this.metrics = config.BACKTESTING.METRICS;
        this.monteCarloSimulations = config.BACKTESTING.MONTE_CARLO_SIMULATIONS;
        this.confidenceIntervals = config.BACKTESTING.CONFIDENCE_INTERVALS;
        
        this.historicalData = {};
        this.backtestResults = {};
        this.currentBacktest = null;
        
        this.logger = console;
    }
    
    /**
     * Inicializa el motor de backtesting
     */
    async initialize() {
        if (!this.enabled) {
            this.logger.info('Backtesting deshabilitado');
            return;
        }
        
        this.logger.info('Inicializando motor de backtesting...');
        
        try {
            // Crear directorio de datos si no existe
            await this.ensureDataDirectory();
            
            // Cargar datos históricos iniciales
            await this.loadInitialData();
            
            this.logger.info('Motor de backtesting inicializado correctamente');
        } catch (error) {
            this.logger.error('Error inicializando motor de backtesting:', error);
            throw error;
        }
    }
    
    /**
     * Asegura que el directorio de datos exista
     */
    async ensureDataDirectory() {
        const dataDir = path.join(__dirname, 'data');
        try {
            await fs.mkdir(dataDir, { recursive: true });
        } catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
    }
    
    /**
     * Carga datos históricos iniciales
     */
    async loadInitialData() {
        try {
            // En una implementación real, aquí cargaríamos datos históricos de una API o archivos
            // Para esta implementación, generaremos datos simulados
            
            const pairs = this.config.TRADING_PAIRS;
            const exchanges = Object.keys(this.config.EXCHANGES)
                .filter(key => this.config.EXCHANGES[key].enabled)
                .map(key => this.config.EXCHANGES[key].name);
            
            for (const pair of pairs) {
                this.historicalData[pair] = {};
                
                for (const exchange of exchanges) {
                    this.historicalData[pair][exchange] = await this.generateHistoricalData(pair, exchange);
                }
            }
            
            this.logger.info(`Datos históricos cargados para ${pairs.length} pares en ${exchanges.length} exchanges`);
        } catch (error) {
            this.logger.error('Error cargando datos históricos:', error);
            throw error;
        }
    }
    
    /**
     * Genera datos históricos simulados
     * @param {string} pair - Par de trading
     * @param {string} exchange - Exchange
     * @returns {Array} - Datos históricos simulados
     */
    async generateHistoricalData(pair, exchange) {
        const days = this.defaultPeriod;
        const dataPoints = days * 24 * 6; // 6 puntos por hora
        const endDate = new Date();
        const data = [];
        
        // Generar precio base según el par
        let basePrice;
        if (pair.includes('BTC')) {
            basePrice = 30000 + Math.random() * 10000;
        } else if (pair.includes('ETH')) {
            basePrice = 2000 + Math.random() * 500;
        } else if (pair.includes('XRP')) {
            basePrice = 0.5 + Math.random() * 0.2;
        } else {
            basePrice = 10 + Math.random() * 90;
        }
        
        // Añadir variación por exchange
        if (exchange === 'Binance') {
            basePrice *= 1.0;
        } else if (exchange === 'Coinbase') {
            basePrice *= 1.005;
        } else if (exchange === 'Kraken') {
            basePrice *= 0.995;
        } else {
            basePrice *= 1.002;
        }
        
        // Generar serie temporal
        let currentPrice = basePrice;
        for (let i = 0; i < dataPoints; i++) {
            const timestamp = new Date(endDate.getTime() - (dataPoints - i) * 10 * 60 * 1000); // 10 minutos
            
            // Simular movimiento de precio
            const change = (Math.random() - 0.5) * 0.01; // ±0.5%
            currentPrice = currentPrice * (1 + change);
            
            // Añadir algo de volatilidad según el par
            if (pair.includes('BTC')) {
                currentPrice += (Math.random() - 0.5) * 50;
            } else if (pair.includes('ETH')) {
                currentPrice += (Math.random() - 0.5) * 10;
            } else {
                currentPrice += (Math.random() - 0.5) * 0.05;
            }
            
            // Asegurar que el precio no sea negativo
            currentPrice = Math.max(currentPrice, 0.001);
            
            // Generar volumen simulado
            let volume;
            if (pair.includes('BTC')) {
                volume = Math.random() * 10 + 1;
            } else if (pair.includes('ETH')) {
                volume = Math.random() * 50 + 5;
            } else {
                volume = Math.random() * 100000 + 10000;
            }
            
            // Añadir datos
            data.push({
                timestamp: timestamp.toISOString(),
                open: currentPrice * (1 - 0.001),
                high: currentPrice * (1 + 0.002),
                low: currentPrice * (1 - 0.002),
                close: currentPrice,
                volume: volume,
                exchange
            });
        }
        
        return data;
    }
    
    /**
     * Ejecuta un backtest con una estrategia específica
     * @param {Object} options - Opciones del backtest
     * @returns {Object} - Resultados del backtest
     */
    async runBacktest(options) {
        if (!this.enabled) {
            throw new Error('Backtesting está deshabilitado');
        }
        
        const {
            strategy = 'basic',
            pairs = this.config.TRADING_PAIRS,
            exchanges = Object.keys(this.config.EXCHANGES)
                .filter(key => this.config.EXCHANGES[key].enabled)
                .map(key => this.config.EXCHANGES[key].name),
            startDate = new Date(Date.now() - this.defaultPeriod * 24 * 60 * 60 * 1000),
            endDate = new Date(),
            initialCapital = this.initialCapital,
            parameters = {}
        } = options;
        
        this.logger.info(`Iniciando backtest para estrategia ${strategy}...`);
        
        try {
            // Crear ID único para este backtest
            const backtestId = `backtest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Inicializar estado del backtest
            this.currentBacktest = {
                id: backtestId,
                strategy,
                pairs,
                exchanges,
                startDate,
                endDate,
                initialCapital,
                parameters,
                status: 'running',
                progress: 0,
                trades: [],
                balance: initialCapital,
                equity: initialCapital,
                startTime: new Date()
            };
            
            // Emitir evento de inicio
            this.emit('backtestStarted', { id: backtestId });
            
            // Filtrar datos históricos según fechas y pares/exchanges
            const filteredData = await this.filterHistoricalData(pairs, exchanges, startDate, endDate);
            
            // Ejecutar simulación
            const result = await this.simulateStrategy(strategy, filteredData, initialCapital, parameters);
            
            // Calcular métricas
            const metrics = this.calculateMetrics(result);
            
            // Ejecutar simulaciones de Monte Carlo
            const monteCarloResults = await this.runMonteCarloSimulations(result);
            
            // Guardar resultados
            this.backtestResults[backtestId] = {
                ...this.currentBacktest,
                status: 'completed',
                progress: 100,
                result,
                metrics,
                monteCarloResults,
                endTime: new Date(),
                executionTime: new Date() - this.currentBacktest.startTime
            };
            
            // Emitir evento de finalización
            this.emit('backtestCompleted', { 
                id: backtestId,
                metrics,
                executionTime: this.backtestResults[backtestId].executionTime
            });
            
            this.currentBacktest = null;
            
            return this.backtestResults[backtestId];
        } catch (error) {
            this.logger.error('Error ejecutando backtest:', error);
            
            if (this.currentBacktest) {
                this.backtestResults[this.currentBacktest.id] = {
                    ...this.currentBacktest,
                    status: 'failed',
                    error: error.message,
                    endTime: new Date(),
                    executionTime: new Date() - this.currentBacktest.startTime
                };
                
                // Emitir evento de error
                this.emit('backtestError', { 
                    id: this.currentBacktest.id,
                    error: error.message
                });
                
                this.currentBacktest = null;
            }
            
            throw error;
        }
    }
    
    /**
     * Filtra datos históricos según criterios
     * @param {Array} pairs - Pares de trading
     * @param {Array} exchanges - Exchanges
     * @param {Date} startDate - Fecha de inicio
     * @param {Date} endDate - Fecha de fin
     * @returns {Object} - Datos históricos filtrados
     */
    async filterHistoricalData(pairs, exchanges, startDate, endDate) {
        const filteredData = {};
        
        for (const pair of pairs) {
            if (!this.historicalData[pair]) continue;
            
            filteredData[pair] = {};
            
            for (const exchange of exchanges) {
                if (!this.historicalData[pair][exchange]) continue;
                
                // Filtrar por fecha
                filteredData[pair][exchange] = this.historicalData[pair][exchange].filter(data => {
                    const timestamp = new Date(data.timestamp);
                    return timestamp >= startDate && timestamp <= endDate;
                });
            }
        }
        
        return filteredData;
    }
    
    /**
     * Simula una estrategia con datos históricos
     * @param {string} strategyName - Nombre de la estrategia
     * @param {Object} data - Datos históricos
     * @param {number} initialCapital - Capital inicial
     * @param {Object} parameters - Parámetros de la estrategia
     * @returns {Object} - Resultados de la simulación
     */
    async simulateStrategy(strategyName, data, initialCapital, parameters) {
        // Obtener configuración de la estrategia
        const strategyConfig = this.config.STRATEGIES[strategyName.toUpperCase()] || this.config.STRATEGIES.BASIC;
        
        // Inicializar resultado
        const result = {
            trades: [],
            balanceHistory: [],
            equityHistory: [],
            positions: {},
            currentBalance: initialCapital,
            maxBalance: initialCapital,
            minBalance: initialCapital,
            finalBalance: initialCapital,
            totalTrades: 0,
            successfulTrades: 0,
            failedTrades: 0,
            totalProfit: 0,
            totalLoss: 0,
            netProfit: 0,
            winRate: 0,
            maxDrawdown: 0,
            maxDrawdownPercentage: 0
        };
        
        // Ordenar todos los datos por timestamp
        const allDataPoints = [];
        
        for (const pair in data) {
            for (const exchange in data[pair]) {
                for (const point of data[pair][exchange]) {
                    allDataPoints.push({
                        ...point,
                        pair,
                        exchange
                    });
                }
            }
        }
        
        // Ordenar por timestamp
        allDataPoints.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Inicializar balance histórico
        result.balanceHistory.push({
            timestamp: allDataPoints[0]?.timestamp || new Date().toISOString(),
            balance: initialCapital
        });
        
        result.equityHistory.push({
            timestamp: allDataPoints[0]?.timestamp || new Date().toISOString(),
            equity: initialCapital
        });
        
        // Simular trading
        let lastProgressUpdate = 0;
        
        for (let i = 0; i < allDataPoints.length; i++) {
            // Actualizar progreso cada 5%
            const progress = Math.floor((i / allDataPoints.length) * 100);
            if (progress >= lastProgressUpdate + 5) {
                lastProgressUpdate = progress;
                if (this.currentBacktest) {
                    this.currentBacktest.progress = progress;
                    this.emit('backtestProgress', { 
                        id: this.currentBacktest.id,
                        progress
                    });
                }
            }
            
            const currentPoint = allDataPoints[i];
            const { pair, exchange, timestamp, close: price } = currentPoint;
            
            // Buscar oportunidades de arbitraje
            const opportunities = await this.findArbitrageOpportunities(allDataPoints, i, strategyName, strategyConfig);
            
            // Ejecutar operaciones para oportunidades encontradas
            for (const opportunity of opportunities) {
                const trade = await this.executeTrade(opportunity, result.currentBalance, timestamp);
                
                if (trade) {
                    // Actualizar balance
                    result.currentBalance += trade.profit;
                    
                    // Actualizar estadísticas
                    result.totalTrades++;
                    if (trade.profit > 0) {
                        result.successfulTrades++;
                        result.totalProfit += trade.profit;
                    } else {
                        result.failedTrades++;
                        result.totalLoss += trade.profit; // Será negativo
                    }
                    
                    // Actualizar máximo y mínimo balance
                    result.maxBalance = Math.max(result.maxBalance, result.currentBalance);
                    result.minBalance = Math.min(result.minBalance, result.currentBalance);
                    
                    // Registrar operación
                    result.trades.push(trade);
                }
            }
            
            // Actualizar historial de balance cada hora simulada
            if (i % 6 === 0) { // Asumiendo 6 puntos por hora
                result.balanceHistory.push({
                    timestamp,
                    balance: result.currentBalance
                });
                
                // Calcular equity (balance + valor de posiciones abiertas)
                let equity = result.currentBalance;
                
                // Añadir valor de posiciones abiertas (si las hubiera)
                for (const positionPair in result.positions) {
                    for (const positionExchange in result.positions[positionPair]) {
                        const position = result.positions[positionPair][positionExchange];
                        // En este ejemplo simplificado no manejamos posiciones abiertas
                    }
                }
                
                result.equityHistory.push({
                    timestamp,
                    equity
                });
            }
        }
        
        // Finalizar resultado
        result.finalBalance = result.currentBalance;
        result.netProfit = result.totalProfit + result.totalLoss;
        result.winRate = result.totalTrades > 0 ? result.successfulTrades / result.totalTrades : 0;
        
        // Calcular drawdown
        let peak = initialCapital;
        let maxDrawdown = 0;
        let maxDrawdownPercentage = 0;
        
        for (const point of result.balanceHistory) {
            if (point.balance > peak) {
                peak = point.balance;
            } else {
                const drawdown = peak - point.balance;
                const drawdownPercentage = drawdown / peak;
                
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                    maxDrawdownPercentage = drawdownPercentage;
                }
            }
        }
        
        result.maxDrawdown = maxDrawdown;
        result.maxDrawdownPercentage = maxDrawdownPercentage;
        
        return result;
    }
    
    /**
     * Busca oportunidades de arbitraje en datos históricos
     * @param {Array} dataPoints - Puntos de datos históricos
     * @param {number} currentIndex - Índice actual
     * @param {string} strategyName - Nombre de la estrategia
     * @param {Object} strategyConfig - Configuración de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findArbitrageOpportunities(dataPoints, currentIndex, strategyName, strategyConfig) {
        const opportunities = [];
        const currentPoint = dataPoints[currentIndex];
        const { timestamp } = currentPoint;
        
        // Obtener precios actuales para todos los pares y exchanges
        const currentPrices = {};
        
        // Buscar en un rango cercano al punto actual (simulando datos simultáneos)
        const rangeStart = Math.max(0, currentIndex - 10);
        const rangeEnd = Math.min(dataPoints.length - 1, currentIndex + 10);
        
        for (let i = rangeStart; i <= rangeEnd; i++) {
            const point = dataPoints[i];
            const { pair, exchange, close: price } = point;
            
            if (!currentPrices[pair]) {
                currentPrices[pair] = {};
            }
            
            currentPrices[pair][exchange] = price;
        }
        
        // Buscar oportunidades según la estrategia
        switch (strategyName.toLowerCase()) {
            case 'basic':
                return this.findBasicArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                
            case 'triangular':
                return this.findTriangularArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                
            case 'statistical':
                return this.findStatisticalArbitrageOpportunities(currentPrices, dataPoints, currentIndex, strategyConfig);
                
            case 'ml':
                return this.findMLArbitrageOpportunities(currentPrices, dataPoints, currentIndex, strategyConfig);
                
            case 'combined':
                // Combinar resultados de varias estrategias
                const basicOpps = await this.findBasicArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                const triangularOpps = await this.findTriangularArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                const statisticalOpps = await this.findStatisticalArbitrageOpportunities(currentPrices, dataPoints, currentIndex, strategyConfig);
                
                return [...basicOpps, ...triangularOpps, ...statisticalOpps];
                
            default:
                return this.findBasicArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
        }
    }
    
    /**
     * Busca oportunidades de arbitraje básico
     * @param {Object} prices - Precios actuales
     * @param {string} timestamp - Timestamp actual
     * @param {Object} config - Configuración de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findBasicArbitrageOpportunities(prices, timestamp, config) {
        const opportunities = [];
        const minProfitPercentage = config.minProfitPercentage || 0.2;
        
        for (const pair in prices) {
            const exchanges = Object.keys(prices[pair]);
            
            // Necesitamos al menos 2 exchanges para arbitraje
            if (exchanges.length < 2) continue;
            
            // Encontrar el exchange con el precio más bajo y más alto
            let lowestPrice = Infinity;
            let highestPrice = -Infinity;
            let buyExchange = null;
            let sellExchange = null;
            
            for (const exchange of exchanges) {
                const price = prices[pair][exchange];
                
                if (price < lowestPrice) {
                    lowestPrice = price;
                    buyExchange = exchange;
                }
                
                if (price > highestPrice) {
                    highestPrice = price;
                    sellExchange = exchange;
                }
            }
            
            // Calcular ganancia potencial
            const profitPercentage = ((highestPrice - lowestPrice) / lowestPrice) * 100;
            
            // Verificar si la ganancia supera el mínimo requerido
            if (profitPercentage >= minProfitPercentage && buyExchange !== sellExchange) {
                opportunities.push({
                    type: 'basic',
                    pair,
                    buyExchange,
                    sellExchange,
                    buyPrice: lowestPrice,
                    sellPrice: highestPrice,
                    profitPercentage,
                    timestamp
                });
            }
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje triangular
     * @param {Object} prices - Precios actuales
     * @param {string} timestamp - Timestamp actual
     * @param {Object} config - Configuración de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findTriangularArbitrageOpportunities(prices, timestamp, config) {
        // En una implementación real, aquí buscaríamos oportunidades de arbitraje triangular
        // Para esta implementación, simularemos algunas oportunidades
        
        const opportunities = [];
        const minProfitPercentage = config.minProfitPercentage || 0.15;
        
        // Simular algunas oportunidades triangulares
        if (Math.random() < 0.05) { // 5% de probabilidad de encontrar una oportunidad
            const profitPercentage = minProfitPercentage + Math.random() * 0.5;
            
            // Elegir pares y exchanges aleatorios
            const availablePairs = Object.keys(prices);
            if (availablePairs.length < 2) return opportunities;
            
            const pair1 = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            let pair2 = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            while (pair2 === pair1) {
                pair2 = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            }
            
            const availableExchanges = Object.keys(prices[pair1]);
            if (availableExchanges.length < 1) return opportunities;
            
            const exchange = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            
            opportunities.push({
                type: 'triangular',
                pairs: [pair1, pair2],
                exchange,
                steps: [
                    { pair: pair1, action: 'buy', price: prices[pair1][exchange] || 1000 },
                    { pair: pair2, action: 'sell', price: prices[pair2][exchange] || 1000 }
                ],
                profitPercentage,
                timestamp
            });
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje estadístico
     * @param {Object} prices - Precios actuales
     * @param {Array} dataPoints - Puntos de datos históricos
     * @param {number} currentIndex - Índice actual
     * @param {Object} config - Configuración de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findStatisticalArbitrageOpportunities(prices, dataPoints, currentIndex, config) {
        // En una implementación real, aquí buscaríamos oportunidades de arbitraje estadístico
        // Para esta implementación, simularemos algunas oportunidades
        
        const opportunities = [];
        const minProfitPercentage = config.minProfitPercentage || 0.1;
        const lookbackPeriod = config.lookbackPeriod || 100;
        const zScoreThreshold = config.zScoreThreshold || 2.0;
        
        // Simular algunas oportunidades estadísticas
        if (Math.random() < 0.03) { // 3% de probabilidad de encontrar una oportunidad
            const profitPercentage = minProfitPercentage + Math.random() * 0.3;
            
            // Elegir par y exchanges aleatorios
            const availablePairs = Object.keys(prices);
            if (availablePairs.length < 1) return opportunities;
            
            const pair = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            
            const availableExchanges = Object.keys(prices[pair]);
            if (availableExchanges.length < 2) return opportunities;
            
            const exchange1 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            let exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            while (exchange2 === exchange1) {
                exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            }
            
            opportunities.push({
                type: 'statistical',
                pair,
                buyExchange: exchange1,
                sellExchange: exchange2,
                buyPrice: prices[pair][exchange1] || 1000,
                sellPrice: prices[pair][exchange2] || 1000,
                zScore: zScoreThreshold + Math.random(),
                profitPercentage,
                timestamp: dataPoints[currentIndex].timestamp
            });
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje con ML
     * @param {Object} prices - Precios actuales
     * @param {Array} dataPoints - Puntos de datos históricos
     * @param {number} currentIndex - Índice actual
     * @param {Object} config - Configuración de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findMLArbitrageOpportunities(prices, dataPoints, currentIndex, config) {
        // En una implementación real, aquí usaríamos un modelo de ML para encontrar oportunidades
        // Para esta implementación, simularemos algunas oportunidades
        
        const opportunities = [];
        const confidenceThreshold = config.confidenceThreshold || 0.7;
        
        // Simular algunas oportunidades basadas en ML
        if (Math.random() < 0.02) { // 2% de probabilidad de encontrar una oportunidad
            const confidence = confidenceThreshold + Math.random() * (1 - confidenceThreshold);
            const profitPercentage = 0.1 + Math.random() * 0.4;
            
            // Elegir par y exchanges aleatorios
            const availablePairs = Object.keys(prices);
            if (availablePairs.length < 1) return opportunities;
            
            const pair = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            
            const availableExchanges = Object.keys(prices[pair]);
            if (availableExchanges.length < 2) return opportunities;
            
            const exchange1 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            let exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            while (exchange2 === exchange1) {
                exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            }
            
            opportunities.push({
                type: 'ml',
                pair,
                buyExchange: exchange1,
                sellExchange: exchange2,
                buyPrice: prices[pair][exchange1] || 1000,
                sellPrice: prices[pair][exchange2] || 1000,
                confidence,
                profitPercentage,
                timestamp: dataPoints[currentIndex].timestamp
            });
        }
        
        return opportunities;
    }
    
    /**
     * Ejecuta una operación simulada
     * @param {Object} opportunity - Oportunidad de arbitraje
     * @param {number} balance - Balance actual
     * @param {string} timestamp - Timestamp actual
     * @returns {Object|null} - Detalles de la operación o null si no se ejecutó
     */
    async executeTrade(opportunity, balance, timestamp) {
        // Determinar cantidad a invertir (10% del balance)
        const investmentAmount = balance * 0.1;
        
        // Verificar si hay suficiente balance
        if (investmentAmount < 10) { // Mínimo $10
            return null;
        }
        
        // Calcular comisiones
        const buyCommission = investmentAmount * this.commissionRate;
        const sellCommission = (investmentAmount * (1 + opportunity.profitPercentage / 100)) * this.commissionRate;
        
        // Calcular slippage
        const buySlippage = investmentAmount * this.slippageRate;
        const sellSlippage = (investmentAmount * (1 + opportunity.profitPercentage / 100)) * this.slippageRate;
        
        // Calcular ganancia neta
        const grossProfit = investmentAmount * (opportunity.profitPercentage / 100);
        const netProfit = grossProfit - buyCommission - sellCommission - buySlippage - sellSlippage;
        
        // Simular éxito/fallo (95% éxito)
        const success = Math.random() > 0.05;
        
        // Si falla, perder una parte de la inversión
        const finalProfit = success ? netProfit : -investmentAmount * 0.02;
        
        return {
            timestamp,
            type: opportunity.type,
            pair: opportunity.pair || (opportunity.pairs ? opportunity.pairs[0] : 'unknown'),
            buyExchange: opportunity.buyExchange || opportunity.exchange || 'unknown',
            sellExchange: opportunity.sellExchange || opportunity.exchange || 'unknown',
            buyPrice: opportunity.buyPrice || 0,
            sellPrice: opportunity.sellPrice || 0,
            investmentAmount,
            grossProfit,
            fees: buyCommission + sellCommission,
            slippage: buySlippage + sellSlippage,
            netProfit,
            profit: finalProfit,
            profitPercentage: (finalProfit / investmentAmount) * 100,
            success
        };
    }
    
    /**
     * Calcula métricas de rendimiento
     * @param {Object} result - Resultados del backtest
     * @returns {Object} - Métricas calculadas
     */
    calculateMetrics(result) {
        const metrics = {};
        
        // Total Return
        metrics.totalReturn = ((result.finalBalance - this.initialCapital) / this.initialCapital) * 100;
        
        // Annualized Return (asumiendo 365 días por año)
        const days = result.balanceHistory.length > 1 ? 
            (new Date(result.balanceHistory[result.balanceHistory.length - 1].timestamp) - 
             new Date(result.balanceHistory[0].timestamp)) / (1000 * 60 * 60 * 24) : 1;
        
        metrics.annualizedReturn = ((1 + metrics.totalReturn / 100) ** (365 / days) - 1) * 100;
        
        // Sharpe Ratio (asumiendo tasa libre de riesgo del 2%)
        const riskFreeRate = 0.02;
        const returns = [];
        
        for (let i = 1; i < result.balanceHistory.length; i++) {
            const prevBalance = result.balanceHistory[i - 1].balance;
            const currentBalance = result.balanceHistory[i].balance;
            returns.push((currentBalance - prevBalance) / prevBalance);
        }
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const stdReturn = Math.sqrt(returns.reduce((sum, r) => sum + (r - avgReturn) ** 2, 0) / returns.length);
        
        metrics.sharpeRatio = stdReturn !== 0 ? 
            (avgReturn - riskFreeRate / 365) / stdReturn * Math.sqrt(365) : 0;
        
        // Max Drawdown
       metrics.maxDrawdown = result.maxDrawdown;
        metrics.maxDrawdownPercentage = result.maxDrawdownPercentage * 100;
        
        // Win Rate
        metrics.winRate = result.winRate * 100;
        
        // Profit Factor
        metrics.profitFactor = result.totalLoss !== 0 ? 
            Math.abs(result.totalProfit / result.totalLoss) : 
            (result.totalProfit > 0 ? Infinity : 0);
        
        // Calmar Ratio
        metrics.calmarRatio = metrics.maxDrawdownPercentage !== 0 ? 
            metrics.annualizedReturn / metrics.maxDrawdownPercentage : 0;
        
        // Average Trade
        metrics.averageTrade = result.totalTrades > 0 ? 
            result.netProfit / result.totalTrades : 0;
        
        // Best Trade
        metrics.bestTrade = result.trades.length > 0 ? 
            Math.max(...result.trades.map(t => t.profit)) : 0;
        
        // Worst Trade
        metrics.worstTrade = result.trades.length > 0 ? 
            Math.min(...result.trades.map(t => t.profit)) : 0;
        
        // Average Win
        const winningTrades = result.trades.filter(t => t.profit > 0);
        metrics.averageWin = winningTrades.length > 0 ? 
            winningTrades.reduce((sum, t) => sum + t.profit, 0) / winningTrades.length : 0;
        
        // Average Loss
        const losingTrades = result.trades.filter(t => t.profit < 0);
        metrics.averageLoss = losingTrades.length > 0 ? 
            losingTrades.reduce((sum, t) => sum + t.profit, 0) / losingTrades.length : 0;
        
        // Largest Winning Streak
        let currentWinStreak = 0;
        let maxWinStreak = 0;
        
        for (const trade of result.trades) {
            if (trade.profit > 0) {
                currentWinStreak++;
                maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
            } else {
                currentWinStreak = 0;
            }
        }
        
        metrics.largestWinningStreak = maxWinStreak;
        
        // Largest Losing Streak
        let currentLossStreak = 0;
        let maxLossStreak = 0;
        
        for (const trade of result.trades) {
            if (trade.profit < 0) {
                currentLossStreak++;
                maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
            } else {
                currentLossStreak = 0;
            }
        }
        
        metrics.largestLosingStreak = maxLossStreak;
        
        return metrics;
    }
    
    /**
     * Ejecuta simulaciones de Monte Carlo
     * @param {Object} result - Resultados del backtest
     * @returns {Object} - Resultados de Monte Carlo
     */
    async runMonteCarloSimulations(result) {
        const simulations = [];
        const trades = result.trades;
        
        if (trades.length === 0) {
            return { simulations: [], statistics: {} };
        }
        
        // Extraer retornos de las operaciones
        const returns = trades.map(trade => trade.profit / this.initialCapital);
        
        // Ejecutar simulaciones
        for (let sim = 0; sim < this.monteCarloSimulations; sim++) {
            let balance = this.initialCapital;
            const simulationReturns = [];
            
            // Generar secuencia aleatoria de retornos
            for (let i = 0; i < trades.length; i++) {
                const randomReturn = returns[Math.floor(Math.random() * returns.length)];
                balance += balance * randomReturn;
                simulationReturns.push((balance - this.initialCapital) / this.initialCapital);
            }
            
            simulations.push({
                finalReturn: simulationReturns[simulationReturns.length - 1],
                maxDrawdown: this.calculateSimulationDrawdown(simulationReturns),
                returns: simulationReturns
            });
        }
        
        // Calcular estadísticas
        const finalReturns = simulations.map(sim => sim.finalReturn);
        const maxDrawdowns = simulations.map(sim => sim.maxDrawdown);
        
        finalReturns.sort((a, b) => a - b);
        maxDrawdowns.sort((a, b) => a - b);
        
        const statistics = {};
        
        // Intervalos de confianza para retorno final
        for (const confidence of this.confidenceIntervals) {
            const lowerIndex = Math.floor((1 - confidence) / 2 * finalReturns.length);
            const upperIndex = Math.floor((1 + confidence) / 2 * finalReturns.length);
            
            statistics[`finalReturn_${confidence * 100}%`] = {
                lower: finalReturns[lowerIndex] * 100,
                upper: finalReturns[upperIndex] * 100
            };
        }
        
        // Intervalos de confianza para máximo drawdown
        for (const confidence of this.confidenceIntervals) {
            const lowerIndex = Math.floor((1 - confidence) / 2 * maxDrawdowns.length);
            const upperIndex = Math.floor((1 + confidence) / 2 * maxDrawdowns.length);
            
            statistics[`maxDrawdown_${confidence * 100}%`] = {
                lower: maxDrawdowns[lowerIndex] * 100,
                upper: maxDrawdowns[upperIndex] * 100
            };
        }
        
        // Probabilidad de pérdida
        const lossCount = finalReturns.filter(r => r < 0).length;
        statistics.probabilityOfLoss = (lossCount / finalReturns.length) * 100;
        
        return { simulations, statistics };
    }
    
    /**
     * Calcula el drawdown para una simulación
     * @param {Array} returns - Retornos de la simulación
     * @returns {number} - Máximo drawdown
     */
    calculateSimulationDrawdown(returns) {
        let peak = 0;
        let maxDrawdown = 0;
        
        for (const returnValue of returns) {
            if (returnValue > peak) {
                peak = returnValue;
            } else {
                const drawdown = peak - returnValue;
                maxDrawdown = Math.max(maxDrawdown, drawdown);
            }
        }
        
        return maxDrawdown;
    }
    
    /**
     * Obtiene los resultados de un backtest
     * @param {string} backtestId - ID del backtest
     * @returns {Object|null} - Resultados del backtest
     */
    getBacktestResults(backtestId) {
        return this.backtestResults[backtestId] || null;
    }
    
    /**
     * Obtiene la lista de todos los backtests
     * @returns {Array} - Lista de backtests
     */
    getAllBacktests() {
        return Object.values(this.backtestResults);
    }
    
    /**
     * Obtiene el estado del backtest actual
     * @returns {Object|null} - Estado del backtest actual
     */
    getCurrentBacktestStatus() {
        return this.currentBacktest;
    }
    
    /**
     * Cancela el backtest actual
     */
    cancelCurrentBacktest() {
        if (this.currentBacktest) {
            this.backtestResults[this.currentBacktest.id] = {
                ...this.currentBacktest,
                status: 'cancelled',
                endTime: new Date(),
                executionTime: new Date() - this.currentBacktest.startTime
            };
            
            this.emit('backtestCancelled', { id: this.currentBacktest.id });
            this.currentBacktest = null;
        }
    }
}

module.exports = BacktestEngine;

-------------------------------------------------------------------------------------------------------

// ========== GESTOR DE DATOS HISTÓRICOS PARA BACKTESTING ==========
const fs = require("fs").promises
const path = require("path")
const config = require("../config") // Ajusta la ruta según tu estructura
const { ExchangeManager } = require("../exchanges") // Ajusta la ruta

class HistoricalDataManager {
  constructor(exchangeManager) {
    this.dataDir = config.BACKTESTING.HISTORICAL_DATA_PATH || "./historical_data"
    this.exchangeManager = exchangeManager || new ExchangeManager() // Puede pasarse o crearse uno nuevo
    this.ensureDataDirExists()
  }

  async ensureDataDirExists() {
    try {
      await fs.mkdir(this.dataDir, { recursive: true })
      console.log(`Directorio de datos históricos asegurado: ${this.dataDir}`)
    } catch (error) {
      console.error(`Error creando directorio de datos históricos ${this.dataDir}:`, error)
    }
  }

  getFilePath(exchange, pair, date) {
    // Formato de fecha YYYY-MM-DD
    const dateString = date.toISOString().split("T")[0]
    const pairFilename = pair.replace("/", "_") // BTC/USDT -> BTC_USDT
    return path.join(this.dataDir, exchange, pairFilename, `${dateString}.json`)
  }

  async saveData(exchange, pair, date, data) {
    const filePath = this.getFilePath(exchange, pair, date)
    try {
      await fs.mkdir(path.dirname(filePath), { recursive: true })
      await fs.writeFile(filePath, JSON.stringify(data, null, 2))
      console.log(`Datos guardados para ${exchange} - ${pair} en ${filePath}`)
    } catch (error) {
      console.error(`Error guardando datos en ${filePath}:`, error)
    }
  }

  async loadData(exchange, pair, date) {
    const filePath = this.getFilePath(exchange, pair, date)
    try {
      const data = await fs.readFile(filePath, "utf-8")
      return JSON.parse(data)
    } catch (error) {
      if (error.code === "ENOENT") {
        // console.log(`No se encontraron datos para ${exchange} - ${pair} en ${filePath}`);
        return null
      }
      console.error(`Error cargando datos desde ${filePath}:`, error)
      return null
    }
  }

  // Ejemplo: Obtener datos de Klines (velas)
  // Binance API: /api/v3/klines
  // KuCoin API: /api/v1/market/candles
  async fetchAndStoreCandlestickData(exchange, pair, interval = "1m", startTime, endTime) {
    // Esta función necesitaría implementaciones específicas por exchange
    // y manejar paginación si es necesario.
    console.log(
      `Simulando obtención de datos de velas para ${exchange} - ${pair} de ${new Date(startTime)} a ${new Date(endTime)}`,
    )

    // Ejemplo simplificado: generar datos aleatorios para un día
    const date = new Date(startTime)
    const existingData = await this.loadData(exchange, pair, date)
    if (existingData) {
      console.log(`Datos para ${exchange} - ${pair} en ${date.toISOString().split("T")[0]} ya existen.`)
      return existingData
    }

    const mockCandles = []
    let currentTime = startTime
    while (currentTime < endTime) {
      const open = Math.random() * 100 + 1000 // Precio de apertura aleatorio
      const close = open + (Math.random() - 0.5) * 10
      const high = Math.max(open, close) + Math.random() * 5
      const low = Math.min(open, close) - Math.random() * 5
      const volume = Math.random() * 1000

      mockCandles.push([
        currentTime, // Open time
        open.toFixed(4), // Open
        high.toFixed(4), // High
        low.toFixed(4), // Low
        close.toFixed(4), // Close
        volume.toFixed(4), // Volume
        currentTime + (60000 - 1), // Close time (para intervalo de 1m)
        (volume * ((open + close) / 2)).toFixed(4), // Quote asset volume
        Math.floor(Math.random() * 100), // Number of trades
        (volume / 2).toFixed(4), // Taker buy base asset volume
        ((volume * ((open + close) / 2)) / 2).toFixed(4), // Taker buy quote asset volume
        "0", // Ignore
      ])
      currentTime += 60000 // Avanzar 1 minuto
    }

    await this.saveData(exchange, pair, date, mockCandles)
    return mockCandles
  }

  async getHistoricalRange(exchange, pair, startDate, endDate, interval = "1m") {
    let allData = []
    const currentDate = new Date(startDate)
    const finalDate = new Date(endDate)

    while (currentDate <= finalDate) {
      let dailyData = await this.loadData(exchange, pair, currentDate)
      if (!dailyData) {
        // Si no hay datos locales, intentar obtenerlos (si se implementa la lógica de fetch real)
        // Por ahora, para el ejemplo, podríamos simular o simplemente saltar.
        console.log(
          `No hay datos locales para ${exchange} - ${pair} en ${currentDate.toISOString().split("T")[0]}, intentando obtener...`,
        )
        dailyData = await this.fetchAndStoreCandlestickData(
          exchange,
          pair,
          interval,
          currentDate.getTime(),
          currentDate.getTime() + (24 * 60 * 60 * 1000 - 1),
        )
      }
      if (dailyData) {
        allData = allData.concat(dailyData)
      }
      currentDate.setDate(currentDate.getDate() + 1) // Siguiente día
    }
    return allData
  }
}

module.exports = { HistoricalDataManager }

---------------------------------------------------------------------------------------------------------------

CORE 

const EventEmitter = require('events');
const nodemailer = require('nodemailer');
const axios = require('axios');

/**
 * Gestor de Alertas
 * Maneja notificaciones por email, Telegram, Discord y Slack
 */
class AlertManager extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.enabled = config.ALERTS.ENABLED;
        this.channels = config.ALERTS.CHANNELS;
        this.alertTypes = config.ALERTS.ALERT_TYPES;
        
        this.emailTransporter = null;
        this.alertHistory = [];
        this.alertQueue = [];
        this.isProcessingQueue = false;
        
        this.logger = console;
    }

    initialize() {
        // Método vacío para compatibilidad con el bot base
        // Agrega aquí inicialización si la necesitas en el futuro
    }
    
    // ... (el resto de los métodos de AlertManager quedan igual, como en tu dump)
}

module.exports = AlertManager;
---------------------------------------------------------------------------------------------------
const StrategyManager = require('./StrategyManager');
const AlertManager = require('./AlertManager');
const ExchangeManager = require('../exchanges/exchange-manager');

class CEXArbitrageBot {
    constructor(config) {
        this.config = config;
        this.logger = console;
        this.exchangeManager = new ExchangeManager(config);
        this.strategyManager = new StrategyManager(config);   // <-- AGREGADO
        this.alertManager = new AlertManager(config);         // <-- AGREGADO
        console.log("✅ CEXArbitrageBot base inicializado");
        this.botState = {
            isRunning: false,
            totalProfit: 0
        };
    }

    async initialize() {
    this.logger.info('Iniciando bot de arbitraje...');
    if (typeof this.strategyManager.initialize === 'function') {
        this.strategyManager.initialize();
    }
    await this.alertManager.initialize();
    this.logger.info('Bot inicializado correctamente');
}

    async start() {
        console.log("⚙️ Bot base iniciado");
        if (this.isRunning) return;
        await this.initialize();
        this.isRunning = true;
        this.logger.info('Bot arrancando ciclo de arbitraje...');
        while (this.isRunning) {
            try {
                const prices = {
                    BINANCE: Math.random() * 100 + 100,
                    KUCOIN: Math.random() * 100 + 100,
                    OKX: Math.random() * 100 + 100
                };
                const pair = "BTC/USDT";
                const opportunities = [
                    ...this.strategyManager.findBasicArbitrage(prices, pair),
                    ...this.strategyManager.findTriangularArbitrage(prices, pair),
                    ...this.strategyManager.findStatisticalArbitrage(prices, pair)
                ];
                if (opportunities.length > 0) {
                    for (const opp of opportunities) {
                        await this.alertManager.sendAlert(
                            "OPPORTUNITY",
                            `Oportunidad de arbitraje detectada: ${opp.strategy} (${opp.profitPercentage.toFixed(2)}%)`,
                            opp
                        );
                        this.strategyManager.updateStrategyPerformance(opp.strategy, {
                            success: true,
                            profit: opp.profitPercentage
                        });
                    }
                }
                await this._sleep(10000);
            } catch (error) {
                this.logger.error('Error en el ciclo principal:', error);
            }
        }
    }

    stop() {
        console.log("⚙️ Bot base detenido");
        this.isRunning = false;
        this.logger.info('Bot detenido.');
    }

    _sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

module.exports = { CEXArbitrageBot };
---------------------------------------------------------------------------------------------------------

const EventEmitter = require('events');

/**
 * Gestor de Estrategias
 * Maneja múltiples estrategias de arbitraje y su selección
 */
class StrategyManager extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.strategies = config.STRATEGIES;
        this.activeStrategy = 'BASIC';
        this.strategyInstances = {};
        this.strategyPerformance = {};
        this.strategyHistory = [];
        this.logger = console;
    }

    findBasicArbitrage(prices, pair) {
        // Aquí va tu lógica de arbitraje básico
        // Por ahora devolvemos un array vacío para evitar errores
        return [];
    }

    findTriangularArbitrage(prices, pair) {
        // Aquí va tu lógica de arbitraje triangular
        return [];
    }

    findStatisticalArbitrage(prices, pair) {
        // Aquí va tu lógica de arbitraje estadístico
        return [];
    }

    // ... (el resto de los métodos de StrategyManager quedan igual, como en tu dump)
}

/**
 * Clase Strategy
 * Representa una estrategia individual
 */
class Strategy {
    constructor(name, config) {
        this.name = name;
        this.config = config;
        this.isActive = false;
        this.lastExecution = null;
    }
    
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    
    execute(marketData) {
        this.lastExecution = new Date();
        // Implementación específica de cada estrategia
        return [];
    }
}

module.exports = StrategyManager;

-------------------------------------------------------------------------------------------------------------
CSS

.dashboard-container {
  display: flex;
  min-height: 100vh;
  background: linear-gradient(160deg, #6a11cb 0%, #2575fc 100%);
}

.sidebar {
  width: 220px;
  background: #222;
  color: #fff;
  padding: 30px 10px;
  min-height: 100vh;
}
.sidebar h2 {
  font-size: 1.2em;
  margin-bottom: 2em;
}
.sidebar ul {
  list-style: none;
  padding: 0;
}
.sidebar li {
  margin: 18px 0;
}
.sidebar a {
  color: #fff;
  text-decoration: none;
  font-weight: bold;
}

.dashboard-main {
  flex: 1;
  padding: 32px;
  display: flex;
  flex-direction: column;
}
.dashboard-row {
  display: flex;
  flex-wrap: wrap;
  gap: 22px;
  margin-bottom: 28px;
}
.panel {
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 4px 16px rgba(100,100,100,0.10);
  padding: 22px;
  flex: 1;
  min-width: 320px;
  max-width: 420px;
}
.panel h3 {
  font-size: 1.15em;
  margin-bottom: 12px;
}
.panel ul {
  margin: 0;
  padding-left: 18px;
}
button {
  margin-bottom: 10px;
  background: #2575fc;
  color: #fff;
  padding: 8px 18px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
button:disabled {
  background: #aaa;
}
input, select {
  margin: 4px 0 10px 0;
  padding: 6px 10px;
  border-radius: 4px;
  border: 1px solid #ccc;
}

------------------------------------------------------------------------------------------------------------

EXCHANGES

const ccxt = require("ccxt")

/**
 * Gestor de Exchanges para el Bot de Arbitraje
 */
class ExchangeManager {
  constructor(config) {
    this.config = config
    this.exchanges = {}
    this.logger = console
  }

  /**
   * 
   * Inicializa las conexiones a los exchanges
   */
  async initialize() {
    try {
      this.logger.info("🔄 Inicializando conexiones a exchanges...")

      // Configurar Binance
      if (this.config.EXCHANGES.BINANCE.enabled) {
        this.exchanges.binance = new ccxt.binance({
          apiKey: this.config.EXCHANGES.BINANCE.apiKey,
          secret: this.config.EXCHANGES.BINANCE.apiSecret,
          sandbox: this.config.EXCHANGES.BINANCE.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.BINANCE.rateLimit,
        })

        await this.exchanges.binance.loadMarkets()
        this.logger.info("✅ Binance conectado")
      }

      // Configurar Bybit (NUEVO)
      if (this.config.EXCHANGES.BYBIT.enabled) {
        this.exchanges.bybit = new ccxt.bybit({
          apiKey: this.config.EXCHANGES.BYBIT.apiKey,
          secret: this.config.EXCHANGES.BYBIT.apiSecret,
          sandbox: this.config.EXCHANGES.BYBIT.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.BYBIT.rateLimit,
        })

        await this.exchanges.bybit.loadMarkets()
        this.logger.info("✅ Bybit conectado")
      }

      // Configurar Kucoin (DESHABILITADO)
      if (this.config.EXCHANGES.KUCOIN.enabled) {
        this.exchanges.kucoin = new ccxt.kucoin({
          apiKey: this.config.EXCHANGES.KUCOIN.apiKey,
          secret: this.config.EXCHANGES.KUCOIN.apiSecret,
          password: this.config.EXCHANGES.KUCOIN.passphrase,
          sandbox: this.config.EXCHANGES.KUCOIN.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.KUCOIN.rateLimit,
        })

        await this.exchanges.kucoin.loadMarkets()
        this.logger.info("✅ Kucoin conectado")
      }

      // Configurar Coinbase (si está habilitado)
      if (this.config.EXCHANGES.COINBASE.enabled) {
        this.exchanges.coinbase = new ccxt.coinbasepro({
          apiKey: this.config.EXCHANGES.COINBASE.apiKey,
          secret: this.config.EXCHANGES.COINBASE.apiSecret,
          password: this.config.EXCHANGES.COINBASE.passphrase,
          sandbox: this.config.EXCHANGES.COINBASE.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.COINBASE.rateLimit,
        })

        await this.exchanges.coinbase.loadMarkets()
        this.logger.info("✅ Coinbase conectado")
      }

      // Configurar Kraken (si está habilitado)
      if (this.config.EXCHANGES.KRAKEN.enabled) {
        this.exchanges.kraken = new ccxt.kraken({
          apiKey: this.config.EXCHANGES.KRAKEN.apiKey,
          secret: this.config.EXCHANGES.KRAKEN.apiSecret,
          sandbox: this.config.EXCHANGES.KRAKEN.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.KRAKEN.rateLimit,
        })

        await this.exchanges.kraken.loadMarkets()
        this.logger.info("✅ Kraken conectado")
      }

      this.logger.info("🎉 ExchangeManager inicializado correctamente")
      return true
    } catch (error) {
      this.logger.error("❌ Error inicializando ExchangeManager:", error.message)
      throw error
    }
  }

  /**
   * Obtiene un exchange por su nombre
   */
  getExchange(exchangeName) {
    return this.exchanges[exchangeName.toLowerCase()]
  }

  /**
   * Obtiene todos los exchanges
   */
  getAllExchanges() {
    return this.exchanges
  }

  /**
   * Obtiene los nombres de los exchanges habilitados
   */
  getEnabledExchangeNames() {
    return Object.keys(this.exchanges)
  }

  /**
   * Verifica si un exchange está habilitado
   */
  isExchangeEnabled(exchangeName) {
    return !!this.exchanges[exchangeName.toLowerCase()]
  }

  /**
   * Obtiene el balance de un exchange
   */
  async getBalance(exchangeName, symbol = null) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      const balance = await exchange.fetchBalance()
      if (symbol) {
        return balance[symbol] || { free: 0, used: 0, total: 0 }
      }
      return balance
    } catch (error) {
      this.logger.error(`❌ Error obteniendo balance de ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Obtiene el ticker de un par en un exchange
   */
  async getTicker(exchangeName, symbol) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      return await exchange.fetchTicker(symbol)
    } catch (error) {
      this.logger.error(`❌ Error obteniendo ticker de ${symbol} en ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Obtiene el libro de órdenes de un par en un exchange
   */
  async getOrderBook(exchangeName, symbol, limit = 5) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      return await exchange.fetchOrderBook(symbol, limit)
    } catch (error) {
      this.logger.error(`❌ Error obteniendo libro de órdenes de ${symbol} en ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Ejecuta una orden de compra
   */
  async buy(exchangeName, symbol, amount, price = null, params = {}) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      // Orden de mercado si no se especifica precio
      const orderType = price ? "limit" : "market"

      return await exchange.createOrder(symbol, orderType, "buy", amount, price, params)
    } catch (error) {
      this.logger.error(`❌ Error ejecutando orden de compra de ${symbol} en ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Ejecuta una orden de venta
   */
  async sell(exchangeName, symbol, amount, price = null, params = {}) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      // Orden de mercado si no se especifica precio
      const orderType = price ? "limit" : "market"

      return await exchange.createOrder(symbol, orderType, "sell", amount, price, params)
    } catch (error) {
      this.logger.error(`❌ Error ejecutando orden de venta de ${symbol} en ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Verifica el estado de una orden
   */
  async checkOrder(exchangeName, orderId, symbol) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      return await exchange.fetchOrder(orderId, symbol)
    } catch (error) {
      this.logger.error(`❌ Error verificando orden ${orderId} en ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Cancela una orden
   */
  async cancelOrder(exchangeName, orderId, symbol) {
    try {
      const exchange = this.getExchange(exchangeName)
      if (!exchange) {
        throw new Error(`Exchange ${exchangeName} no encontrado`)
      }

      return await exchange.cancelOrder(orderId, symbol)
    } catch (error) {
      this.logger.error(`❌ Error cancelando orden ${orderId} en ${exchangeName}:`, error.message)
      throw error
    }
  }

  /**
   * Cierra todas las conexiones
   */
  async close() {
    this.logger.info("🔄 Cerrando conexiones a exchanges...")
    // No hay un método específico para cerrar conexiones en ccxt
    // pero podemos limpiar el objeto exchanges
    this.exchanges = {}
    this.logger.info("✅ Conexiones cerradas")
  }

  // =========== AGREGADO PARA DASHBOARD PANEL DE COMISIONES ===========
  getFees() {
    // Devuelve las comisiones de cada exchange habilitado
    const fees = {}
    for (const [exName, exObj] of Object.entries(this.config.EXCHANGES)) {
      if (exObj.enabled && exObj.fees) {
        fees[exName] = exObj.fees
      }
    }
    return fees
  }
  // =========== FIN AGREGADO ===========
}

module.exports = ExchangeManager

----------------------------------------------------------------------------------------------------------------

// ========== MÓDULO DE GESTIÓN DE EXCHANGES ==========
const axios = require("axios")
const crypto = require("crypto")
const EventEmitter = require('events')
const config = require('../strategies/config');

class ExchangeManager extends EventEmitter {
  constructor(config) {
    super();
    this.config = config;
    this.exchanges = {
      BINANCE: {
        name: "Binance",
        baseURL: config.EXCHANGES.BINANCE.testnet || config.EXCHANGES.BINANCE.baseURL,
        apiKey: config.EXCHANGES.BINANCE.apiKey,
        apiSecret: config.EXCHANGES.BINANCE.apiSecret,
      },
      KUCOIN: {
        name: "KuCoin",
        baseURL: config.EXCHANGES.KUCOIN.testnet || config.EXCHANGES.KUCOIN.baseURL,
        apiKey: config.EXCHANGES.KUCOIN.apiKey,
        apiSecret: config.EXCHANGES.KUCOIN.apiSecret,
        passphrase: config.EXCHANGES.KUCOIN.passphrase,
      },
    }

    console.log(`🔄 Exchange Manager inicializado: ${Object.keys(this.exchanges).join(", ")}`)
    console.log(`🧪 Modo testnet: ${config.TRADING_MODE === 'simulation' ? "Activado" : "Desactivado"}`)
  }

  // Obtener precios de todos los pares en todos los exchanges
  async getAllPrices() {
    const allPrices = {}

    for (const pair of config.TRADING_PAIRS) {
      allPrices[pair.symbol] = {}

      for (const exchangeName of Object.keys(this.exchanges)) {
        try {
          const price = await this.getPrice(exchangeName, pair.symbol)
          allPrices[pair.symbol][exchangeName] = price
        } catch (error) {
          console.error(`Error obteniendo precio de ${pair.symbol} en ${exchangeName}:`, error.message)
        }
      }
    }

    return allPrices
  }

  // Obtener precio de un par en un exchange específico
  async getPrice(exchangeName, symbol) {
    if (exchangeName === "BINANCE") {
      return this.getBinancePrice(symbol)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinPrice(symbol)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener precio en Binance
  async getBinancePrice(symbol) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/ticker/price`, {
        params: { symbol: formattedSymbol },
      })

      return Number.parseFloat(response.data.price)
    } catch (error) {
      throw new Error(`Error en Binance: ${error.message}`)
    }
  }

  // Obtener precio en KuCoin
  async getKucoinPrice(symbol) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POL-USDT)
      const formattedSymbol = symbol.replace("/", "-")

      // Usar endpoint público sin autenticación para evitar problemas SSL
      const response = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1`, {
        params: { symbol: formattedSymbol },
        timeout: 10000,
        headers: {
          "User-Agent": "CEX-Arbitrage-Bot/1.0",
        },
      })

      // KuCoin devuelve precio en data.data.price
      return Number.parseFloat(response.data.data.price)
    } catch (error) {
      // Si falla KuCoin, usar precio simulado
      console.warn(`⚠️ Usando precio simulado para ${symbol} en KuCoin`)
      return this.getSimulatedPrice(symbol)
    }
  }

  // Calcular spread entre dos precios
  calculateSpread(price1, price2) {
    return Math.abs((price1 - price2) / Math.min(price1, price2)) * 100
  }

  // Obtener balances en un exchange
  async getBalances(exchangeName) {
    if (config.BOT.DRY_RUN) {
      // En modo simulación, devolver balances iniciales
      return this.getSimulatedBalances(exchangeName)
    }

    if (exchangeName === "BINANCE") {
      return this.getBinanceBalances()
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinBalances()
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Balances simulados para modo DRY_RUN
  getSimulatedBalances(exchangeName) {
    const initialBalances = config.INITIAL_BALANCES[exchangeName]
    const balances = {}

    for (const [asset, amount] of Object.entries(initialBalances)) {
      balances[asset] = {
        free: amount,
        locked: 0,
        total: amount,
      }
    }

    return balances
  }

  // Obtener balances en Binance
  async getBinanceBalances() {
    try {
      const timestamp = Date.now()
      const queryString = `timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/account`, {
        params: {
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      const balances = {}
      response.data.balances.forEach((balance) => {
        const free = Number.parseFloat(balance.free)
        const locked = Number.parseFloat(balance.locked)
        const total = free + locked

        if (total > 0) {
          balances[balance.asset] = {
            free,
            locked,
            total,
          }
        }
      })

      return balances
    } catch (error) {
      throw new Error(`Error obteniendo balances de Binance: ${error.message}`)
    }
  }

  // Obtener balances en KuCoin
  async getKucoinBalances() {
    try {
      // Primero necesitamos obtener un token de KuCoin
      const timestamp = Date.now()
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "GET" + "/api/v1/accounts")
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}/api/v1/accounts`, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
        },
      })

      const balances = {}
      response.data.data.forEach((balance) => {
        const free = Number.parseFloat(balance.available)
        const locked = Number.parseFloat(balance.holds)
        const total = free + locked

        if (total > 0) {
          balances[balance.currency] = {
            free,
            locked,
            total,
          }
        }
      })

      return balances
    } catch (error) {
      throw new Error(`Error obteniendo balances de KuCoin: ${error.message}`)
    }
  }

  // Colocar orden en un exchange
  async placeOrder(exchangeName, symbol, side, amount) {
    if (config.BOT.DRY_RUN) {
      // En modo simulación, simular la orden
      return this.simulateOrder(exchangeName, symbol, side, amount)
    }

    if (exchangeName === "BINANCE") {
      return this.placeBinanceOrder(symbol, side, amount)
    } else if (exchangeName === "KUCOIN") {
      return this.placeKucoinOrder(symbol, side, amount)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Simular orden para modo DRY_RUN
  async simulateOrder(exchangeName, symbol, side, amount) {
    try {
      const price = await this.getPrice(exchangeName, symbol)
      const executedQty = side === "buy" ? amount / price : amount
      const orderId = `sim-${Date.now()}-${Math.floor(Math.random() * 1000)}`

      console.log(
        `🧪 SIMULACIÓN: Orden ${side} de ${amount} ${symbol} en ${exchangeName} a precio ${price} (ID: ${orderId})`,
      )

      return {
        orderId,
        status: "FILLED",
        executedQty,
        price,
      }
    } catch (error) {
      throw new Error(`Error simulando orden: ${error.message}`)
    }
  }

  // Colocar orden en Binance
  async placeBinanceOrder(symbol, side, amount) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const timestamp = Date.now()
      const params = {
        symbol: formattedSymbol,
        side: side.toUpperCase(),
        type: "MARKET",
        quantity: amount,
        timestamp,
      }

      const queryString = Object.entries(params)
        .map(([key, value]) => `${key}=${value}`)
        .join("&")

      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.post(`${this.exchanges.BINANCE.baseURL}/api/v3/order`, null, {
        params: {
          ...params,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        orderId: response.data.orderId,
        status: response.data.status,
        executedQty: Number.parseFloat(response.data.executedQty),
        price: Number.parseFloat(response.data.price),
      }
    } catch (error) {
      throw new Error(`Error colocando orden en Binance: ${error.message}`)
    }
  }

  // Colocar orden en KuCoin
  async placeKucoinOrder(symbol, side, amount) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POL-USDT)
      const formattedSymbol = symbol.replace("/", "-")

      const timestamp = Date.now()
      const data = {
        clientOid: `bot-${timestamp}`,
        side: side.toUpperCase(),
        symbol: formattedSymbol,
        type: "market",
        size: amount,
      }

      const dataString = JSON.stringify(data)
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "POST" + "/api/v1/orders" + dataString)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.post(`${this.exchanges.KUCOIN.baseURL}/api/v1/orders`, data, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
          "Content-Type": "application/json",
        },
      })

      // KuCoin devuelve solo el ID de la orden, necesitamos consultar el estado
      const orderId = response.data.data.orderId
      const orderDetails = await this.getKucoinOrderDetails(orderId)

      return {
        orderId,
        status: orderDetails.status,
        executedQty: Number.parseFloat(orderDetails.executedQty),
        price: Number.parseFloat(orderDetails.price),
      }
    } catch (error) {
      throw new Error(`Error colocando orden en KuCoin: ${error.message}`)
    }
  }

  // Obtener detalles de una orden en KuCoin
  async getKucoinOrderDetails(orderId) {
    try {
      const timestamp = Date.now()
      const endpoint = `/api/v1/orders/${orderId}`
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "GET" + endpoint)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}${endpoint}`, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
        },
      })

      const order = response.data.data
      return {
        status: order.isActive ? "ACTIVE" : "FILLED",
        executedQty: order.dealSize,
        price: order.dealFunds / order.dealSize, // Precio promedio
      }
    } catch (error) {
      throw new Error(`Error obteniendo detalles de orden en KuCoin: ${error.message}`)
    }
  }

  // Obtener estado de una orden
  async getOrderStatus(exchangeName, orderId, symbol) {
    if (config.BOT.DRY_RUN) {
      // En modo simulación, devolver estado completado
      return {
        status: "FILLED",
        executedQty: 1,
        price: 1,
      }
    }

    if (exchangeName === "BINANCE") {
      return this.getBinanceOrderStatus(orderId, symbol)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinOrderDetails(orderId)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener estado de una orden en Binance
  async getBinanceOrderStatus(orderId, symbol) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const timestamp = Date.now()
      const queryString = `symbol=${formattedSymbol}&orderId=${orderId}&timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/order`, {
        params: {
          symbol: formattedSymbol,
          orderId,
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        status: response.data.status,
        executedQty: Number.parseFloat(response.data.executedQty),
        price: Number.parseFloat(response.data.price),
      }
    } catch (error) {
      throw new Error(`Error obteniendo estado de orden en Binance: ${error.message}`)
    }
  }

  // Obtener dirección de depósito
  async getDepositAddress(exchangeName, asset, network) {
    if (config.BOT.DRY_RUN) {
      // En modo simulación, devolver dirección simulada
      return {
        address: `sim-${exchangeName.toLowerCase()}-${asset.toLowerCase()}-address`,
        tag: null,
      }
    }

    if (exchangeName === "BINANCE") {
      return this.getBinanceDepositAddress(asset, network)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinDepositAddress(asset, network)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener dirección de depósito en Binance
  async getBinanceDepositAddress(asset, network) {
    try {
      const timestamp = Date.now()
      const queryString = `coin=${asset}&network=${network}&timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/sapi/v1/capital/deposit/address`, {
        params: {
          coin: asset,
          network,
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        address: response.data.address,
        tag: response.data.tag,
      }
    } catch (error) {
      throw new Error(`Error obteniendo dirección de depósito en Binance: ${error.message}`)
    }
  }

  // Obtener dirección de depósito en KuCoin
  async getKucoinDepositAddress(asset, network) {
    try {
      const timestamp = Date.now()
      const endpoint = `/api/v1/deposit-addresses`
      const queryString = `currency=${asset}&network=${network}`
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "GET" + endpoint + "?" + queryString)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}${endpoint}`, {
        params: {
          currency: asset,
          network,
        },
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
        },
      })

      return {
        address: response.data.data.address,
        tag: response.data.data.memo,
      }
    } catch (error) {
      throw new Error(`Error obteniendo dirección de depósito en KuCoin: ${error.message}`)
    }
  }

  // Realizar retiro
  async withdraw(exchangeName, asset, amount, address, network) {
    if (config.BOT.DRY_RUN) {
      // En modo simulación, simular retiro
      const withdrawId = `sim-withdraw-${Date.now()}`
      console.log(`🧪 SIMULACIÓN: Retiro de ${amount} ${asset} desde ${exchangeName} a ${address} (ID: ${withdrawId})`)
      return { withdrawId }
    }

    if (exchangeName === "BINANCE") {
      return this.binanceWithdraw(asset, amount, address, network)
    } else if (exchangeName === "KUCOIN") {
      return this.kucoinWithdraw(asset, amount, address, network)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Realizar retiro en Binance
  async binanceWithdraw(asset, amount, address, network) {
    try {
      const timestamp = Date.now()
      const queryString = `coin=${asset}&address=${address}&amount=${amount}&network=${network}&timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.post(`${this.exchanges.BINANCE.baseURL}/sapi/v1/capital/withdraw/apply`, null, {
        params: {
          coin: asset,
          address,
          amount,
          network,
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        withdrawId: response.data.id,
      }
    } catch (error) {
      throw new Error(`Error realizando retiro en Binance: ${error.message}`)
    }
  }

  // Realizar retiro en KuCoin
  async kucoinWithdraw(asset, amount, address, network) {
    try {
      const timestamp = Date.now()
      const data = {
        currency: asset,
        address,
        amount: amount.toString(),
        network,
      }

      const dataString = JSON.stringify(data)
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "POST" + "/api/v1/withdrawals" + dataString)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.post(`${this.exchanges.KUCOIN.baseURL}/api/v1/withdrawals`, data, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
          "Content-Type": "application/json",
        },
      })

      return {
        withdrawId: response.data.data.withdrawalId,
      }
    } catch (error) {
      throw new Error(`Error realizando retiro en KuCoin: ${error.message}`)
    }
  }

  // Obtener order book
  async getOrderBook(exchangeName, symbol) {
    if (exchangeName === "BINANCE") {
      return this.getBinanceOrderBook(symbol)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinOrderBook(symbol)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener order book en Binance
  async getBinanceOrderBook(symbol) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/depth`, {
        params: {
          symbol: formattedSymbol,
          limit: 20,
        },
      })

      return {
        bids: response.data.bids.map((bid) => [Number.parseFloat(bid[0]), Number.parseFloat(bid[1])]),
        asks: response.data.asks.map((ask) => [Number.parseFloat(ask[0]), Number.parseFloat(ask[1])]),
      }
    } catch (error) {
      throw new Error(`Error obteniendo order book en Binance: ${error.message}`)
    }
  }

  // Obtener order book en KuCoin
  async getKucoinOrderBook(symbol) {
    try {
      // Convertir formato de símbolo (POL/USDT -> POL-USDT)
      const formattedSymbol = symbol.replace("/", "-")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}/api/v1/market/orderbook/level2_20`, {
        params: {
          symbol: formattedSymbol,
        },
      })

      return {
        bids: response.data.data.bids.map((bid) => [Number.parseFloat(bid[0]), Number.parseFloat(bid[1])]),
        asks: response.data.data.asks.map((ask) => [Number.parseFloat(ask[0]), Number.parseFloat(ask[1])]),
      }
    } catch (error) {
      throw new Error(`Error obteniendo order book en KuCoin: ${error.message}`)
    }
  }

  // Método auxiliar para generar precios simulados
  getSimulatedPrice(symbol) {
    // Precios base simulados
    const basePrices = {
      "POL/USDT": 0.45,
      "USDC/USDT": 1.0001,
    }

    const basePrice = basePrices[symbol] || 1.0
    // Agregar variación aleatoria del ±0.1%
    const variation = (Math.random() - 0.5) * 0.002
    return basePrice * (1 + variation)
  }
}

module.exports = ExchangeManager
---------------------------------------------------------------------------------------------------------------

const ccxt = require("ccxt")

/**
 * Fetcher de precios reales para Binance y Bybit
 */
class RealPriceFetcher {
  constructor(config) {
    this.config = config
    this.exchanges = {}
    this.lastPrices = {}
    this.isInitialized = false

    this.logger = console
  }

  /**
   * Inicializa las conexiones a los exchanges
   */
  async initialize() {
    try {
      this.logger.info("🔄 Inicializando conexiones a exchanges...")

      // Configurar Binance
if (this.config.EXCHANGES.BINANCE.enabled) {
   this.exchanges.binance = new ccxt.binance({
    apiKey: this.config.EXCHANGES.BINANCE.apiKey,
    secret: this.config.EXCHANGES.BINANCE.apiSecret,
    sandbox: this.config.EXCHANGES.BINANCE.sandbox,
    enableRateLimit: true,
    rateLimit: this.config.EXCHANGES.BINANCE.rateLimit,
  });

  await this.exchanges.binance.loadMarkets();
  this.logger.info("✅ Binance conectado");
}

      // Configurar Bybit (NUEVO - reemplaza Kucoin)
      if (this.config.EXCHANGES.BYBIT.enabled) {
        this.exchanges.bybit = new ccxt.bybit({
          apiKey: this.config.EXCHANGES.BYBIT.apiKey,
          secret: this.config.EXCHANGES.BYBIT.apiSecret,
          sandbox: this.config.EXCHANGES.BYBIT.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.BYBIT.rateLimit,
        })

        await this.exchanges.bybit.loadMarkets()
        this.logger.info("✅ Bybit conectado")
      }

      this.isInitialized = true
      this.logger.info("🎉 RealPriceFetcher inicializado correctamente")
    } catch (error) {
      this.logger.error("❌ Error inicializando RealPriceFetcher:", error.message)
      throw error
    }
  }

  /**
   * Obtiene precios reales de todos los exchanges para un par específico
   */
  async fetchPricesForPair(pair) {
    if (!this.isInitialized) {
      throw new Error("RealPriceFetcher no está inicializado")
    }

    const prices = {}

    for (const [exchangeName, exchange] of Object.entries(this.exchanges)) {
      try {
        // Verificar si el par está disponible
        if (!exchange.markets[pair]) {
          this.logger.warn(`⚠️  Par ${pair} no disponible en ${exchangeName}`)
          continue
        }

        // Obtener ticker
        const ticker = await exchange.fetchTicker(pair)

        prices[exchangeName] = {
          price: ticker.last,
          bid: ticker.bid,
          ask: ticker.ask,
          volume: ticker.baseVolume,
          timestamp: ticker.timestamp,
          lastUpdate: Date.now(),
        }

        this.logger.debug(`📊 ${exchangeName}: ${pair} = $${ticker.last?.toFixed(4)}`)
      } catch (error) {
        this.logger.error(`❌ Error obteniendo precio de ${pair} en ${exchangeName}:`, error.message)
      }
    }

    // Guardar en caché
    this.lastPrices[pair] = prices

    return prices
  }

  /**
   * Obtiene precios de todos los pares configurados
   */
  async fetchAllPrices() {
    const allPrices = {}

    for (const pair of this.config.TRADING_PAIRS) {
      try {
        allPrices[pair] = await this.fetchPricesForPair(pair)

        // Pequeña pausa para evitar rate limits
        await new Promise((resolve) => setTimeout(resolve, 100))
      } catch (error) {
        this.logger.error(`❌ Error obteniendo precios para ${pair}:`, error.message)
      }
    }

    return allPrices
  }

  /**
   * Calcula oportunidades de arbitraje
   */
  calculateArbitrageOpportunities(prices) {
    const opportunities = {}

    for (const [pair, exchangePrices] of Object.entries(prices)) {
      const exchanges = Object.keys(exchangePrices)

      if (exchanges.length < 2) {
        continue
      }

      let bestBuy = null
      let bestSell = null
      let lowestAsk = Number.POSITIVE_INFINITY
      let highestBid = 0

      // Encontrar mejor compra (menor ask) y mejor venta (mayor bid)
      for (const [exchangeName, priceData] of Object.entries(exchangePrices)) {
        if (priceData.ask && priceData.ask < lowestAsk) {
          lowestAsk = priceData.ask
          bestBuy = { exchange: exchangeName, price: priceData.ask }
        }

        if (priceData.bid && priceData.bid > highestBid) {
          highestBid = priceData.bid
          bestSell = { exchange: exchangeName, price: priceData.bid }
        }
      }

      if (bestBuy && bestSell && bestBuy.exchange !== bestSell.exchange) {
        const profitPercentage = ((bestSell.price - bestBuy.price) / bestBuy.price) * 100

        opportunities[pair] = {
          exchanges: exchangePrices,
          bestBuy,
          bestSell,
          profitPercentage,
          isOpportunity: profitPercentage >= this.config.STRATEGIES.BASIC.minProfitPercentage,
          minProfitThreshold: this.config.STRATEGIES.BASIC.minProfitPercentage,
        }
      }
    }

    return opportunities
  }

  /**
   * Obtiene los últimos precios del caché
   */
  getLastPrices() {
    return this.lastPrices
  }

  /**
   * Verifica el estado de las conexiones
   */
  async checkConnections() {
    const status = {}

    for (const [exchangeName, exchange] of Object.entries(this.exchanges)) {
      try {
        const exchangeStatus = await exchange.fetchStatus()
        status[exchangeName] = {
          connected: true,
          status: exchangeStatus.status || "active",
          updated: exchangeStatus.updated,
        }
      } catch (error) {
        status[exchangeName] = {
          connected: false,
          error: error.message,
        }
      }
    }

    return status
  }
}

module.exports = RealPriceFetcher

--------------------------------------------------------------------------------------------------------------

MOBILE

// Versión simplificada sin dependencias
class MobileAPI {
  constructor(config) {
    this.enabled = false;
    console.log('📱 Mobile API disabled (firebase-admin no instalado)');
  }
  
  start() {
    // No hacer nada
    return;
  }
  
  stop() {
    // No hacer nada
    return;
  }
  
  sendNotification() {
    // No hacer nada
    return;
  }
}

module.exports = MobileAPI;

-----------------------------------------------------------------------------------------------------------

const express = require('express');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const admin = require('firebase-admin');

/**
 * API Móvil para el Bot de Arbitraje
 * Proporciona endpoints para la aplicación móvil
 */
class MobileAPI {
    constructor(config) {
        this.config = config;
        this.enabled = config.MOBILE_API.ENABLED;
        this.port = config.MOBILE_API.PORT;
        this.jwtSecret = config.MOBILE_API.JWT_SECRET;
        this.jwtExpiry = config.MOBILE_API.JWT_EXPIRY;
        this.rateLimitConfig = config.MOBILE_API.RATE_LIMIT;
        this.corsConfig = config.MOBILE_API.CORS;
        this.endpoints = config.MOBILE_API.ENDPOINTS;
        this.pushNotifications = config.MOBILE_API.PUSH_NOTIFICATIONS;
        
        this.app = express();
        this.server = null;
        this.bot = null;
        this.authenticatedUsers = new Map();
        
        this.logger = console;
    }
    
    /**
     * Inicializa la API móvil
     */
    async initialize() {
        if (!this.enabled) {
            this.logger.info('Mobile API deshabilitada');
            return;
        }
        
        this.logger.info('Inicializando Mobile API...');
        
        try {
            // Configurar middleware
            this.setupMiddleware();
            
            // Configurar rutas
            this.setupRoutes();
            
            // Inicializar Firebase para notificaciones push
            if (this.pushNotifications.enabled) {
                await this.initializeFirebase();
            }
            
            // Iniciar servidor
            await this.startServer();
            
            this.logger.info(`Mobile API inicializada en puerto ${this.port}`);
        } catch (error) {
            this.logger.error('Error inicializando Mobile API:', error);
            throw error;
        }
    }
    
    /**
     * Configura el middleware de Express
     */
    setupMiddleware() {
        // CORS
        this.app.use(cors(this.corsConfig));
        
        // Rate limiting
        const limiter = rateLimit(this.rateLimitConfig);
        this.app.use(limiter);
        
        // Body parser
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true }));
        
        // Logging middleware
        this.app.use((req, res, next) => {
            this.logger.info(`${req.method} ${req.path} - ${req.ip}`);
            next();
        });
        
        // Error handling middleware
        this.app.use((error, req, res, next) => {
            this.logger.error('API Error:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        });
    }
    
    /**
     * Configura las rutas de la API
     */
    setupRoutes() {
        // Ruta de autenticación
        this.app.post('/api/mobile/auth/login', this.handleLogin.bind(this));
        this.app.post('/api/mobile/auth/logout', this.authenticateToken.bind(this), this.handleLogout.bind(this));
        this.app.post('/api/mobile/auth/refresh', this.handleRefreshToken.bind(this));
        
        // Rutas protegidas
        this.app.use('/api/mobile/*', this.authenticateToken.bind(this));
        
        // Estado del bot
        this.app.get(this.endpoints.STATUS, this.handleGetStatus.bind(this));
        
        // Operaciones
        this.app.get(this.endpoints.TRADES, this.handleGetTrades.bind(this));
        this.app.get('/api/mobile/trades/:id', this.handleGetTradeDetails.bind(this));
        
        // Portfolio
        this.app.get(this.endpoints.PORTFOLIO, this.handleGetPortfolio.bind(this));
        this.app.get('/api/mobile/portfolio/history', this.handleGetPortfolioHistory.bind(this));
        
        // Alertas
        this.app.get(this.endpoints.ALERTS, this.handleGetAlerts.bind(this));
        this.app.post('/api/mobile/alerts/mark-read', this.handleMarkAlertsRead.bind(this));
        
        // Configuración
        this.app.get(this.endpoints.SETTINGS, this.handleGetSettings.bind(this));
        this.app.put(this.endpoints.SETTINGS, this.handleUpdateSettings.bind(this));
        
        // Control del bot
        this.app.post('/api/mobile/bot/start', this.handleStartBot.bind(this));
        this.app.post('/api/mobile/bot/stop', this.handleStopBot.bind(this));
        this.app.post('/api/mobile/bot/strategy', this.handleChangeStrategy.bind(this));
        
        // Estadísticas
        this.app.get('/api/mobile/stats/summary', this.handleGetStatsSummary.bind(this));
        this.app.get('/api/mobile/stats/performance', this.handleGetPerformanceStats.bind(this));
        
        // Notificaciones push
        this.app.post('/api/mobile/notifications/register', this.handleRegisterDevice.bind(this));
        this.app.post('/api/mobile/notifications/unregister', this.handleUnregisterDevice.bind(this));
        
        // Health check
        this.app.get('/api/mobile/health', (req, res) => {
            res.json({ status: 'ok', timestamp: new Date().toISOString() });
        });
    }
    
    /**
     * Inicializa Firebase para notificaciones push
     */
    async initializeFirebase() {
        try {
            if (!this.pushNotifications.fcmServerKey) {
                throw new Error('FCM Server Key no configurado');
            }
            
            // En una implementación real, aquí inicializaríamos Firebase Admin SDK
            this.logger.info('Firebase inicializado para notificaciones push');
        } catch (error) {
            this.logger.error('Error inicializando Firebase:', error);
            this.pushNotifications.enabled = false;
        }
    }
    
    /**
     * Inicia el servidor
     */
    async startServer() {
        return new Promise((resolve, reject) => {
            this.server = this.app.listen(this.port, (error) => {
                if (error) {
                    reject(error);
                } else {
                    resolve();
                }
            });
        });
    }
    
    /**
     * Middleware de autenticación
     */
    authenticateToken(req, res, next) {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];
        
        if (!token) {
            return res.status(401).json({
                success: false,
                error: 'Token de acceso requerido'
            });
        }
        
        jwt.verify(token, this.jwtSecret, (error, user) => {
            if (error) {
                return res.status(403).json({
                    success: false,
                    error: 'Token inválido'
                });
            }
            
            req.user = user;
            next();
        });
    }
    
    /**
     * Maneja el login
     */
    async handleLogin(req, res) {
        try {
            const { username, password } = req.body;
            
            // En una implementación real, aquí verificaríamos las credenciales
            // Para esta implementación, usaremos credenciales hardcodeadas
            if (username === 'admin' && password === 'admin123') {
                const user = {
                    id: 1,
                    username: 'admin',
                    role: 'admin'
                };
                
                const token = jwt.sign(user, this.jwtSecret, { expiresIn: this.jwtExpiry });
                const refreshToken = jwt.sign(user, this.jwtSecret + '_refresh', { expiresIn: '7d' });
                
                // Guardar usuario autenticado
                this.authenticatedUsers.set(user.id, {
                    ...user,
                    token,
                    refreshToken,
                    loginTime: new Date()
                });
                
                res.json({
                    success: true,
                    data: {
                        user,
                        token,
                        refreshToken
                    }
                });
            } else {
                res.status(401).json({
                    success: false,
                    error: 'Credenciales inválidas'
                });
            }
        } catch (error) {
            this.logger.error('Error en login:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Maneja el logout
     */
    async handleLogout(req, res) {
        try {
            const userId = req.user.id;
            
            // Remover usuario autenticado
            this.authenticatedUsers.delete(userId);
            
            res.json({
                success: true,
                message: 'Logout exitoso'
            });
        } catch (error) {
            this.logger.error('Error en logout:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Maneja la renovación de token
     */
    async handleRefreshToken(req, res) {
        try {
            const { refreshToken } = req.body;
            
            if (!refreshToken) {
                return res.status(401).json({
                    success: false,
                    error: 'Refresh token requerido'
                });
            }
            
            jwt.verify(refreshToken, this.jwtSecret + '_refresh', (error, user) => {
                if (error) {
                    return res.status(403).json({
                        success: false,
                        error: 'Refresh token inválido'
                    });
                }
                
                const newToken = jwt.sign(
                    { id: user.id, username: user.username, role: user.role },
                    this.jwtSecret,
                    { expiresIn: this.jwtExpiry }
                );
                
                res.json({
                    success: true,
                    data: { token: newToken }
                });
            });
        } catch (error) {
            this.logger.error('Error renovando token:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene el estado del bot
     */
    async handleGetStatus(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const status = this.bot.getStatus();
            const riskAnalysis = this.bot.getRiskAnalysis();
            
            res.json({
                success: true,
                data: {
                    ...status,
                    riskAnalysis
                }
            });
        } catch (error) {
            this.logger.error('Error obteniendo estado:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene las operaciones
     */
    async handleGetTrades(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { page = 1, limit = 20, type, status } = req.query;
            const offset = (page - 1) * limit;
            
            let trades = this.bot.getTradeHistory();
            
            // Filtrar por tipo si se especifica
            if (type) {
                trades = trades.filter(trade => trade.type === type);
            }
            
            // Filtrar por estado si se especifica
            if (status) {
                trades = trades.filter(trade => 
                    status === 'success' ? trade.success : !trade.success
                );
            }
            
            // Paginar
            const total = trades.length;
            const paginatedTrades = trades.slice(offset, offset + parseInt(limit));
            
            res.json({
                success: true,
                data: {
                    trades: paginatedTrades,
                    pagination: {
                        page: parseInt(page),
                        limit: parseInt(limit),
                        total,
                        pages: Math.ceil(total / limit)
                    }
                }
            });
        } catch (error) {
            this.logger.error('Error obteniendo operaciones:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene detalles de una operación específica
     */
    async handleGetTradeDetails(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { id } = req.params;
            const trades = this.bot.getTradeHistory();
            const trade = trades.find(t => t.id === id);
            
            if (!trade) {
                return res.status(404).json({
                    success: false,
                    error: 'Operación no encontrada'
                });
            }
            
            res.json({
                success: true,
                data: trade
            });
        } catch (error) {
            this.logger.error('Error obteniendo detalles de operación:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene información del portfolio
     */
    async handleGetPortfolio(req, res) {
        try {
            // En una implementación real, obtendríamos datos del portfolio manager
            const portfolioData = {
                totalValue: 10500.75,
                totalProfit: 500.75,
                totalProfitPercentage: 5.01,
                balances: {
                    'Binance': 2625.19,
                    'Coinbase': 2631.25,
                    'Kraken': 2622.15,
                    'Kucoin': 2622.16
                },
                allocation: {
                    'Binance': 25.0,
                    'Coinbase': 25.1,
                    'Kraken': 24.9,
                    'Kucoin': 25.0
                },
                lastUpdate: new Date().toISOString()
            };
            
            res.json({
                success: true,
                data: portfolioData
            });
        } catch (error) {
            this.logger.error('Error obteniendo portfolio:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene historial del portfolio
     */
    async handleGetPortfolioHistory(req, res) {
        try {
            const { period = '7d' } = req.query;
            
            // Simular datos históricos
            const history = [];
            const now = new Date();
            let days;
            
            switch (period) {
                case '1d':
                    days = 1;
                    break;
                case '7d':
                    days = 7;
                    break;
                case '30d':
                    days = 30;
                    break;
                default:
                    days = 7;
            }
            
            for (let i = days; i >= 0; i--) {
                const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
                history.push({
                    timestamp: date.toISOString(),
                    value: 10000 + Math.random() * 1000,
                    profit: Math.random() * 100 - 50
                });
            }
            
            res.json({
                success: true,
                data: history
            });
        } catch (error) {
            this.logger.error('Error obteniendo historial de portfolio:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene alertas
     */
    async handleGetAlerts(req, res) {
        try {
            // En una implementación real, obtendríamos alertas del alert manager
            const alerts = [
                {
                    id: 'alert_1',
                    type: 'trade_executed',
                    message: 'Arbitraje ejecutado: BTC/USDT - Ganancia: 0.5%',
                    timestamp: new Date().toISOString(),
                    priority: 'medium',
                    read: false
                },
                {
                    id: 'alert_2',
                    type: 'risk_warning',
                    message: 'Volatilidad alta detectada en el mercado',
                    timestamp: new Date(Date.now() - 3600000).toISOString(),
                    priority: 'high',
                    read: true
                }
            ];
            
            res.json({
                success: true,
                data: alerts
            });
        } catch (error) {
            this.logger.error('Error obteniendo alertas:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Marca alertas como leídas
     */
    async handleMarkAlertsRead(req, res) {
        try {
            const { alertIds } = req.body;
            
            // En una implementación real, marcaríamos las alertas como leídas
            this.logger.info(`Marcando alertas como leídas: ${alertIds.join(', ')}`);
            
            res.json({
                success: true,
                message: 'Alertas marcadas como leídas'
            });
        } catch (error) {
            this.logger.error('Error marcando alertas como leídas:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene configuración
     */
    async handleGetSettings(req, res) {
        try {
            const settings = {
                riskLevel: 'medium',
                maxExposure: 20,
                strategies: ['basic', 'triangular'],
                notifications: {
                    trades: true,
                    alerts: true,
                    dailySummary: false
                },
                autoRebalance: true
            };
            
            res.json({
                success: true,
                data: settings
            });
        } catch (error) {
            this.logger.error('Error obteniendo configuración:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Actualiza configuración
     */
    async handleUpdateSettings(req, res) {
        try {
            const settings = req.body;
            
            // En una implementación real, actualizaríamos la configuración del bot
            this.logger.info('Actualizando configuración:', settings);
            
            res.json({
                success: true,
                message: 'Configuración actualizada correctamente'
            });
        } catch (error) {
            this.logger.error('Error actualizando configuración:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Inicia el bot
     */
    async handleStartBot(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { mode = 'simulation' } = req.body;
            
            await this.bot.start(mode);
            
            // Enviar notificación push
            if (this.pushNotifications.enabled) {
                await this.sendPushNotification(req.user.id, {
                    title: 'Bot Iniciado',
                    body: `Bot iniciado en modo ${mode}`,
                    data: { type: 'bot_started', mode }
                });
            }
            
            res.json({
                success: true,
                message: 'Bot iniciado correctamente'
            });
        } catch (error) {
            this.logger.error('Error iniciando bot:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    /**
     * Detiene el bot
     */
    async handleStopBot(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            await this.bot.stop();
            
            // Enviar notificación push
            if (this.pushNotifications.enabled) {
                await this.sendPushNotification(req.user.id, {
                    title: 'Bot Detenido',
                    body: 'Bot detenido correctamente',
                    data: { type: 'bot_stopped' }
                });
            }
            
            res.json({
                success: true,
                message: 'Bot detenido correctamente'
            });
        } catch (error) {
            this.logger.error('Error deteniendo bot:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    /**
     * Cambia la estrategia del bot
     */
    async handleChangeStrategy(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { strategy } = req.body;
            
            this.bot.changeStrategy(strategy);
            
            res.json({
                success: true,
                message: `Estrategia cambiada a ${strategy}`
            });
        } catch (error) {
            this.logger.error('Error cambiando estrategia:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    /**
     * Obtiene resumen de estadísticas
     */
    async handleGetStatsSummary(req, res) {
        try {
            const stats = {
                totalTrades: 156,
                successfulTrades: 142,
                failedTrades: 14,
                winRate: 91.03,
                totalProfit: 1250.75,
                averageProfit: 8.79,
                bestTrade: 45.20,
                worstTrade: -12.30,
                sharpeRatio: 1.85,
                maxDrawdown: 3.2
            };
            
            res.json({
                success: true,
                data: stats
            });
        } catch (error) {
            this.logger.error('Error obteniendo estadísticas:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene estadísticas de rendimiento
     */
    async handleGetPerformanceStats(req, res) {
        try {
            const { period = '30d' } = req.query;
            
            // Simular datos de rendimiento
            const performance = {
                period,
                totalReturn: 12.5,
                annualizedReturn: 156.2,
                volatility: 8.3,
                sharpeRatio: 1.85,
                maxDrawdown: 3.2,
                calmarRatio: 48.8,
                winRate: 91.03,
                profitFactor: 6.45,
                averageTrade: 8.79,
                tradesPerDay: 5.2
            };
            
            res.json({
                success: true,
                data: performance
            });
        } catch (error) {
            this.logger.error('Error obteniendo estadísticas de rendimiento:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Registra dispositivo para notificaciones push
     */
    async handleRegisterDevice(req, res) {
        try {
            const { deviceToken, platform } = req.body;
            const userId = req.user.id;
            
            // En una implementación real, guardaríamos el token del dispositivo
            this.logger.info(`Registrando dispositivo para usuario ${userId}: ${platform}`);
            
            res.json({
                success: true,
                message: 'Dispositivo registrado para notificaciones'
            });
        } catch (error) {
            this.logger.error('Error registrando dispositivo:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Desregistra dispositivo para notificaciones push
     */
    async handleUnregisterDevice(req, res) {
        try {
            const { deviceToken } = req.body;
            const userId = req.user.id;
            
            // En una implementación real, removeríamos el token del dispositivo
            this.logger.info(`Desregistrando dispositivo para usuario ${userId}`);
            
            res.json({
                success: true,
                message: 'Dispositivo desregistrado de notificaciones'
            });
        } catch (error) {
            this.logger.error('Error desregistrando dispositivo:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Envía notificación push a un usuario
     * @param {number} userId - ID del usuario
     * @param {Object} notification - Datos de la notificación
     */
    async sendPushNotification(userId, notification) {
        try {
            if (!this.pushNotifications.enabled) {
                return;
            }
            
            // En una implementación real, enviaríamos la notificación usando Firebase
            this.logger.info(`Enviando notificación push a usuario ${userId}:`, notification);
        } catch (error) {
            this.logger.error('Error enviando notificación push:', error);
        }
    }
    
    /**
     * Establece la referencia al bot
     * @param {Object} bot - Instancia del bot
     */
    setBot(bot) {
        this.bot = bot;
    }
    
    /**
     * Detiene la API móvil
     */
    async stop() {
        if (this.server) {
            return new Promise((resolve) => {
                this.server.close(() => {
                    this.logger.info('Mobile API detenida');
                    resolve();
                });
            });
        }
    }
}

module.exports = MobileAPI;

----------------------------------------------------------------------------------------------------------------

PORTAFOLIO

const EventEmitter = require('events');

/**
 * Gestor de Portfolio
 * Maneja la distribución y rebalanceo de fondos entre exchanges
 */
class PortfolioManager extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.initialBalance = config.PORTFOLIO.INITIAL_BALANCE;
        this.rebalanceFrequency = config.PORTFOLIO.REBALANCE_FREQUENCY;
        this.targetAllocation = config.PORTFOLIO.TARGET_ALLOCATION;
        this.minBalancePerExchange = config.PORTFOLIO.MIN_BALANCE_PER_EXCHANGE;
        this.reservePercentage = config.PORTFOLIO.RESERVE_PERCENTAGE;
        this.autoCompound = config.PORTFOLIO.AUTO_COMPOUND;
        this.compoundThreshold = config.PORTFOLIO.COMPOUND_THRESHOLD;
        
        this.currentBalances = {};
        this.balanceHistory = [];
        this.allocationHistory = [];
        this.rebalanceHistory = [];
        this.totalValue = 0;
        this.totalProfit = 0;
        this.totalProfitPercentage = 0;
        this.lastRebalance = null;
        this.rebalanceInterval = null;
        
        this.logger = console;

        // ======= AGREGADO DASHBOARD =======
        this._autoRebalanceEnabled = false; // Estado del auto rebalanceo
        // ======= FIN AGREGADO DASHBOARD =======
    }
    
    /**
     * Inicializa el gestor de portfolio
     * @param {Object} initialBalances - Balances iniciales por exchange
     */
    async initialize(initialBalances = {}) {
        this.logger.info('Inicializando Portfolio Manager...');
        
        try {
            // Establecer balances iniciales
            this.currentBalances = { ...initialBalances };
            
            // Si no hay balances iniciales, distribuir el balance inicial
            if (Object.keys(this.currentBalances).length === 0) {
                await this.distributeInitialBalance();
            }
            
            // Calcular valor total inicial
            this.calculateTotalValue();
            
            // Registrar estado inicial
            this.recordBalanceSnapshot();
            this.recordAllocationSnapshot();
            
            // Programar rebalanceo automático
            if (this.rebalanceFrequency > 0) {
                this.scheduleAutoRebalance();
            }
            
            this.logger.info('Portfolio Manager inicializado correctamente');
            this.logger.info(`Valor total del portfolio: $${this.totalValue.toFixed(2)}`);
        } catch (error) {
            this.logger.error('Error inicializando Portfolio Manager:', error);
            throw error;
        }
    }
    
    /**
     * Distribuye el balance inicial según la asignación objetivo
     */
    async distributeInitialBalance() {
        const exchanges = Object.keys(this.targetAllocation);
        const balancePerExchange = this.initialBalance / exchanges.length;
        
        for (const exchange of exchanges) {
            const targetPercentage = this.targetAllocation[exchange];
            this.currentBalances[exchange] = this.initialBalance * targetPercentage;
        }
        
        this.logger.info('Balance inicial distribuido entre exchanges');
    }
    
    /**
     * Calcula el valor total del portfolio
     */
    calculateTotalValue() {
        this.totalValue = Object.values(this.currentBalances).reduce((sum, balance) => sum + balance, 0);
        this.totalProfit = this.totalValue - this.initialBalance;
        this.totalProfitPercentage = ((this.totalProfit / this.initialBalance) * 100);
    }
    
    /**
     * Registra un snapshot del balance actual
     */
    recordBalanceSnapshot() {
        this.balanceHistory.push({
            timestamp: new Date(),
            balances: { ...this.currentBalances },
            totalValue: this.totalValue,
            totalProfit: this.totalProfit,
            totalProfitPercentage: this.totalProfitPercentage
        });
        
        // Mantener solo los últimos 1000 registros
        if (this.balanceHistory.length > 1000) {
            this.balanceHistory.shift();
        }
    }
    
    /**
     * Registra un snapshot de la asignación actual
     */
    recordAllocationSnapshot() {
        const allocation = {};
        
        for (const exchange in this.currentBalances) {
            allocation[exchange] = (this.currentBalances[exchange] / this.totalValue) * 100;
        }
        
        this.allocationHistory.push({
            timestamp: new Date(),
            allocation,
            totalValue: this.totalValue
        });
        
        // Mantener solo los últimos 500 registros
        if (this.allocationHistory.length > 500) {
            this.allocationHistory.shift();
        }
    }
    
    /**
     * Programa el rebalanceo automático
     */
    scheduleAutoRebalance() {
        this._autoRebalanceEnabled = true; // AGREGADO DASHBOARD: marcar como habilitado
        this.rebalanceInterval = setInterval(async () => {
            try {
                await this.checkAndRebalance();
            } catch (error) {
                this.logger.error('Error en rebalanceo automático:', error);
            }
        }, this.rebalanceFrequency);
    }
    
    /**
     * Actualiza los balances del portfolio
     * @param {Object} newBalances - Nuevos balances por exchange
     */
    async updateBalances(newBalances) {
        // Actualizar balances
        this.currentBalances = { ...newBalances };
        
        // Recalcular valor total
        this.calculateTotalValue();
        
        // Registrar snapshot
        this.recordBalanceSnapshot();
        this.recordAllocationSnapshot();
        
        // Verificar si se necesita rebalanceo
        if (await this.shouldRebalance()) {
            this.emit('rebalanceNeeded', {
                balances: this.currentBalances,
                reason: 'Desviación de asignación objetivo'
            });
        }
        
        // Verificar si se debe reinvertir ganancias
        if (this.autoCompound && this.totalProfit >= this.compoundThreshold) {
            await this.compoundProfits();
        }
    }
    
    /**
     * Verifica si se necesita rebalanceo
     * @returns {boolean} - True si se necesita rebalanceo
     */
    async shouldRebalance() {
        const currentAllocation = this.getCurrentAllocation();
        const rebalanceThreshold = this.config.RISK_MANAGEMENT.REBALANCE_THRESHOLD || 0.15;
        
        for (const exchange in this.targetAllocation) {
            const targetPercentage = this.targetAllocation[exchange];
            const currentPercentage = currentAllocation[exchange] || 0;
            const deviation = Math.abs(targetPercentage - currentPercentage);
            
            if (deviation > rebalanceThreshold) {
                this.logger.info(`Rebalanceo necesario: ${exchange} - Objetivo: ${targetPercentage}%, Actual: ${currentPercentage.toFixed(2)}%`);
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Obtiene la asignación actual del portfolio
     * @returns {Object} - Asignación actual por exchange
     */
    getCurrentAllocation() {
        const allocation = {};
        
        for (const exchange in this.currentBalances) {
            allocation[exchange] = (this.currentBalances[exchange] / this.totalValue) * 100;
        }
        
        return allocation;
    }
    
    /**
     * Verifica y ejecuta rebalanceo si es necesario
     */
    async checkAndRebalance() {
        if (await this.shouldRebalance()) {
            await this.rebalancePortfolio();
        }
    }
    
    /**
     * Ejecuta el rebalanceo del portfolio
     */
    async rebalancePortfolio() {
        this.logger.info('Iniciando rebalanceo del portfolio...');
        
        try {
            const rebalanceId = this.generateRebalanceId();
            const startTime = new Date();
            const initialBalances = { ...this.currentBalances };
            
            // Calcular nuevos balances objetivo
            const targetBalances = this.calculateTargetBalances();
            
            // Calcular transferencias necesarias
            const transfers = this.calculateRequiredTransfers(targetBalances);
            
            // Ejecutar transferencias (simulado)
            const executedTransfers = await this.executeTransfers(transfers);
            
            // Actualizar balances
            this.applyTransfers(executedTransfers);
            
            // Registrar rebalanceo
            const rebalanceRecord = {
                id: rebalanceId,
                timestamp: startTime,
                endTime: new Date(),
                initialBalances,
                finalBalances: { ...this.currentBalances },
                targetBalances,
                transfers: executedTransfers,
                totalTransferred: executedTransfers.reduce((sum, t) => sum + t.amount, 0),
                success: true
            };
            
            this.rebalanceHistory.push(rebalanceRecord);
            this.lastRebalance = startTime;
            
            // Mantener solo los últimos 100 rebalanceos
            if (this.rebalanceHistory.length > 100) {
                this.rebalanceHistory.shift();
            }
            
            // Registrar nuevo estado
            this.calculateTotalValue();
            this.recordBalanceSnapshot();
            this.recordAllocationSnapshot();
            
            this.emit('rebalanceCompleted', rebalanceRecord);
            this.logger.info(`Rebalanceo completado: $${rebalanceRecord.totalTransferred.toFixed(2)} transferidos`);
            
        } catch (error) {
            this.logger.error('Error ejecutando rebalanceo:', error);
            
            // Registrar rebalanceo fallido
            this.rebalanceHistory.push({
                id: this.generateRebalanceId(),
                timestamp: new Date(),
                success: false,
                error: error.message
            });
            
            this.emit('rebalanceError', { error: error.message });
        }
    }

    /**
 * Rebalancea solo una cantidad específica del exchange con más saldo al que tiene menos.
 * @param {number} amount - Cantidad a rebalancear.
 */
async rebalanceSpecificAmount(amount) {
    this.logger.info(`Iniciando rebalanceo MANUAL de cantidad específica: $${amount.toFixed(2)}`);

    // Encuentra el exchange con más saldo y el que tiene menos
    let maxEx = null, minEx = null;
    let maxVal = -Infinity, minVal = Infinity;
    for (const ex in this.currentBalances) {
        if (this.currentBalances[ex] > maxVal) {
            maxEx = ex;
            maxVal = this.currentBalances[ex];
        }
        if (this.currentBalances[ex] < minVal) {
            minEx = ex;
            minVal = this.currentBalances[ex];
        }
    }

    if (!maxEx || !minEx || maxEx === minEx) {
        throw new Error("No es posible rebalancear con los balances actuales.");
    }
    if (this.currentBalances[maxEx] < amount) {
        throw new Error(`El exchange ${maxEx} no tiene suficiente saldo para transferir $${amount}.`);
    }

    // Simula la transferencia (descuenta del origen, suma al destino)
    this.currentBalances[maxEx] -= amount;
    this.currentBalances[minEx] += amount;

    // Registrar el rebalanceo manual
    this.rebalanceHistory.push({
        id: this.generateRebalanceId(),
        timestamp: new Date(),
        manual: true,
        from: maxEx,
        to: minEx,
        amount,
        balancesAfter: { ...this.currentBalances },
        success: true
    });

    this.lastRebalance = new Date();
    this.calculateTotalValue();
    this.recordBalanceSnapshot();
    this.recordAllocationSnapshot();

    this.logger.info(`Rebalanceo manual: $${amount.toFixed(2)} transferidos de ${maxEx} a ${minEx}.`);
    this.emit('rebalanceCompleted', { manual: true, from: maxEx, to: minEx, amount });
}

/**
 * Rebalancea una cantidad específica entre dos exchanges y para un token (si aplica).
 * @param {Object} params - { amount, fromExchange, toExchange, token }
 */
async rebalanceCustom({ amount, fromExchange, toExchange, token = "USDT" }) {
    this.logger.info(`Rebalanceo manual: $${amount} de ${fromExchange} a ${toExchange} para token ${token}`);

    // Si tienes balances por token y exchange, ajusta aquí:
    // this.currentBalances[exchange][token]
    // Si solo por exchange: this.currentBalances[exchange]

    // --- Si balances por exchange y token ---
    if (typeof this.currentBalances[fromExchange] === "object" && token in this.currentBalances[fromExchange]) {
        // Verifica saldo suficiente
        if (this.currentBalances[fromExchange][token] < amount) {
            throw new Error(`El exchange ${fromExchange} no tiene suficiente saldo de ${token} para transferir $${amount}.`);
        }
        // Realiza transferencia
        this.currentBalances[fromExchange][token] -= amount;
        this.currentBalances[toExchange][token] += amount;
    } else {
        // --- Si balances simples por exchange ---
        if (this.currentBalances[fromExchange] < amount) {
            throw new Error(`El exchange ${fromExchange} no tiene suficiente saldo para transferir $${amount}.`);
        }
        this.currentBalances[fromExchange] -= amount;
        this.currentBalances[toExchange] += amount;
    }

    // Registrar rebalanceo
    this.rebalanceHistory.push({
        id: this.generateRebalanceId(),
        timestamp: new Date(),
        manual: true,
        from: fromExchange,
        to: toExchange,
        amount,
        token,
        balancesAfter: JSON.parse(JSON.stringify(this.currentBalances)),
        success: true
    });

    this.lastRebalance = new Date();
    this.calculateTotalValue();
    this.recordBalanceSnapshot();
    this.recordAllocationSnapshot();

    this.logger.info(`Rebalanceo manual: $${amount} ${token} transferidos de ${fromExchange} a ${toExchange}.`);
    this.emit('rebalanceCompleted', { manual: true, from: fromExchange, to: toExchange, amount, token });
}
    
    /**
     * Calcula los balances objetivo según la asignación
     * @returns {Object} - Balances objetivo por exchange
     */
    calculateTargetBalances() {
        const targetBalances = {};
        const availableBalance = this.totalValue * (1 - this.reservePercentage);
        
        for (const exchange in this.targetAllocation) {
            const targetPercentage = this.targetAllocation[exchange];
            targetBalances[exchange] = availableBalance * targetPercentage;
            
            // Asegurar balance mínimo
            if (targetBalances[exchange] < this.minBalancePerExchange) {
                targetBalances[exchange] = this.minBalancePerExchange;
            }
        }
        
        return targetBalances;
    }
    
    /**
     * Calcula las transferencias necesarias para el rebalanceo
     * @param {Object} targetBalances - Balances objetivo
     * @returns {Array} - Lista de transferencias necesarias
     */
    calculateRequiredTransfers(targetBalances) {
        const transfers = [];
        const surplusExchanges = [];
        const deficitExchanges = [];
        
        // Identificar exchanges con exceso y déficit
        for (const exchange in this.currentBalances) {
            const currentBalance = this.currentBalances[exchange];
            const targetBalance = targetBalances[exchange] || 0;
            const difference = currentBalance - targetBalance;
            
            if (difference > 1) { // Margen de $1 para evitar transferencias mínimas
                surplusExchanges.push({
                    exchange,
                    surplus: difference
                });
            } else if (difference < -1) {
                deficitExchanges.push({
                    exchange,
                    deficit: -difference
                });
            }
        }
        
        // Ordenar por cantidad (mayor primero)
        surplusExchanges.sort((a, b) => b.surplus - a.surplus);
        deficitExchanges.sort((a, b) => b.deficit - a.deficit);
        
        // Calcular transferencias
        for (const deficitExchange of deficitExchanges) {
            let remainingDeficit = deficitExchange.deficit;
            
            for (let i = 0; i < surplusExchanges.length && remainingDeficit > 0; i++) {
                const surplusExchange = surplusExchanges[i];
                
                if (surplusExchange.surplus <= 0) continue;
                
                const transferAmount = Math.min(surplusExchange.surplus, remainingDeficit);
                
                if (transferAmount > 1) { // Transferir solo si es mayor a $1
                    transfers.push({
                        from: surplusExchange.exchange,
                        to: deficitExchange.exchange,
                        amount: transferAmount
                    });
                    
                    surplusExchange.surplus -= transferAmount;
                    remainingDeficit -= transferAmount;
                }
            }
        }
        
        return transfers;
    }
    
    /**
     * Ejecuta las transferencias (simulado)
     * @param {Array} transfers - Lista de transferencias
     * @returns {Array} - Transferencias ejecutadas
     */
    async executeTransfers(transfers) {
        const executedTransfers = [];
        
        for (const transfer of transfers) {
            try {
                // Simular latencia de transferencia
                await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                
                // Simular éxito/fallo (98% éxito)
                const success = Math.random() > 0.02;
                
                if (success) {
                    // Simular fee de transferencia (0.1%)
                    const fee = transfer.amount * 0.001;
                    const netAmount = transfer.amount - fee;
                    
                    executedTransfers.push({
                        ...transfer,
                        netAmount,
                        fee,
                        success: true,
                        timestamp: new Date()
                    });
                    
                    this.logger.info(`Transferencia ejecutada: $${transfer.amount.toFixed(2)} de ${transfer.from} a ${transfer.to}`);
                } else {
                    throw new Error('Transferencia fallida');
                }
            } catch (error) {
                this.logger.error(`Error en transferencia de ${transfer.from} a ${transfer.to}:`, error);
                
                executedTransfers.push({
                    ...transfer,
                    success: false,
                    error: error.message,
                    timestamp: new Date()
                });
            }
        }
        
        return executedTransfers;
    }
    
    /**
     * Aplica las transferencias a los balances
     * @param {Array} transfers - Transferencias ejecutadas
     */
    applyTransfers(transfers) {
        for (const transfer of transfers) {
            if (transfer.success) {
                // Restar del exchange origen
                this.currentBalances[transfer.from] -= transfer.amount;
                
                // Sumar al exchange destino (menos fee)
                this.currentBalances[transfer.to] += transfer.netAmount;
            }
        }
    }
    
    /**
     * Reinvierte las ganancias en el portfolio
     */
    async compoundProfits() {
        if (this.totalProfit < this.compoundThreshold) {
            return;
        }
        
        this.logger.info(`Reinvirtiendo ganancias: $${this.totalProfit.toFixed(2)}`);
        
        try {
            // Distribuir ganancias según asignación objetivo
            for (const exchange in this.targetAllocation) {
                const allocationPercentage = this.targetAllocation[exchange];
                const additionalAmount = this.totalProfit * allocationPercentage;
                
                this.currentBalances[exchange] += additionalAmount;
            }
            
            // Actualizar balance inicial para reflejar la reinversión
            this.initialBalance = this.totalValue;
            
            // Recalcular métricas
            this.calculateTotalValue();
            this.recordBalanceSnapshot();
            this.recordAllocationSnapshot();
            
            this.emit('profitsCompounded', {
                amount: this.totalProfit,
                newInitialBalance: this.initialBalance
            });
            
            this.logger.info('Ganancias reinvertidas correctamente');
        } catch (error) {
            this.logger.error('Error reinvirtiendo ganancias:', error);
        }
    }
    
    /**
     * Genera un ID único para el rebalanceo
     * @returns {string} - ID del rebalanceo
     */
    generateRebalanceId() {
        return `rebalance_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Obtiene el estado actual del portfolio
     * @returns {Object} - Estado del portfolio
     */
    getPortfolioStatus() {
        return {
            totalValue: this.totalValue,
            totalProfit: this.totalProfit,
            totalProfitPercentage: this.totalProfitPercentage,
            currentBalances: { ...this.currentBalances },
            currentAllocation: this.getCurrentAllocation(),
            targetAllocation: { ...this.targetAllocation },
            lastRebalance: this.lastRebalance,
            nextRebalanceCheck: this.lastRebalance ? 
                new Date(this.lastRebalance.getTime() + this.rebalanceFrequency) : 
                new Date()
        };
    }

    // ======= AGREGADO DASHBOARD: API paneles de rebalanceo y balances =======
    getBalances() {
        // Devuelve balances actuales
        return { ...this.currentBalances }
    }
    isAutoRebalanceEnabled() {
        return !!this._autoRebalanceEnabled
    }
    enableAutoRebalance() {
        if (!this._autoRebalanceEnabled) {
            this._autoRebalanceEnabled = true;
            if (!this.rebalanceInterval && this.rebalanceFrequency > 0) {
                this.scheduleAutoRebalance();
            }
        }
    }
    disableAutoRebalance() {
        if (this._autoRebalanceEnabled) {
            this._autoRebalanceEnabled = false;
            if (this.rebalanceInterval) {
                clearInterval(this.rebalanceInterval);
                this.rebalanceInterval = null;
            }
        }
    }
    // ======= FIN AGREGADO DASHBOARD =======
    
    /**
     * Obtiene el historial de balances
     * @param {number} limit - Límite de registros
     * @returns {Array} - Historial de balances
     */
    getBalanceHistory(limit = 100) {
        return this.balanceHistory.slice(-limit);
    }
    
    /**
     * Obtiene el historial de asignaciones
     * @param {number} limit - Límite de registros
     * @returns {Array} - Historial de asignaciones
     */
    getAllocationHistory(limit = 100) {
        return this.allocationHistory.slice(-limit);
    }
    
    /**
     * Obtiene el historial de rebalanceos
     * @param {number} limit - Límite de registros
     * @returns {Array} - Historial de rebalanceos
     */
    getRebalanceHistory(limit = 50) {
        return this.rebalanceHistory.slice(-limit);
    }
    
    /**
     * Actualiza la asignación objetivo
     * @param {Object} newAllocation - Nueva asignación objetivo
     */
    updateTargetAllocation(newAllocation) {
        // Validar que las asignaciones sumen 100%
        const totalAllocation = Object.values(newAllocation).reduce((sum, allocation) => sum + allocation, 0);
        
        if (Math.abs(totalAllocation - 1.0) > 0.01) {
            throw new Error('La asignación total debe sumar 100%');
        }
        
        this.targetAllocation = { ...newAllocation };
        this.logger.info('Asignación objetivo actualizada:', this.targetAllocation);
        
        // Verificar si se necesita rebalanceo inmediato
        this.checkAndRebalance();
    }
    
    /**
     * Detiene el gestor de portfolio
     */
    stop() {
        if (this.rebalanceInterval) {
            clearInterval(this.rebalanceInterval);
            this.rebalanceInterval = null;
        }
        
        this._autoRebalanceEnabled = false; // AGREGADO DASHBOARD: marcar como deshabilitado
        this.logger.info('Portfolio Manager detenido');
    }
}

module.exports = PortfolioManager;

-------------------------------------------------------------------------------------------------------

RISK

// ========== GESTIÓN AVANZADA DE RIESGO ==========
const config = require("../strategies/config")

class AdvancedRiskManager {
  constructor() {
    this.exposureMap = new Map()
    this.totalExposure = 0
    this.riskMetrics = new Map()
    this.correlationMatrix = new Map()
    this.volatilityHistory = new Map()
    this.anomalyDetector = new AnomalyDetector()
    this.stressTestResults = []
    this.riskLimits = this.initializeRiskLimits()
    
    // ======= AGREGADO PARA DASHBOARD =======
    this.riskSettings = {
      maxPorOperacion: 100,
      maxTotal: 1000,
    }
    // ======= FIN AGREGADO DASHBOARD =======

    console.log('🛡️ Gestor de Riesgo Avanzado inicializado')
  }

  // ======= AGREGADO PARA DASHBOARD =======
  getRiskSettings() {
    return this.riskSettings
  }
  setRiskSettings(settings) {
    this.riskSettings = { ...this.riskSettings, ...settings }
  }
  // ======= FIN AGREGADO DASHBOARD =======
  
  initializeRiskLimits() {
    return {
      maxDailyLoss: config.BOT.MAX_DAILY_LOSS || -5.0, // -5%
      maxSingleTradeRisk: 2.0, // 2% del portfolio por trade
      maxCorrelatedExposure: 30.0, // 30% en activos correlacionados
      maxVolatilityThreshold: 50.0, // 50% volatilidad anualizada
      maxDrawdown: 10.0, // 10% drawdown máximo
      minLiquidityRatio: 0.2, // 20% mínimo en activos líquidos
      maxConcentrationRisk: 40.0, // 40% máximo en un solo activo
    }
  }

  async assessTradeRisk(opportunity, marketData, portfolioValue) {
    const riskAssessment = {
      riskScore: 0,
      riskLevel: 'LOW',
      riskFactors: [],
      recommendations: [],
      approved: true,
      maxPositionSize: opportunity.tradeAmount,
    }

    try {
      // 1. Riesgo de volatilidad
      const volatilityRisk = this.assessVolatilityRisk(opportunity.pair, marketData)
      riskAssessment.riskScore += volatilityRisk.score
      if (volatilityRisk.factors.length > 0) {
        riskAssessment.riskFactors.push(...volatilityRisk.factors)
      }

      // 2. Riesgo de liquidez
      const liquidityRisk = this.assessLiquidityRisk(opportunity, marketData)
      riskAssessment.riskScore += liquidityRisk.score
      if (liquidityRisk.factors.length > 0) {
        riskAssessment.riskFactors.push(...liquidityRisk.factors)
      }

      // 3. Riesgo de concentración
      const concentrationRisk = this.assessConcentrationRisk(opportunity, portfolioValue)
      riskAssessment.riskScore += concentrationRisk.score
      if (concentrationRisk.factors.length > 0) {
        riskAssessment.riskFactors.push(...concentrationRisk.factors)
      }

      // 4. Riesgo de correlación
      const correlationRisk = this.assessCorrelationRisk(opportunity.pair)
      riskAssessment.riskScore += correlationRisk.score
      if (correlationRisk.factors.length > 0) {
        riskAssessment.riskFactors.push(...correlationRisk.factors)
      }

      // 5. Riesgo temporal
      const temporalRisk = this.assessTemporalRisk()
      riskAssessment.riskScore += temporalRisk.score
      if (temporalRisk.factors.length > 0) {
        riskAssessment.riskFactors.push(...temporalRisk.factors)
      }

      // Determinar nivel de riesgo
      if (riskAssessment.riskScore < 0.3) {
        riskAssessment.riskLevel = 'LOW'
      } else if (riskAssessment.riskScore < 0.7) {
        riskAssessment.riskLevel = 'MEDIUM'
      } else {
        riskAssessment.riskLevel = 'HIGH'
      }

      // Ajustar tamaño de posición basado en riesgo
      riskAssessment.maxPositionSize = this.calculateOptimalPositionSize(
        opportunity,
        riskAssessment.riskScore,
        portfolioValue
      )

      // Generar recomendaciones
      riskAssessment.recommendations = this.generateRiskRecommendations(riskAssessment)

      // Decidir aprobación
      riskAssessment.approved = this.shouldApproveTradeRisk(riskAssessment)

      return riskAssessment
    } catch (error) {
      console.error('❌ Error en evaluación de riesgo:', error)
      return {
        ...riskAssessment,
        riskLevel: 'HIGH',
        approved: false,
        riskFactors: ['Error en evaluación de riesgo'],
      }
    }
  }

  assessVolatilityRisk(pair, marketData) {
    const assessment = { score: 0, factors: [] }
    
    const currentVolatility = marketData.volatility || 0
    const historicalVolatility = this.getHistoricalVolatility(pair)
    
    // Volatilidad actual vs histórica
    if (currentVolatility > historicalVolatility * 1.5) {
      assessment.score += 0.3
      assessment.factors.push(`Volatilidad elevada: ${(currentVolatility * 100).toFixed(1)}%`)
    }

    // Volatilidad absoluta
    if (currentVolatility > this.riskLimits.maxVolatilityThreshold / 100) {
      assessment.score += 0.4
      assessment.factors.push(`Volatilidad excesiva: ${(currentVolatility * 100).toFixed(1)}%`)
    }

    // Cambios súbitos de volatilidad
    const volatilityChange = this.getVolatilityChange(pair)
    if (Math.abs(volatilityChange) > 0.1) {
      assessment.score += 0.2
      assessment.factors.push(`Cambio súbito de volatilidad: ${(volatilityChange * 100).toFixed(1)}%`)
    }

    return assessment
  }

  assessLiquidityRisk(opportunity, marketData) {
    const assessment = { score: 0, factors: [] }
    
    const volume24h = marketData.volume24h || 0
    const avgVolume = marketData.avgVolume || volume24h
    const volumeRatio = avgVolume > 0 ? volume24h / avgVolume : 1

    // Volumen bajo
    if (volumeRatio < 0.5) {
      assessment.score += 0.3
      assessment.factors.push(`Volumen bajo: ${(volumeRatio * 100).toFixed(1)}% del promedio`)
    }

    // Spread amplio (indicador de baja liquidez)
    if (opportunity.spread > 2.0) {
      assessment.score += 0.2
      assessment.factors.push(`Spread amplio: ${opportunity.spread.toFixed(2)}%`)
    }

    // Profundidad del order book
    const orderBookDepth = marketData.orderBookDepth || 0
    if (orderBookDepth < opportunity.tradeAmount * 2) {
      assessment.score += 0.4
      assessment.factors.push('Profundidad insuficiente del order book')
    }

    return assessment
  }

  assessConcentrationRisk(opportunity, portfolioValue) {
    const assessment = { score: 0, factors: [] }
    
    const currentExposure = this.exposureMap.get(opportunity.pair) || 0
    const newExposure = currentExposure + opportunity.tradeAmount
    const concentrationPercent = (newExposure / portfolioValue) * 100

    // Concentración por par
    if (concentrationPercent > this.riskLimits.maxConcentrationRisk) {
      assessment.score += 0.5
      assessment.factors.push(`Concentración excesiva en ${opportunity.pair}: ${concentrationPercent.toFixed(1)}%`)
    }

    // Exposición total
    const newTotalExposure = this.totalExposure + opportunity.tradeAmount
    const totalExposurePercent = (newTotalExposure / portfolioValue) * 100
    
    if (totalExposurePercent > 80) {
      assessment.score += 0.3
      assessment.factors.push(`Exposición total alta: ${totalExposurePercent.toFixed(1)}%`)
    }

    return assessment
  }

  assessCorrelationRisk(pair) {
    const assessment = { score: 0, factors: [] }
    
    const correlatedPairs = this.getCorrelatedPairs(pair)
    let correlatedExposure = 0

    for (const correlatedPair of correlatedPairs) {
      correlatedExposure += this.exposureMap.get(correlatedPair) || 0
    }

    const correlationPercent = (correlatedExposure / this.totalExposure) * 100

    if (correlationPercent > this.riskLimits.maxCorrelatedExposure) {
      assessment.score += 0.4
      assessment.factors.push(`Alta exposición correlacionada: ${correlationPercent.toFixed(1)}%`)
    }

    return assessment
  }

  assessTemporalRisk() {
    const assessment = { score: 0, factors: [] }
    
    const now = new Date()
    const hour = now.getHours()
    const day = now.getDay()

    // Horarios de baja liquidez
    if (hour >= 22 || hour <= 6) {
      assessment.score += 0.1
      assessment.factors.push('Horario de baja liquidez')
    }

    // Fines de semana
    if (day === 0 || day === 6) {
      assessment.score += 0.1
      assessment.factors.push('Trading en fin de semana')
    }

    // Eventos de mercado (simplificado)
    if (this.isHighVolatilityPeriod()) {
      assessment.score += 0.2
      assessment.factors.push('Período de alta volatilidad del mercado')
    }

    return assessment
  }

  calculateOptimalPositionSize(opportunity, riskScore, portfolioValue) {
    const baseSize = opportunity.tradeAmount
    const maxRiskPerTrade = portfolioValue * (this.riskLimits.maxSingleTradeRisk / 100)
    
    // Ajustar por score de riesgo
    const riskAdjustment = Math.max(0.1, 1 - riskScore)
    const adjustedSize = baseSize * riskAdjustment
    
    // Aplicar límites
    return Math.min(adjustedSize, maxRiskPerTrade, baseSize)
  }

  generateRiskRecommendations(riskAssessment) {
    const recommendations = []

    if (riskAssessment.riskLevel === 'HIGH') {
      recommendations.push('Considere reducir el tamaño de la posición')
      recommendations.push('Monitoree de cerca la ejecución')
      recommendations.push('Prepare stop-loss más estricto')
    }

    if (riskAssessment.riskFactors.includes('Volatilidad elevada')) {
      recommendations.push('Espere a que la volatilidad se normalice')
    }

    if (riskAssessment.riskFactors.some(f => f.includes('Concentración'))) {
      recommendations.push('Diversifique la exposición')
    }

    if (riskAssessment.riskFactors.some(f => f.includes('liquidez'))) {
      recommendations.push('Verifique la profundidad del order book')
    }

    return recommendations
  }

  shouldApproveTradeRisk(riskAssessment) {
    // No aprobar si el riesgo es muy alto
    if (riskAssessment.riskScore > 0.8) return false
    
    // No aprobar si hay factores críticos
    const criticalFactors = [
      'Volatilidad excesiva',
      'Concentración excesiva',
      'Profundidad insuficiente'
    ]
    
    for (const factor of riskAssessment.riskFactors) {
      if (criticalFactors.some(critical => factor.includes(critical))) {
        return false
      }
    }

    return true
  }

  async runStressTest(scenarios = []) {
    console.log('🧪 Ejecutando stress test...')
    
    const defaultScenarios = [
      { name: 'Crash 20%', priceChange: -0.20, volumeChange: -0.50 },
      { name: 'Volatilidad Extrema', volatilityMultiplier: 3, spreadMultiplier: 2 },
      { name: 'Liquidez Baja', volumeChange: -0.80, spreadMultiplier: 5 },
      { name: 'Correlación Alta', correlationIncrease: 0.5 },
    ]

    const testScenarios = scenarios.length > 0 ? scenarios : defaultScenarios
    const results = []

    for (const scenario of testScenarios) {
      const result = await this.simulateScenario(scenario)
      results.push(result)
    }

    this.stressTestResults = results
    return results
  }

  async simulateScenario(scenario) {
    const simulation = {
      name: scenario.name,
      parameters: scenario,
      results: {
        portfolioLoss: 0,
        maxDrawdown: 0,
        tradesAffected: 0,
        liquidityImpact: 0,
        riskScore: 0,
      },
      recommendations: [],
    }

    // Simular impacto en portfolio
    if (scenario.priceChange) {
      simulation.results.portfolioLoss = this.totalExposure * Math.abs(scenario.priceChange)
    }

    // Simular impacto en liquidez
    if (scenario.volumeChange) {
      simulation.results.liquidityImpact = Math.abs(scenario.volumeChange)
    }

    // Calcular score de riesgo del escenario
    simulation.results.riskScore = this.calculateScenarioRisk(scenario)

    // Generar recomendaciones
    simulation.recommendations = this.generateStressTestRecommendations(simulation)

    return simulation
  }

  calculateScenarioRisk(scenario) {
    let riskScore = 0

    if (scenario.priceChange && Math.abs(scenario.priceChange) > 0.1) {
      riskScore += 0.4
    }

    if (scenario.volatilityMultiplier && scenario.volatilityMultiplier > 2) {
      riskScore += 0.3
    }

    if (scenario.volumeChange && scenario.volumeChange < -0.5) {
      riskScore += 0.3
    }

    return Math.min(1.0, riskScore)
  }

  generateStressTestRecommendations(simulation) {
    const recommendations = []

    if (simulation.results.portfolioLoss > this.totalExposure * 0.1) {
      recommendations.push('Reducir exposición total')
      recommendations.push('Implementar hedging')
    }

    if (simulation.results.liquidityImpact > 0.5) {
      recommendations.push('Diversificar exchanges')
      recommendations.push('Monitorear volúmenes más de cerca')
    }

    if (simulation.results.riskScore > 0.7) {
      recommendations.push('Pausar trading automático')
      recommendations.push('Revisar límites de riesgo')
    }

    return recommendations
  }

  // Métodos auxiliares
  getHistoricalVolatility(pair) {
    const history = this.volatilityHistory.get(pair) || []
    if (history.length === 0) return 0.02 // 2% por defecto
    
    return history.reduce((sum, vol) => sum + vol, 0) / history.length
  }

  getVolatilityChange(pair) {
    const history = this.volatilityHistory.get(pair) || []
    if (history.length < 2) return 0
    
    return history[history.length - 1] - history[history.length - 2]
  }

  getCorrelatedPairs(pair) {
    // Simplificado - en producción usar matriz de correlación real
    const correlations = {
      'POL/USDT': ['MATIC/USDT'],
      'BTC/USDT': ['ETH/USDT'],
      'ETH/USDT': ['BTC/USDT'],
    }
    
    return correlations[pair] || []
  }

  isHighVolatilityPeriod() {
    // Simplificado - en producción usar indicadores de mercado reales
    return Math.random() < 0.1 // 10% probabilidad
  }

  updateExposure(pair, amount, isClosing = false) {
    const currentExposure = this.exposureMap.get(pair) || 0
    
    if (isClosing) {
      const newExposure = Math.max(0, currentExposure - amount)
      this.exposureMap.set(pair, newExposure)
      this.totalExposure = Math.max(0, this.totalExposure - amount)
    } else {
      this.exposureMap.set(pair, currentExposure + amount)
      this.totalExposure += amount
    }
  }

  trackVolatility(pair, volatility) {
    if (!this.volatilityHistory.has(pair)) {
      this.volatilityHistory.set(pair, [])
    }
    
    const history = this.volatilityHistory.get(pair)
    history.push(volatility)
    
    // Mantener solo los últimos 100 puntos
    if (history.length > 100) {
      history.shift()
    }
  }

  getRiskReport() {
    return {
      totalExposure: this.totalExposure,
      exposureByPair: Object.fromEntries(this.exposureMap),
      riskLimits: this.riskLimits,
      stressTestResults: this.stressTestResults.slice(-5), // Últimos 5 tests
      riskMetrics: Object.fromEntries(this.riskMetrics),
      recommendations: this.generatePortfolioRiskRecommendations(),
    }
  }

  generatePortfolioRiskRecommendations() {
    const recommendations = []
    
    // Verificar exposición total
    if (this.totalExposure > 1000) { // Ejemplo: $1000
      recommendations.push({
        type: 'EXPOSURE',
        message: 'Exposición total elevada',
        priority: 'MEDIUM',
      })
    }

    // Verificar concentración
    for (const [pair, exposure] of this.exposureMap.entries()) {
      if (exposure > this.totalExposure * 0.4) {
        recommendations.push({
          type: 'CONCENTRATION',
          message: `Alta concentración en ${pair}`,
          priority: 'HIGH',
        })
      }
    }

    return recommendations
  }
}

// Detector de anomalías auxiliar
class AnomalyDetector {
  constructor() {
    this.priceHistory = new Map()
    this.volumeHistory = new Map()
    this.spreadHistory = new Map()
  }

  detectAnomalies(pair, price, volume, spread) {
    const anomalies = []
    
    // Detectar anomalías de precio
    const priceAnomaly = this.detectPriceAnomaly(pair, price)
    if (priceAnomaly) anomalies.push(priceAnomaly)
    
    // Detectar anomalías de volumen
    const volumeAnomaly = this.detectVolumeAnomaly(pair, volume)
    if (volumeAnomaly) anomalies.push(volumeAnomaly)
    
    // Detectar anomalías de spread
    const spreadAnomaly = this.detectSpreadAnomaly(pair, spread)
    if (spreadAnomaly) anomalies.push(spreadAnomaly)
    
    // Actualizar historiales
    this.updateHistory(pair, price, volume, spread)
    
    return anomalies
  }

  detectPriceAnomaly(pair, price) {
    const history = this.priceHistory.get(pair) || []
    if (history.length < 10) return null
    
    const avg = history.reduce((a, b) => a + b) / history.length
    const deviation = Math.abs(price - avg) / avg
    
    if (deviation > 0.05) { // 5% desviación
      return {
        type: 'PRICE_ANOMALY',
        severity: deviation > 0.1 ? 'HIGH' : 'MEDIUM',
        message: `Precio anómalo: ${(deviation * 100).toFixed(1)}% desviación`,
      }
    }
    
    return null
  }

  detectVolumeAnomaly(pair, volume) {
    const history = this.volumeHistory.get(pair) || []
    if (history.length < 10) return null
    
    const avg = history.reduce((a, b) => a + b) / history.length
    const ratio = volume / avg
    
    if (ratio < 0.1 || ratio > 10) {
      return {
        type: 'VOLUME_ANOMALY',
        severity: ratio < 0.05 || ratio > 20 ? 'HIGH' : 'MEDIUM',
        message: `Volumen anómalo: ${ratio.toFixed(1)}x del promedio`,
      }
    }
    
    return null
  }

  detectSpreadAnomaly(pair, spread) {
    const history = this.spreadHistory.get(pair) || []
    if (history.length < 10) return null
    
    const avg = history.reduce((a, b) => a + b) / history.length
    const ratio = spread / avg
    
    if (ratio > 3) {
      return {
        type: 'SPREAD_ANOMALY',
        severity: ratio > 5 ? 'HIGH' : 'MEDIUM',
        message: `Spread anómalo: ${ratio.toFixed(1)}x del promedio`,
      }
    }
    
    return null
  }

  updateHistory(pair, price, volume, spread) {
    // Actualizar historial de precios
    if (!this.priceHistory.has(pair)) {
      this.priceHistory.set(pair, [])
    }
    const priceHist = this.priceHistory.get(pair)
    priceHist.push(price)
    if (priceHist.length > 50) priceHist.shift()
    
    // Actualizar historial de volumen
    if (!this.volumeHistory.has(pair)) {
      this.volumeHistory.set(pair, [])
    }
    const volumeHist = this.volumeHistory.get(pair)
    volumeHist.push(volume)
    if (volumeHist.length > 50) volumeHist.shift()
    
    // Actualizar historial de spread
    if (!this.spreadHistory.has(pair)) {
      this.spreadHistory.set(pair, [])
    }
    const spreadHist = this.spreadHistory.get(pair)
    spreadHist.push(spread)
    if (spreadHist.length > 50) spreadHist.shift()
  }
}

module.exports = {
  AdvancedRiskManager
}

------------------------------------------------------------------------------------------------------

SCRIPTS

// Nuevo script para ejecutar el backtesting
const { Backtester } = require("../backtesting/backtester")
const { HistoricalDataManager } = require("../backtesting/historical-data-manager")
const config = require("../config")

async function main() {
  if (!config.BACKTESTING.ENABLED) {
    console.log("El backtesting está desactivado en la configuración.")
    return
  }

  const startDateStr = process.argv[2] || "2024-01-01" // Ejemplo: YYYY-MM-DD
  const endDateStr = process.argv[3] || "2024-01-02" // Ejemplo: YYYY-MM-DD

  console.log(`Preparando datos históricos para el backtest (${startDateStr} a ${endDateStr})...`)
  const dataManager = new HistoricalDataManager()

  // Descargar/verificar datos para el rango especificado
  // Esto es un ejemplo, necesitarías una lógica más robusta para manejar los días
  const currentDate = new Date(startDateStr)
  const finalDate = new Date(endDateStr)

  while (currentDate <= finalDate) {
    for (const pairConfig of config.TRADING_PAIRS) {
      for (const exchangeName of Object.keys(config.EXCHANGES)) {
        // El método fetchAndStoreCandlestickData ahora guarda los datos si no existen.
        // Para un backtest, primero nos aseguraríamos que los datos existen.
        // Si no, se podrían descargar aquí o el backtester podría hacerlo.
        // Por simplicidad, asumimos que fetchAndStore los obtiene y guarda si es necesario.
        await dataManager.fetchAndStoreCandlestickData(
          exchangeName,
          pairConfig.symbol,
          "1m", // intervalo
          currentDate.getTime(), // startTime del día
          currentDate.getTime() + (24 * 60 * 60 * 1000 - 1), // endTime del día
        )
      }
    }
    currentDate.setDate(currentDate.getDate() + 1)
  }
  console.log("Datos históricos listos.")

  const backtester = new Backtester(startDateStr, endDateStr)

  try {
    const report = await backtester.run()
    console.log("\n--- Reporte Final del Backtest ---")
    console.log(`Periodo: ${report.startDate.toDateString()} - ${report.endDate.toDateString()}`)
    console.log(`Balance Inicial: ${report.initialBalance.toFixed(2)} USDT`)
    console.log(`Balance Final: ${report.finalBalance.toFixed(2)} USDT`)
    console.log(`Profit: ${report.profit.toFixed(2)} USDT (${report.profitPercentage.toFixed(2)}%)`)
    console.log(`Total Trades: ${report.totalTrades}`)

    // Enviar alerta con el resumen del backtest
    if (config.ALERTS.ALERT_ON_BACKTEST_COMPLETION && backtester.simulatedBot) {
      const alertMessage =
        `Backtest completado (${startDateStr} a ${endDateStr}):\n` +
        `Profit: ${report.profit.toFixed(2)} USDT (${report.profitPercentage.toFixed(2)}%)\n` +
        `Trades: ${report.totalTrades}`
      await backtester.simulatedBot.logAndAlert(alertMessage, { type: "BACKTEST_RESULT", priority: "normal" })
    }
  } catch (error) {
    console.error("Error durante el backtesting:", error)
  }
}

main()

#----------run-backtest----------------

--------------------------------------------------------------------------------------
SERVICES

import axios from "axios";
const API = axios.create({ baseURL: "/api" });
export default API;

--------------------------------------------------------------------------------------

const express = require("express");
const config = require("../strategies/config");
const fs = require("fs");
const path = require("path");

const router = express.Router();

/* ===========================
   CONFIGURACIÓN GENERAL
   =========================== */
router.get("/config", (req, res) => {
  res.json(config);
});

router.post("/config", (req, res) => {
  // Actualizar config.js en disco. (Requiere reinicio del bot para efectos completos.)
  const newConfig = req.body;
  const configPath = path.join(__dirname, "../strategies/config.js");
  fs.writeFileSync(
    configPath,
    "module.exports = " + JSON.stringify(newConfig, null, 2)
  );
  res.json({ ok: true });
});

/* ===========================
   ENDPOINTS MÍNIMOS PARA DASHBOARD
   =========================== */
router.get("/metrics", (req, res) => {
  const metrics = {
    totalTrades: 123,
    totalProfit: 456.78,
    uptime: "24h 13m",
    winRate: "67%",
    openPositions: 4,
    closedPositions: 119,
    currentBalance: 15234.56,
    startTime: "2025-06-12 12:00:00"
  };
  res.json(metrics);
});

router.get("/commissions", (req, res) => {
  const commissions = [
    { exchange: "Binance", type: "maker", fee: 0.1 },
    { exchange: "Binance", type: "taker", fee: 0.2 },
    { exchange: "Kraken", type: "maker", fee: 0.16 },
    { exchange: "Kraken", type: "taker", fee: 0.26 },
    { exchange: "Bitfinex", type: "maker", fee: 0.1 }
  ];
  res.json(commissions);
});

router.get("/alerts", (req, res) => {
  res.json(config.ALERTS || [
    { id: 1, type: "info", message: "Bot iniciado correctamente.", timestamp: "2025-06-13 07:00:00" },
    { id: 2, type: "warning", message: "Balance bajo en Binance.", timestamp: "2025-06-13 06:50:00" }
  ]);
});

/* ===========================
   EXCHANGES
   =========================== */
router.get("/exchanges", (req, res) => {
  res.json(config.EXCHANGES);
});

router.post("/exchanges", (req, res) => {
  config.EXCHANGES = req.body;
  res.json({ ok: true });
});

/* ===========================
   ESTRATEGIAS
   =========================== */
router.get("/strategies", (req, res) => {
  res.json(config.STRATEGIES);
});

router.post("/strategies", (req, res) => {
  config.STRATEGIES = req.body;
  res.json({ ok: true });
});

/* ===========================
   RISK MANAGEMENT
   =========================== */
router.get("/risk", (req, res) => {
  res.json(config.RISK_MANAGEMENT);
});

router.post("/risk", (req, res) => {
  config.RISK_MANAGEMENT = req.body;
  res.json({ ok: true });
});

/* ===========================
   PORTFOLIO
   =========================== */
router.get("/portfolio", (req, res) => {
  res.json(config.PORTFOLIO);
});

router.post("/portfolio", (req, res) => {
  config.PORTFOLIO = req.body;
  res.json({ ok: true });
});

/* ===========================
   AI
   =========================== */
router.get("/ai", (req, res) => {
  res.json(config.AI_TRADING);
});

router.post("/ai", (req, res) => {
  config.AI_TRADING = req.body;
  res.json({ ok: true });
});

/* ===========================
   BACKTESTING
   =========================== */
router.get("/backtesting", (req, res) => {
  res.json(config.BACKTESTING);
});

router.post("/backtesting", (req, res) => {
  config.BACKTESTING = req.body;
  res.json({ ok: true });
});

/* ===========================
   MOBILE API
   =========================== */
router.get("/mobile-api", (req, res) => {
  res.json(config.MOBILE_API);
});

router.post("/mobile-api", (req, res) => {
  config.MOBILE_API = req.body;
  res.json({ ok: true });
});

/* ===========================
   DASHBOARD
   =========================== */
router.get("/dashboard", (req, res) => {
  res.json(config.DASHBOARD);
});

router.post("/dashboard", (req, res) => {
  config.DASHBOARD = req.body;
  res.json({ ok: true });
});

/* ===========================
   LOGS
   =========================== */
router.get("/logging", (req, res) => {
  res.json(config.LOGGING);
});

router.post("/logging", (req, res) => {
  config.LOGGING = req.body;
  res.json({ ok: true });
});

/* ===========================
   MONITORING
   =========================== */
router.get("/monitoring", (req, res) => {
  res.json(config.MONITORING);
});

router.post("/monitoring", (req, res) => {
  config.MONITORING = req.body;
  res.json({ ok: true });
});

/* ===========================
   SECURITY
   =========================== */
router.get("/security", (req, res) => {
  res.json(config.SECURITY);
});

router.post("/security", (req, res) => {
  config.SECURITY = req.body;
  res.json({ ok: true });
});

/* ===========================
   TROUBLESHOOTING
   =========================== */
router.get("/troubleshooting", (req, res) => {
  const manualPath = path.join(__dirname, "../../Manual_Completo_del_Bot_La_Biblia.txt");
  let content = "";
  try {
    content = fs.readFileSync(manualPath, "utf8");
  } catch (e) {
    content = "Manual no encontrado.";
  }
  res.json({ manual: content });
});

module.exports = router;

---------------------------------------------------------------------------------------------------------

STRATEGIES

/**
 * Configuración completa del Bot de YageCoin Exchange CEX con IA
 */


module.exports = {
  // Configuración general
  CHECK_INTERVAL: 5000, // Intervalo de verificación en ms
  TRADING_PAIRS: ["LTC/USDT", "BNB/USDT", "XRP/USDT"], // SOLO los tres pares indicados

  // Configuración de Exchanges - SOLO BINANCE Y BYBIT HABILITADOS
  EXCHANGES: {
    BINANCE: {
      name: "Binance",
      apiKey: process.env.BINANCE_API_KEY || "",
      apiSecret: process.env.BINANCE_API_SECRET || "",
      sandbox: process.env.NODE_ENV !== "production",
      rateLimit: 10,
      fees: {
        maker: 0.1,
        taker: 0.1,
      },
      enabled: true, // ✅ HABILITADO
    },
    COINBASE: {
      name: "Coinbase",
      apiKey: process.env.COINBASE_API_KEY || "",
      apiSecret: process.env.COINBASE_API_SECRET || "",
      passphrase: process.env.COINBASE_PASSPHRASE || "",
      sandbox: process.env.NODE_ENV !== "production",
      rateLimit: 10,
      fees: {
        maker: 0.005,
        taker: 0.005,
      },
      enabled: false, // ❌ DESHABILITADO
    },
    KRAKEN: {
      name: "Kraken",
      apiKey: process.env.KRAKEN_API_KEY || "",
      apiSecret: process.env.KRAKEN_API_SECRET || "",
      sandbox: process.env.NODE_ENV !== "production",
      rateLimit: 10,
      fees: {
        maker: 0.0016,
        taker: 0.0026,
      },
      enabled: false, // ❌ DESHABILITADO
    },
    KUCOIN: {
      name: "Kucoin",
      apiKey: process.env.KUCOIN_API_KEY || "",
      apiSecret: process.env.KUCOIN_API_SECRET || "",
      passphrase: process.env.KUCOIN_PASSPHRASE || "",
      sandbox: process.env.NODE_ENV !== "production",
      rateLimit: 10,
      fees: {
        maker: 0.001,
        taker: 0.001,
      },
      enabled: false, // ❌ DESHABILITADO - CAMBIADO A BYBIT
    },
    BYBIT: {
      name: "Bybit",
      apiKey: process.env.BYBIT_API_KEY || "",
      apiSecret: process.env.BYBIT_API_SECRET || "",
      sandbox: process.env.NODE_ENV !== "production",
      rateLimit: 10,
      fees: {
        maker: 0.1,
        taker: 0.1,
      },
      enabled: true, // ✅ HABILITADO - NUEVO
    },
  },

  // === NUEVO BLOQUE PARA REDES, DIRECCIONES Y MINIMOS DE DEPOSITO/RETIRO ===
  TOKEN_NETWORKS: {
    BINANCE: {
      USDT: {
        address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb",
        memo: "163771801",
        network: "TON",
        minDeposit: 0.002,
        minWithdraw: 10,
        withdrawFee: 0.20,
        withdrawToken: "USDC", // Confirmar si es USDT o USDC en TON
        note: "Depósito mínimo en TON: 0.002 USDT"
      },
      LTC: {
        address: "LiCH4dMWM6YRHFWYC78hppAk1SwUFkDAK4",
        network: "Litecoin",
        minDeposit: 0.002,
        minWithdraw: 0.002,
        withdrawFee: 0.0001,
        withdrawToken: "LTC"
      },
      BNB: {
        address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
        network: "BEP20",
        minDeposit: 0.000003,
        minWithdraw: 0.0005,
        withdrawFee: 0.00001,
        withdrawToken: "BNB"
      },
      XRP: {
        address: "rNxp4h8apvRis6mJf9Sh8C6iRxfrDWN7AV",
        tag: "466152795",
        network: "XRP",
        minDeposit: 0.001,
        minWithdraw: 2,
        withdrawFee: 0.2,
        withdrawToken: "XRP"
      }
    },
    BYBIT: {
      USDT: {
        address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
        network: "TON",
        minDeposit: 0.001,
        minWithdraw: 1,
        withdrawFee: 0.3,
        withdrawToken: "USDT"
      },
      LTC: {
        address: "LLCxH3L5fn9ejTPVk3nWTJcqvvTWsu2LbJ",
        network: "Litecoin",
        minDeposit: 0.00000001,
        minWithdraw: 0.001,
        withdrawFee: 0.0001,
        withdrawToken: "LTC"
      },
      BNB: {
        address: "0x4231d188a91481a8c3d39d444b7451436babee94",
        network: "BEP20",
        minDeposit: 0.000,
        minWithdraw: 0.0002,
        withdrawFee: 0.0002,
        withdrawToken: "BNB"
      },
      XRP: {
        address: "rJn2zAPdFA193sixJwuFixRkYDUtx3apQh",
        tag: "501350199",
        network: "XRP",
        minDeposit: 0.01,
        minWithdraw: 1.2,
        withdrawFee: 0.2,
        withdrawToken: "XRP"
      }
    }
  },

// Configuración de Gestión de Riesgos
  RISK_MANAGEMENT: {
    RISK_LEVEL: "medium",
    MAX_DRAWDOWN: 0.05,
    MAX_EXPOSURE: 0.2,
    STOP_LOSS_PERCENTAGE: 0.02,
    VOLATILITY_THRESHOLD: 0.1,
    MAX_DAILY_TRADES: 100,
    MAX_CONCURRENT_TRADES: 5,
    MIN_PROFIT_THRESHOLD: 0.1,
    REBALANCE_THRESHOLD: 0.15,
    EMERGENCY_STOP_LOSS: 0.1,
    MIN_TRADE_AMOUNT: 10, // Mínimo por operación
    MAX_TRADE_AMOUNT: 10, // Máximo por operación
    MAX_SLIPPAGE: 0.1, // 0.5% de slippage máximo tolerado
    MIN_SPREAD: 0.2, // 0.2% spread mínimo para arbitrar
    EXCHANGE_RISK_SCORES: {
      Binance: 1.0,
      Bybit: 1.3,
    },
  },

  // Configuración de Portfolio
  PORTFOLIO: {
    INITIAL_BALANCE: 15, // 15 USDT por exchange
    REBALANCE_FREQUENCY: 3600000,
    TARGET_ALLOCATION: {
      Binance: 0.5,
      Bybit: 0.5,
    },
    MIN_BALANCE_PER_EXCHANGE: 15,
    RESERVE_PERCENTAGE: 0.1,
    AUTO_COMPOUND: true,
    COMPOUND_THRESHOLD: 100,
  },

  // Límites y reglas del exchange
  EXCHANGE_LIMITS: {
    BINANCE: {
      dailyWithdrawLimit: null,
      tradingLimit: null,
      countryRestrictions: null
    },
    BYBIT: {
      dailyWithdrawLimit: null,
      tradingLimit: null,
      countryRestrictions: null
    }
  },

  // Configuración de Estrategias
  STRATEGIES: {
    BASIC: {
      name: "Arbitraje Básico",
      enabled: true,
      minProfitPercentage: 0.2,
      maxInvestmentPercentage: 0.1,
      timeoutMs: 30000,
    },
    TRIANGULAR: {
      name: "Arbitraje Triangular",
      enabled: true,
      minProfitPercentage: 0.15,
      maxInvestmentPercentage: 0.08,
      timeoutMs: 45000,
      maxHops: 3,
    },
    STATISTICAL: {
      name: "Arbitraje Estadístico",
      enabled: true,
      lookbackPeriod: 100,
      zScoreThreshold: 2.0,
      meanReversionTime: 300000,
      minProfitPercentage: 0.1,
    },
    ML: {
      name: "Machine Learning",
      enabled: true,
      modelType: "random_forest",
      features: ["price_spread", "volume_ratio", "volatility", "time_of_day", "market_sentiment"],
      retrainInterval: 86400000,
      confidenceThreshold: 0.7,
    },
    COMBINED: {
      name: "Estrategia Combinada",
      enabled: true,
      strategies: ["BASIC", "TRIANGULAR", "STATISTICAL"],
      votingThreshold: 2,
      weightings: {
        BASIC: 0.4,
        TRIANGULAR: 0.3,
        STATISTICAL: 0.3,
      },
    },
  },

  // Configuración de IA y Machine Learning
  AI_TRADING: {
    ENABLED: true,
    MODEL_PATH: "./models/",
    TRAINING_DATA_DAYS: 30,
    PREDICTION_HORIZON: 300000,
    FEATURES: {
      TECHNICAL_INDICATORS: true,
      MARKET_SENTIMENT: true,
      ORDER_BOOK_ANALYSIS: true,
      VOLUME_ANALYSIS: true,
      CORRELATION_ANALYSIS: true,
    },
    MODELS: {
      PRICE_PREDICTION: {
        type: "lstm",
        layers: [50, 50, 25],
        epochs: 100,
        batchSize: 32,
      },
      OPPORTUNITY_SCORING: {
        type: "random_forest",
        nEstimators: 100,
        maxDepth: 10,
      },
      RISK_ASSESSMENT: {
        type: "gradient_boosting",
        nEstimators: 50,
        learningRate: 0.1,
      },
      AI_TRADING: {
        ENABLED: false,
        MODE: "ml", // O "heuristic"
        MODEL_PATH: "./models", // Debe existir esta carpeta y el modelo .json/.bin
    // otros parámetros...
      },
      AI_TRADING: {
      ENABLED: true,
      MODE: "heuristic", // <<< SOLO HEURÍSTICO
      MODEL_PATH: "./models"
      },
    },
    AUTO_RETRAIN: true,
    RETRAIN_THRESHOLD: 0.05,
    SENTIMENT_SOURCES: ["twitter", "reddit", "news", "fear_greed_index"],
  },
  

  // Configuración de Backtesting
  BACKTESTING: {
    ENABLED: true,
    DATA_SOURCE: "historical_api",
    DEFAULT_PERIOD: 30,
    COMMISSION_RATE: 0.001,
    SLIPPAGE_RATE: 0.0005,
    INITIAL_CAPITAL: 10000,
    BENCHMARK: "BTC",
    METRICS: ["total_return", "sharpe_ratio", "max_drawdown", "win_rate", "profit_factor", "calmar_ratio"],
    MONTE_CARLO_SIMULATIONS: 1000,
    CONFIDENCE_INTERVALS: [0.95, 0.99],
  },

  // *** CONFIGURACIÓN DE ALERTAS COMPLETAS ***
  ALERTS: {
    ENABLED: true,
    CHANNELS: {
      EMAIL: {
        enabled: process.env.EMAIL_ENABLED === "true",
        smtp: {
          host: process.env.EMAIL_SERVICE === "gmail" ? "smtp.gmail.com" : "smtp.gmail.com",
          port: 587,
          secure: false,
          auth: {
            user: process.env.EMAIL_USER || "",
            pass: process.env.EMAIL_PASS || "",
          },
        },
        from: process.env.EMAIL_USER || "bot@arbitrage.com",
        to: process.env.EMAIL_TO || "admin@arbitrage.com",
      },
      TELEGRAM: {
        enabled: true,
        botToken: process.env.TELEGRAM_BOT_TOKEN || "",
        chatId: process.env.TELEGRAM_CHAT_ID || "",
        parseMode: "HTML",
      },
      DISCORD: {
        enabled: false,
        webhookUrl: process.env.DISCORD_WEBHOOK_URL || "",
      },
      SLACK: {
        enabled: false,
        webhookUrl: process.env.SLACK_WEBHOOK_URL || "",
      },
    },
    ALERT_TYPES: {
      // *** ALERTAS DE SISTEMA ***
      BOT_STARTED: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "medium",
      },
      BOT_STOPPED: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "high",
      },
      SYSTEM_ERROR: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "critical",
      },
      CONNECTION_ERROR: {
        enabled: true,
        channels: ["telegram"],
        priority: "high",
      },

      // *** ALERTAS DE TRADING ***
      TRADE_EXECUTED: {
        enabled: true,
        channels: ["telegram"],
        priority: "medium",
      },
      TRADE_FAILED: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "high",
      },
      OPPORTUNITY_FOUND: {
        enabled: true,
        channels: ["telegram"],
        priority: "low",
      },
      PAIR_ANALYSIS: {
        enabled: true,
        channels: ["telegram"],
        priority: "low",
      },

      // *** ALERTAS DE BALANCE ***
      BALANCE_UPDATE: {
        enabled: true,
        channels: ["telegram"],
        priority: "low",
      },
      LOW_BALANCE: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "high",
      },
      BALANCE_REBALANCED: {
        enabled: true,
        channels: ["telegram"],
        priority: "medium",
      },

      // *** ALERTAS DE GANANCIAS ***
      PROFIT_MILESTONE: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "high",
        milestones: [50, 100, 250, 500, 1000], // USD
      },
      DAILY_PROFIT: {
        enabled: true,
        channels: ["telegram"],
        priority: "medium",
      },

      // *** ALERTAS DE RIESGO ***
      RISK_WARNING: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "high",
      },
      HIGH_VOLATILITY: {
        enabled: true,
        channels: ["telegram"],
        priority: "medium",
      },
      STOP_LOSS_TRIGGERED: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "critical",
      },

      // *** ALERTAS PERIÓDICAS ***
      HOURLY_SUMMARY: {
        enabled: true,
        channels: ["telegram"],
        priority: "low",
      },
      DAILY_SUMMARY: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "medium",
        time: "23:59",
      },
      WEEKLY_SUMMARY: {
        enabled: true,
        channels: ["email"],
        priority: "medium",
      },

      // *** ALERTAS GENERALES ***
      INFO: {
        enabled: true,
        channels: ["telegram"],
        priority: "low",
      },
      WARNING: {
        enabled: true,
        channels: ["telegram"],
        priority: "medium",
      },
      ERROR: {
        enabled: true,
        channels: ["telegram", "email"],
        priority: "high",
      },
    },
  },

  // Configuración de API Móvil
  MOBILE_API: {
    ENABLED: false,
    PORT: process.env.MOBILE_API_PORT || 8426,
    JWT_SECRET: process.env.JWT_SECRET || "your-secret-key",
    JWT_EXPIRY: "24h",
    RATE_LIMIT: {
      windowMs: 15 * 60 * 1000,
      max: 100,
    },
    CORS: {
      origin: process.env.MOBILE_APP_URL || "*",
      credentials: true,
    },
    ENDPOINTS: {
      STATUS: "/api/mobile/status",
      TRADES: "/api/mobile/trades",
      PORTFOLIO: "/api/mobile/portfolio",
      ALERTS: "/api/mobile/alerts",
      SETTINGS: "/api/mobile/settings",
    },
    PUSH_NOTIFICATIONS: {
      enabled: true,
      fcmServerKey: process.env.FCM_SERVER_KEY || "",
      topics: ["trades", "alerts", "system"],
    },
  },

  // Configuración de Base de Datos
  DATABASE: {
    TYPE: "mongodb",
    URL: process.env.DATABASE_URL || "mongodb://localhost:27017/arbitrage_bot",
    OPTIONS: {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
    },
    COLLECTIONS: {
      TRADES: "trades",
      BALANCES: "balances",
      PRICES: "prices",
      ALERTS: "alerts",
      SETTINGS: "settings",
      ML_MODELS: "ml_models",
    },
  },

  // Configuración de Logging
  LOGGING: {
    LEVEL: process.env.LOG_LEVEL || "info",
    FILE: {
      enabled: true,
      path: "./logs/",
      maxSize: "10m",
      maxFiles: 5,
      datePattern: "YYYY-MM-DD",
    },
    CONSOLE: {
      enabled: true,
      colorize: true,
      timestamp: true,
    },
    REMOTE: {
      enabled: false,
      endpoint: process.env.LOG_ENDPOINT || "",
      apiKey: process.env.LOG_API_KEY || "",
    },
  },

  // Configuración de Seguridad
  SECURITY: {
    API_ENCRYPTION: true,
    ENCRYPTION_KEY: process.env.ENCRYPTION_KEY || "your-encryption-key",
    TWO_FACTOR_AUTH: {
      enabled: false,
      secret: process.env.TOTP_SECRET || "",
    },
    IP_WHITELIST: process.env.IP_WHITELIST ? process.env.IP_WHITELIST.split(",") : [],
    MAX_LOGIN_ATTEMPTS: 5,
    LOCKOUT_DURATION: 300000,
    SESSION_TIMEOUT: 3600000,
  },

  // Configuración de Performance
  PERFORMANCE: {
    MAX_MEMORY_USAGE: 512,
    CPU_THRESHOLD: 80,
    GARBAGE_COLLECTION: {
      enabled: true,
      interval: 300000,
    },
    CACHE: {
      enabled: true,
      ttl: 60000,
      maxSize: 1000,
    },
    COMPRESSION: {
      enabled: true,
      level: 6,
    },
  },

  // Configuración de Desarrollo
  DEVELOPMENT: {
    DEBUG_MODE: process.env.NODE_ENV === "development",
    MOCK_EXCHANGES: process.env.MOCK_EXCHANGES === "true",
    SIMULATION_ONLY: process.env.SIMULATION_ONLY === "true",
    HOT_RELOAD: true,
    PROFILING: {
      enabled: false,
      interval: 60000,
    },
  },
}
// Config.js

---------------------------------------------------------------------------------------------------------

/**
 * Módulo de gestión avanzada de riesgos para el bot de arbitraje
 */
const EventEmitter = require('events')

class AdvancedRiskManager extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.riskLevel = config.RISK_MANAGEMENT.RISK_LEVEL || 'medium';
        this.maxDrawdown = config.RISK_MANAGEMENT.MAX_DRAWDOWN || 0.05;
        this.maxExposure = config.RISK_MANAGEMENT.MAX_EXPOSURE || 0.2;
        this.stopLossPercentage = config.RISK_MANAGEMENT.STOP_LOSS_PERCENTAGE || 0.02;
        this.volatilityThreshold = config.RISK_MANAGEMENT.VOLATILITY_THRESHOLD || 0.1;
        this.exchangeRiskScores = config.RISK_MANAGEMENT.EXCHANGE_RISK_SCORES || {
            'Binance': 1,
            'Coinbase': 1,
            'Kraken': 1.2,
            'Kucoin': 1.5
        };
        
        this.portfolioValue = 0;
        this.initialPortfolioValue = 0;
        this.maxPortfolioValue = 0;
        this.currentDrawdown = 0;
        this.riskAnalysis = {
            marketVolatility: 0,
            exchangeRisk: 0,
            liquidityRisk: 0,
            overallRisk: 0
        };
        
        this.logger = console;
    }
    
    /**
     * Inicializa el gestor de riesgos con los balances actuales
     * @param {Object} balances - Balances por exchange
     */
    initialize(balances) {
        this.portfolioValue = this.calculatePortfolioValue(balances);
        this.initialPortfolioValue = this.portfolioValue;
        this.maxPortfolioValue = this.portfolioValue;
        this.logger.info(`Risk Manager inicializado con portfolio: $${this.portfolioValue.toFixed(2)}`);
    }
    
    /**
     * Calcula el valor total del portfolio
     * @param {Object} balances - Balances por exchange
     * @returns {number} - Valor total del portfolio
     */
    calculatePortfolioValue(balances) {
        let total = 0;
        for (const exchange in balances) {
            total += balances[exchange];
        }
        return total;
    }
    
    /**
     * Actualiza el análisis de riesgo basado en las condiciones actuales
     * @param {Object} marketData - Datos del mercado
     * @param {Object} balances - Balances por exchange
     */
    updateRiskAnalysis(marketData, balances) {
        // Actualizar valor del portfolio
        this.portfolioValue = this.calculatePortfolioValue(balances);
        
        // Actualizar máximo valor del portfolio
        if (this.portfolioValue > this.maxPortfolioValue) {
            this.maxPortfolioValue = this.portfolioValue;
        }
        
        // Calcular drawdown actual
        this.currentDrawdown = (this.maxPortfolioValue - this.portfolioValue) / this.maxPortfolioValue;
        
        // Calcular volatilidad del mercado (simulado)
        const marketVolatility = this.calculateMarketVolatility(marketData);
        
        // Calcular riesgo de exchange
        const exchangeRisk = this.calculateExchangeRisk(balances);
        
        // Calcular riesgo de liquidez
        const liquidityRisk = this.calculateLiquidityRisk(marketData);
        
        // Calcular riesgo total
        const overallRisk = (marketVolatility + exchangeRisk + liquidityRisk) / 3;
        
        this.riskAnalysis = {
            marketVolatility,
            exchangeRisk,
            liquidityRisk,
            overallRisk
        };
        
        return this.riskAnalysis;
    }
    
    /**
     * Calcula la volatilidad del mercado
     * @param {Object} marketData - Datos del mercado
     * @returns {number} - Porcentaje de volatilidad (0-100)
     */
    calculateMarketVolatility(marketData) {
        // Simulación de cálculo de volatilidad
        // En una implementación real, se calcularía la desviación estándar de los precios
        if (!marketData || !marketData.volatility) {
            return Math.random() * 30 + 10; // Valor aleatorio entre 10 y 40
        }
        
        return marketData.volatility * 100;
    }
    
    /**
     * Calcula el riesgo asociado a los exchanges
     * @param {Object} balances - Balances por exchange
     * @returns {number} - Porcentaje de riesgo (0-100)
     */
    calculateExchangeRisk(balances) {
        if (!balances) return 30; // Valor por defecto
        
        let totalRisk = 0;
        let totalBalance = 0;
        
        for (const exchange in balances) {
            const balance = balances[exchange];
            const riskScore = this.exchangeRiskScores[exchange] || 1;
            
            totalRisk += balance * riskScore;
            totalBalance += balance;
        }
        
        // Normalizar a un porcentaje (0-100)
        return totalBalance > 0 ? (totalRisk / totalBalance) * 25 : 30;
    }
    
    /**
     * Calcula el riesgo de liquidez
     * @param {Object} marketData - Datos del mercado
     * @returns {number} - Porcentaje de riesgo (0-100)
     */
    calculateLiquidityRisk(marketData) {
        // Simulación de cálculo de riesgo de liquidez
        // En una implementación real, se analizarían los libros de órdenes
        if (!marketData || !marketData.liquidityScore) {
            return Math.random() * 40 + 20; // Valor aleatorio entre 20 y 60
        }
        
        return (1 - marketData.liquidityScore) * 100;
    }
    
    /**
     * Evalúa si una oportunidad de arbitraje cumple con los criterios de riesgo
     * @param {Object} opportunity - Oportunidad de arbitraje
     * @param {Object} balances - Balances por exchange
     * @returns {boolean} - True si la oportunidad es aceptable
     */
    evaluateOpportunity(opportunity, balances) {
        // Verificar si estamos en drawdown máximo
        if (this.currentDrawdown >= this.maxDrawdown) {
            this.logger.warn(`Oportunidad rechazada: Drawdown máximo alcanzado (${(this.currentDrawdown * 100).toFixed(2)}%)`);
            return false;
        }
        
        // Verificar si la exposición es demasiado alta
        const exposureAmount = opportunity.investmentAmount;
        const exposurePercentage = exposureAmount / this.portfolioValue;
        
        if (exposurePercentage > this.maxExposure) {
            this.logger.warn(`Oportunidad rechazada: Exposición demasiado alta (${(exposurePercentage * 100).toFixed(2)}%)`);
            return false;
        }
        
        // Verificar si la volatilidad del mercado es demasiado alta
        if (this.riskAnalysis.marketVolatility > this.volatilityThreshold * 100) {
            this.logger.warn(`Oportunidad rechazada: Volatilidad del mercado demasiado alta (${this.riskAnalysis.marketVolatility.toFixed(2)}%)`);
            return false;
        }
        
        // Verificar si el riesgo total es aceptable según el nivel de riesgo configurado
        const riskThreshold = this.getRiskThreshold();
        if (this.riskAnalysis.overallRisk > riskThreshold) {
            this.logger.warn(`Oportunidad rechazada: Riesgo total demasiado alto (${this.riskAnalysis.overallRisk.toFixed(2)}%)`);
            return false;
        }
        
        // Verificar si hay suficiente balance en los exchanges involucrados
        for (const exchange of opportunity.exchanges) {
            if (!balances[exchange] || balances[exchange] < opportunity.minRequiredBalance) {
                this.logger.warn(`Oportunidad rechazada: Balance insuficiente en ${exchange}`);
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Obtiene el umbral de riesgo según el nivel configurado
     * @returns {number} - Umbral de riesgo (0-100)
     */
    getRiskThreshold() {
        switch (this.riskLevel) {
            case 'low':
                return 30;
            case 'medium':
                return 50;
            case 'high':
                return 70;
            default:
                return 50;
        }
    }
    
    /**
     * Actualiza la configuración de riesgo
     * @param {Object} settings - Nuevas configuraciones
     */
    updateSettings(settings) {
        if (settings.riskLevel) {
            this.riskLevel = settings.riskLevel;
        }
        
        if (settings.maxDrawdown) {
            this.maxDrawdown = settings.maxDrawdown;
        }
        
        if (settings.maxExposure) {
            this.maxExposure = settings.maxExposure;
        }
        
        if (settings.stopLossPercentage) {
            this.stopLossPercentage = settings.stopLossPercentage;
        }
        
        if (settings.volatilityThreshold) {
            this.volatilityThreshold = settings.volatilityThreshold;
        }
        
        this.logger.info(`Configuración de riesgo actualizada: ${JSON.stringify({
            riskLevel: this.riskLevel,
            maxDrawdown: this.maxDrawdown,
            maxExposure: this.maxExposure,
            stopLossPercentage: this.stopLossPercentage,
            volatilityThreshold: this.volatilityThreshold
        })}`);
    }
    
    /**
     * Implementa un sistema de reequilibrio de fondos entre exchanges
     * @param {Object} balances - Balances actuales por exchange
     * @param {Object} exchangeManager - Gestor de exchanges para realizar transferencias
     * @returns {Object} - Resultado del reequilibrio
     */
    rebalanceFunds(balances, exchangeManager) {
        this.logger.info('Iniciando reequilibrio de fondos entre exchanges...');
        
        // Calcular el balance total y el balance promedio objetivo
        const totalBalance = this.calculatePortfolioValue(balances);
        const exchangeCount = Object.keys(balances).length;
        const targetBalance = totalBalance / exchangeCount;
        
        this.logger.info(`Balance total: $${totalBalance.toFixed(2)}, Balance objetivo por exchange: $${targetBalance.toFixed(2)}`);
        
        // Identificar exchanges con exceso y déficit de fondos
        const excessExchanges = [];
        const deficitExchanges = [];
        
        for (const exchange in balances) {
            const balance = balances[exchange];
            const difference = balance - targetBalance;
            
            // Usar un margen del 5% para evitar transferencias innecesarias
            if (difference > targetBalance * 0.05) {
                excessExchanges.push({
                    exchange,
                    balance,
                    excess: difference
                });
            } else if (difference < -targetBalance * 0.05) {
                deficitExchanges.push({
                    exchange,
                    balance,
                    deficit: -difference
                });
            }
        }
        
        // Ordenar por exceso/déficit (de mayor a menor)
        excessExchanges.sort((a, b) => b.excess - a.excess);
        deficitExchanges.sort((a, b) => b.deficit - a.deficit);
        
        // Realizar transferencias
        const transfers = [];
        let totalTransferred = 0;
        
        for (const deficitExchange of deficitExchanges) {
            let remainingDeficit = deficitExchange.deficit;
            
            for (let i = 0; i < excessExchanges.length && remainingDeficit > 0; i++) {
                const excessExchange = excessExchanges[i];
                
                if (excessExchange.excess <= 0) continue;
                
                const transferAmount = Math.min(excessExchange.excess, remainingDeficit);
                
                if (transferAmount > 0) {
                    // En una implementación real, aquí se llamaría a exchangeManager.transfer()
                    this.logger.info(`Transfiriendo $${transferAmount.toFixed(2)} de ${excessExchange.exchange} a ${deficitExchange.exchange}`);
                    
                    // Registrar la transferencia
                    transfers.push({
                        from: excessExchange.exchange,
                        to: deficitExchange.exchange,
                        amount: transferAmount
                    });
                    
                    // Actualizar los balances simulados
                    excessExchange.excess -= transferAmount;
                    remainingDeficit -= transferAmount;
                    totalTransferred += transferAmount;
                }
            }
        }
        
        this.logger.info(`Reequilibrio completado. Total transferido: $${totalTransferred.toFixed(2)}`);
        
        return {
            success: true,
            transfers,
            totalTransferred
        };
    }
    
    /**
     * Obtiene el análisis de riesgo actual
     * @returns {Object} - Análisis de riesgo
     */
    getRiskAnalysis() {
        return this.riskAnalysis;
    }
}

module.exports = AdvancedRiskManager;

--------------------------------------------------------------------------------------------------------------

const EventEmitter = require('events');

/**
 * Gestor de Estrategias
 * Maneja múltiples estrategias de arbitraje y su selección
 */
class StrategyManager {
  constructor() {
    this.config = config;
    this.activeStrategy = 'BASIC';
        this.strategyInstances = {};
        this.strategyPerformance = {};
        this.strategyHistory = [];
        
        this.logger = console;
    }
    
    /**
     * Inicializa el gestor de estrategias
     */
    initialize() {
        this.logger.info('Inicializando Strategy Manager...');
        
        try {
            // Inicializar instancias de estrategias
            this.initializeStrategies();
            
            // Inicializar métricas de rendimiento
            this.initializePerformanceMetrics();
            
            this.logger.info('Strategy Manager inicializado correctamente');
            this.logger.info(`Estrategia activa: ${this.activeStrategy}`);
        } catch (error) {
            this.logger.error('Error inicializando Strategy Manager:', error);
            throw error;
        }
    }
    
    /**
     * Inicializa las instancias de estrategias
     */
    initializeStrategies() {
        for (const strategyName in this.strategies) {
            const strategyConfig = this.strategies[strategyName];
            
            if (strategyConfig.enabled) {
                this.strategyInstances[strategyName] = new Strategy(strategyName, strategyConfig);
                this.logger.info(`Estrategia ${strategyName} inicializada`);
            }
        }
    }
    
    /**
     * Inicializa las métricas de rendimiento
     */
    initializePerformanceMetrics() {
        for (const strategyName in this.strategyInstances) {
            this.strategyPerformance[strategyName] = {
                totalOpportunities: 0,
                executedTrades: 0,
                successfulTrades: 0,
                failedTrades: 0,
                totalProfit: 0,
                averageProfit: 0,
                winRate: 0,
                averageExecutionTime: 0,
                lastUsed: null,
                score: 0
            };
        }
    }
    
    /**
     * Busca oportunidades de arbitraje básico
     * @param {Object} prices - Precios por exchange
     * @param {string} pair - Par de trading
     * @returns {Array} - Oportunidades encontradas
     */
    findBasicArbitrage(prices, pair) {
        const strategy = this.strategyInstances['BASIC'];
        if (!strategy) return [];
        
        const opportunities = [];
        const exchanges = Object.keys(prices);
        
        if (exchanges.length < 2) return opportunities;
        
        // Encontrar el precio más bajo y más alto
        let lowestPrice = Infinity;
        let highestPrice = -Infinity;
        let buyExchange = null;
        let sellExchange = null;
        
        for (const exchange of exchanges) {
            const price = prices[exchange];
            
            if (price < lowestPrice) {
                lowestPrice = price;
                buyExchange = exchange;
            }
            
            if (price > highestPrice) {
                highestPrice = price;
                sellExchange = exchange;
            }
        }
        
        // Calcular ganancia potencial
        const profitPercentage = ((highestPrice - lowestPrice) / lowestPrice) * 100;
        
        // Verificar si cumple con el mínimo requerido
        if (profitPercentage >= strategy.config.minProfitPercentage && buyExchange !== sellExchange) {
            opportunities.push({
                type: 'basic',
                strategy: 'BASIC',
                pair,
                exchanges: [buyExchange, sellExchange],
                buyExchange,
                sellExchange,
                buyPrice: lowestPrice,
                sellPrice: highestPrice,
                profitPercentage,
                investmentAmount: this.calculateInvestmentAmount('BASIC', profitPercentage),
                timestamp: new Date(),
                confidence: this.calculateConfidence('BASIC', profitPercentage)
            });
            
            // Actualizar métricas
            this.strategyPerformance['BASIC'].totalOpportunities++;
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje triangular
     * @param {Object} prices - Precios por exchange
     * @param {string} pair - Par de trading
     * @returns {Array} - Oportunidades encontradas
     */
    findTriangularArbitrage(prices, pair) {
        const strategy = this.strategyInstances['TRIANGULAR'];
        if (!strategy) return [];
        
        const opportunities = [];
        
        // En una implementación real, aquí buscaríamos oportunidades triangulares
        // Para esta implementación, simularemos algunas oportunidades
        
        if (Math.random() < 0.03) { // 3% de probabilidad
            const exchanges = Object.keys(prices);
            if (exchanges.length === 0) return opportunities;
            
            const exchange = exchanges[Math.floor(Math.random() * exchanges.length)];
            const profitPercentage = strategy.config.minProfitPercentage + Math.random() * 0.5;
            
            // Simular ruta triangular
            const baseCurrency = pair.split('/')[1]; // USDT
            const quoteCurrency = pair.split('/')[0]; // BTC
            const intermediateCurrency = 'ETH'; // Moneda intermedia
            
            opportunities.push({
                type: 'triangular',
                strategy: 'TRIANGULAR',
                pair,
                exchange,
                route: [
                    { pair: `${baseCurrency}/${intermediateCurrency}`, action: 'buy' },
                    { pair: `${quoteCurrency}/${intermediateCurrency}`, action: 'sell' },
                    { pair: pair, action: 'sell' }
                ],
                profitPercentage,
                investmentAmount: this.calculateInvestmentAmount('TRIANGULAR', profitPercentage),
                timestamp: new Date(),
                confidence: this.calculateConfidence('TRIANGULAR', profitPercentage)
            });
            
            // Actualizar métricas
            this.strategyPerformance['TRIANGULAR'].totalOpportunities++;
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje estadístico
     * @param {Object} prices - Precios por exchange
     * @param {string} pair - Par de trading
     * @returns {Array} - Oportunidades encontradas
     */
    findStatisticalArbitrage(prices, pair) {
        const strategy = this.strategyInstances['STATISTICAL'];
        if (!strategy) return [];
        
        const opportunities = [];
        
        // En una implementación real, aquí analizaríamos patrones estadísticos
        // Para esta implementación, simularemos algunas oportunidades
        
        if (Math.random() < 0.02) { // 2% de probabilidad
            const exchanges = Object.keys(prices);
            if (exchanges.length < 2) return opportunities;
            
            const exchange1 = exchanges[Math.floor(Math.random() * exchanges.length)];
            let exchange2 = exchanges[Math.floor(Math.random() * exchanges.length)];
            while (exchange2 === exchange1 && exchanges.length > 1) {
                exchange2 = exchanges[Math.floor(Math.random() * exchanges.length)];
            }
            
            const profitPercentage = strategy.config.minProfitPercentage + Math.random() * 0.3;
            const zScore = strategy.config.zScoreThreshold + Math.random();
            
            opportunities.push({
                type: 'statistical',
                strategy: 'STATISTICAL',
                pair,
                exchanges: [exchange1, exchange2],
                buyExchange: exchange1,
                sellExchange: exchange2,
                buyPrice: prices[exchange1],
                sellPrice: prices[exchange2],
                profitPercentage,
                zScore,
                meanReversion: true,
                investmentAmount: this.calculateInvestmentAmount('STATISTICAL', profitPercentage),
                timestamp: new Date(),
                confidence: this.calculateConfidence('STATISTICAL', profitPercentage)
            });
            
            // Actualizar métricas
            this.strategyPerformance['STATISTICAL'].totalOpportunities++;
        }
        
        return opportunities;
    }
    
    /**
     * Calcula la cantidad de inversión para una estrategia
     * @param {string} strategyName - Nombre de la estrategia
     * @param {number} profitPercentage - Porcentaje de ganancia esperada
     * @returns {number} - Cantidad de inversión
     */
    calculateInvestmentAmount(strategyName, profitPercentage) {
        const strategy = this.strategies[strategyName];
        if (!strategy) return 100; // Valor por defecto
        
        const maxInvestmentPercentage = strategy.maxInvestmentPercentage || 0.1;
        const baseAmount = 1000; // Balance base simulado
        
        // Ajustar inversión según la ganancia esperada
        let investmentMultiplier = 1;
        if (profitPercentage > 1.0) {
            investmentMultiplier = 1.5;
        } else if (profitPercentage > 0.5) {
            investmentMultiplier = 1.2;
        }
        
        return baseAmount * maxInvestmentPercentage * investmentMultiplier;
    }
    
    /**
     * Calcula la confianza en una oportunidad
     * @param {string} strategyName - Nombre de la estrategia
     * @param {number} profitPercentage - Porcentaje de ganancia esperada
     * @returns {number} - Nivel de confianza (0-1)
     */
    calculateConfidence(strategyName, profitPercentage) {
        const strategy = this.strategies[strategyName];
        if (!strategy) return 0.5;
        
        const minProfit = strategy.minProfitPercentage || 0.1;
        
        // Confianza base según la estrategia
        let baseConfidence;
        switch (strategyName) {
            case 'BASIC':
                baseConfidence = 0.8;
                break;
            case 'TRIANGULAR':
                baseConfidence = 0.7;
                break;
            case 'STATISTICAL':
                baseConfidence = 0.6;
                break;
            case 'ML':
                baseConfidence = 0.9;
                break;
            default:
                baseConfidence = 0.5;
        }
        
        // Ajustar confianza según la ganancia
        const profitMultiplier = Math.min(profitPercentage / minProfit, 3);
        const confidence = Math.min(baseConfidence * profitMultiplier, 1.0);
        
        return confidence;
    }
    
    /**
     * Establece la estrategia activa
     * @param {string} strategyName - Nombre de la estrategia
     */
    setActiveStrategy(strategyName) {
        if (!this.strategyInstances[strategyName]) {
            throw new Error(`Estrategia ${strategyName} no disponible`);
        }
        
        const previousStrategy = this.activeStrategy;
        this.activeStrategy = strategyName;
        
        // Registrar cambio de estrategia
        this.strategyHistory.push({
            timestamp: new Date(),
            previousStrategy,
            newStrategy: strategyName,
            reason: 'Manual'
        });
        
        // Mantener solo los últimos 100 cambios
        if (this.strategyHistory.length > 100) {
            this.strategyHistory.shift();
        }
        
        this.emit('strategyChanged', {
            previousStrategy,
            newStrategy: strategyName
        });
        
        this.logger.info(`Estrategia cambiada de ${previousStrategy} a ${strategyName}`);
    }
    
    /**
     * Actualiza las métricas de rendimiento de una estrategia
     * @param {string} strategyName - Nombre de la estrategia
     * @param {Object} tradeResult - Resultado de la operación
     */
    updateStrategyPerformance(strategyName, tradeResult) {
        if (!this.strategyPerformance[strategyName]) {
            return;
        }
        
        const performance = this.strategyPerformance[strategyName];
        
        performance.executedTrades++;
        performance.lastUsed = new Date();
        
        if (tradeResult.success) {
            performance.successfulTrades++;
            performance.totalProfit += tradeResult.profit;
        } else {
            performance.failedTrades++;
        }
        
        // Calcular métricas derivadas
        performance.winRate = performance.successfulTrades / performance.executedTrades;
        performance.averageProfit = performance.totalProfit / performance.executedTrades;
        
        // Calcular puntuación de la estrategia
        performance.score = this.calculateStrategyScore(strategyName);
        
        this.logger.info(`Rendimiento actualizado para ${strategyName}: Win Rate: ${(performance.winRate * 100).toFixed(2)}%`);
    }
    
    /**
     * Calcula la puntuación de una estrategia
     * @param {string} strategyName - Nombre de la estrategia
     * @returns {number} - Puntuación de la estrategia (0-100)
     */
    calculateStrategyScore(strategyName) {
        const performance = this.strategyPerformance[strategyName];
        if (!performance || performance.executedTrades === 0) {
            return 50; // Puntuación neutral
        }
        
        // Factores para la puntuación
        const winRateWeight = 0.4;
        const profitWeight = 0.3;
        const opportunityWeight = 0.2;
        const recentUsageWeight = 0.1;
        
        // Normalizar win rate (0-100)
        const winRateScore = performance.winRate * 100;
        
        // Normalizar ganancia promedio (0-100)
        const profitScore = Math.min(Math.max(performance.averageProfit * 10, 0), 100);
        
        // Normalizar oportunidades (0-100)
        const maxOpportunities = Math.max(...Object.values(this.strategyPerformance).map(p => p.totalOpportunities));
        const opportunityScore = maxOpportunities > 0 ? (performance.totalOpportunities / maxOpportunities) * 100 : 50;
        
        // Puntuación por uso reciente (0-100)
        const daysSinceLastUse = performance.lastUsed ? 
            (Date.now() - performance.lastUsed.getTime()) / (1000 * 60 * 60 * 24) : 30;
        const recentUsageScore = Math.max(100 - daysSinceLastUse * 3, 0);
        
        // Calcular puntuación final
        const score = (
            winRateScore * winRateWeight +
            profitScore * profitWeight +
            opportunityScore * opportunityWeight +
            recentUsageScore * recentUsageWeight
        );
        
        return Math.round(score);
    }
    
    /**
     * Recomienda la mejor estrategia basada en el rendimiento
     * @returns {string} - Nombre de la estrategia recomendada
     */
    recommendBestStrategy() {
        let bestStrategy = this.activeStrategy;
        let bestScore = 0;
        
        for (const strategyName in this.strategyPerformance) {
            const score = this.strategyPerformance[strategyName].score;
            
            if (score > bestScore) {
                bestScore = score;
                bestStrategy = strategyName;
            }
        }
        
        return bestStrategy;
    }
    
    /**
     * Obtiene estadísticas de todas las estrategias
     * @returns {Object} - Estadísticas de estrategias
     */
    getStrategyStatistics() {
        const stats = {
            activeStrategy: this.activeStrategy,
            totalStrategies: Object.keys(this.strategyInstances).length,
            performance: { ...this.strategyPerformance },
            recommendations: {
                bestStrategy: this.recommendBestStrategy(),
                worstStrategy: this.getWorstStrategy()
            },
            recentChanges: this.strategyHistory.slice(-10)
        };
        
        return stats;
    }
    
    /**
     * Obtiene la estrategia con peor rendimiento
     * @returns {string} - Nombre de la estrategia con peor rendimiento
     */
    getWorstStrategy() {
        let worstStrategy = this.activeStrategy;
        let worstScore = 100;
        
        for (const strategyName in this.strategyPerformance) {
            const score = this.strategyPerformance[strategyName].score;
            
            if (score < worstScore) {
                worstScore = score;
                worstStrategy = strategyName;
            }
        }
        
        return worstStrategy;
    }
    
    /**
     * Habilita o deshabilita una estrategia
     * @param {string} strategyName - Nombre de la estrategia
     * @param {boolean} enabled - Estado de habilitación
     */
    setStrategyEnabled(strategyName, enabled) {
        if (!this.strategies[strategyName]) {
            throw new Error(`Estrategia ${strategyName} no existe`);
        }
        
        this.strategies[strategyName].enabled = enabled;
        
        if (enabled && !this.strategyInstances[strategyName]) {
            // Inicializar estrategia si se habilita
            this.strategyInstances[strategyName] = new Strategy(strategyName, this.strategies[strategyName]);
            this.initializePerformanceMetrics();
        } else if (!enabled && this.strategyInstances[strategyName]) {
            // Remover estrategia si se deshabilita
            delete this.strategyInstances[strategyName];
            
            // Si era la estrategia activa, cambiar a otra
            if (this.activeStrategy === strategyName) {
                const availableStrategies = Object.keys(this.strategyInstances);
                if (availableStrategies.length > 0) {
                    this.setActiveStrategy(availableStrategies[0]);
                }
            }
        }
        
        this.logger.info(`Estrategia ${strategyName} ${enabled ? 'habilitada' : 'deshabilitada'}`);
    }
    
    /**
     * Obtiene la configuración de una estrategia
     * @param {string} strategyName - Nombre de la estrategia
     * @returns {Object} - Configuración de la estrategia
     */
    getStrategyConfig(strategyName) {
        return this.strategies[strategyName] || null;
    }
    
    /**
     * Actualiza la configuración de una estrategia
     * @param {string} strategyName - Nombre de la estrategia
     * @param {Object} newConfig - Nueva configuración
     */
    updateStrategyConfig(strategyName, newConfig) {
        if (!this.strategies[strategyName]) {
            throw new Error(`Estrategia ${strategyName} no existe`);
        }
        
        this.strategies[strategyName] = { ...this.strategies[strategyName], ...newConfig };
        
        // Actualizar instancia si existe
        if (this.strategyInstances[strategyName]) {
            this.strategyInstances[strategyName].updateConfig(newConfig);
        }
        
        this.logger.info(`Configuración de estrategia ${strategyName} actualizada`);
    }
}

/**
 * Clase Strategy
 * Representa una estrategia individual
 */
class Strategy {
    constructor(name, config) {
        this.name = name;
        this.config = config;
        this.isActive = false;
        this.lastExecution = null;
    }
    
    /**
     * Actualiza la configuración de la estrategia
     * @param {Object} newConfig - Nueva configuración
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    
    /**
     * Ejecuta la estrategia
     * @param {Object} marketData - Datos del mercado
     * @returns {Array} - Oportunidades encontradas
     */
    execute(marketData) {
        this.lastExecution = new Date();
        // Implementación específica de cada estrategia
        return [];
    }
}
module.exports = StrategyManager

---------------------------------------------------------------------------------------------------------

UTILS

/*
  Lógica avanzada del bot:

  1. Para cada par/token:
      - Verifica si está habilitado y si la red está activa.
      - Solo opera si hay suficiente volumen (min_trade, max_trade).
      - Calcula el spread actual y compara con min_spread configurado.
      - Calcula el slippage estimado y compara con max_slippage.
      - Suma todos los fees (trading + retiro en ambos exchanges).
      - Solo ejecuta la operación si la ganancia neta (spread - fees - slippage) es positiva.
      - Si algún parámetro está fuera del rango recomendado, loguea advertencia.
      - Revisa cada 12h la configuración y el estado de cada token (puede ser con un cron que actualice el estado y muestre en frontend).
*/

#----------botlogic-------------

------------------------------------------------------------------------------------------------------

async function getPairVolume(pair, exchange) {
  let url;
  let symbol;

  // Formato de símbolo según exchange
  if (exchange === "BINANCE") {
    symbol = pair.replace("/", "");
    url = `https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`;
  } else if (exchange === "BYBIT") {
    // Bybit usa guión bajo y mayúsculas para spot, y símbolo especial para derivados
    symbol = pair.replace("/", "");
    // API spot Bybit (https://api.bybit.com/v5/market/tickers?category=spot&symbol=BTCUSDT)
    url = `https://api.bybit.com/v5/market/tickers?category=spot&symbol=${symbol}`;
  } else {
    throw new Error("Exchange no soportado");
  }

  const res = await fetch(url);
  if (!res.ok) throw new Error(`Error consultando ${exchange}: ${res.statusText}`);
  const data = await res.json();

  if (exchange === "BINANCE") {
    return parseFloat(data.quoteVolume); // en USDT
  }

  if (exchange === "BYBIT") {
    // Bybit responde en: data.result.list[0].quoteVolume
    if (
      data &&
      data.result &&
      Array.isArray(data.result.list) &&
      data.result.list.length > 0
    ) {
      return parseFloat(data.result.list[0].quoteVolume);
    } else {
      throw new Error("No se pudo obtener el volumen para " + pair + " en Bybit");
    }
  }
}

// Ejemplo de uso:
// const volBinance = await getPairVolume("BTC/USDT", "BINANCE");
// const volBybit = await getPairVolume("BTC/USDT", "BYBIT");

#------utils-------------------

---------------------------------------------------------------------------------------------------
const axios = require("axios");

async function getBinanceSpotPairsUSDT() {
  const url = "https://api.binance.com/api/v3/exchangeInfo";
  const res = await axios.get(url);
  return res.data.symbols
    .filter(s => s.quoteAsset === "USDT" && s.status === "TRADING" && s.isSpotTradingAllowed)
    .map(s => s.symbol);
}

async function getBybitSpotPairsUSDT() {
  const url = "https://api.bybit.com/v5/market/instruments-info?category=spot";
  const res = await axios.get(url);
  return res.data.result.list
    .filter(s => s.quoteCoin === "USDT" && s.status === "Trading")
    .map(s => s.symbol);
}

async function main() {
  const [binancePairs, bybitPairs] = await Promise.all([
    getBinanceSpotPairsUSDT(),
    getBybitSpotPairsUSDT()
  ]);

  // Solo los pares que existen en ambos exchanges
  const binanceSet = new Set(binancePairs);
  const bybitSet = new Set(bybitPairs);

  const arbitrable = [...binanceSet].filter(pair => bybitSet.has(pair));

  console.log("Pares arbitrables entre Binance y Bybit con USDT:");
  arbitrable.sort().forEach(pair => console.log(pair));
}

main().catch(console.error);
-------------------------------------------------------------------------------------------------------
const EventEmitter = require("events")
const ExchangeManager = require("./src/exchanges/exchange-manager")
const AlertManager = require("./src/alerts/alert-manager")

/**
 * Bot de Arbitraje para Exchanges CEX
 */
class ArbitrageBot extends EventEmitter {
  constructor(config) {
    super()
    this.config = config
    this.isRunning = false
    this.mode = "simulation" // "simulation" o "production"
    this.strategy = "basic"
    this.riskLevel = config.RISK_MANAGEMENT.RISK_LEVEL
    this.tradingPairs = config.TRADING_PAIRS
    this.checkInterval = config.CHECK_INTERVAL
    this.totalProfit = 0
    this.totalTrades = 0
    this.successfulTrades = 0
    this.failedTrades = 0
    this.lastOpportunities = {}
    this.checkIntervalId = null
    this.logger = console

    // Inicializar gestores
    this.exchangeManager = new ExchangeManager(config)
    this.alertManager = new AlertManager(config)

    // ====== AGREGADO PARA DASHBOARD ======
    this.simulation = true
  }

  /**
   * Inicia el bot
   */
  async start(mode = "simulation") {
    try {
      if (this.isRunning) {
        this.logger.warn("⚠️ El bot ya está en ejecución")
        return
      }

      this.mode = mode
      this.simulation = mode === "simulation"
      this.logger.info(`🚀 Iniciando bot en modo: ${this.mode}`)

      // Inicializar componentes
      await this.initialize()

      // Enviar alerta de inicio
      await this.alertManager.sendAlert(
        "BOT_STARTED",
        `🤖 Bot de Arbitraje iniciado en modo ${this.mode.toUpperCase()}`,
      )

      // Iniciar verificación periódica
      this.startPeriodicCheck()

      this.isRunning = true
      this.emit("started", { mode: this.mode })

      return true
    } catch (error) {
      this.logger.error("❌ Error al iniciar bot:", error.message)

      // Enviar alerta de error
      await this.alertManager.sendAlert("ERROR", `Error al iniciar bot: ${error.message}`)

      throw error
    }
  }

  /**
   * Detiene el bot
   */
  async stop() {
    try {
      if (!this.isRunning) {
        this.logger.warn("⚠️ El bot no está en ejecución")
        return
      }

      this.logger.info("🛑 Deteniendo bot...")

      // Detener verificación periódica
      this.stopPeriodicCheck()

      // Enviar alerta de detención
      await this.alertManager.sendAlert("BOT_STOPPED", "🛑 Bot de Arbitraje detenido")

      this.isRunning = false
      this.emit("stopped")

      return true
    } catch (error) {
      this.logger.error("❌ Error al detener bot:", error.message)
      throw error
    }
  }

  /**
   * Cambia la estrategia del bot
   */
  changeStrategy(strategy) {
    if (!this.config.STRATEGIES[strategy.toUpperCase()]) {
      throw new Error(`Estrategia ${strategy} no válida`)
    }

    this.strategy = strategy
    this.logger.info(`🔄 Estrategia cambiada a: ${strategy}`)
    this.emit("strategyChanged", { strategy })

    return true
  }

  /**
   * Actualiza la configuración de riesgo
   */
  updateRiskSettings(settings) {
    if (settings.riskLevel) {
      this.riskLevel = settings.riskLevel
      this.logger.info(`🔄 Nivel de riesgo cambiado a: ${settings.riskLevel}`)
    }

    this.emit("riskSettingsUpdated", settings)
    return true
  }

  /**
   * Inicializa los componentes del bot
   */
  async initialize() {
    try {
      // Inicializar AlertManager
      await this.alertManager.initialize()

      // Inicializar ExchangeManager
      await this.exchangeManager.initialize()

      return true
    } catch (error) {
      this.logger.error("❌ Error inicializando componentes:", error.message)
      throw error
    }
  }

  /**
   * Inicia la verificación periódica de oportunidades
   */
  startPeriodicCheck() {
    if (this.checkIntervalId) {
      clearInterval(this.checkIntervalId)
    }

    this.checkIntervalId = setInterval(() => {
      this.checkOpportunities().catch((error) => {
        this.logger.error("❌ Error en verificación periódica:", error.message)
      })
    }, this.checkInterval)

    this.logger.info(`🔄 Verificación periódica iniciada (cada ${this.checkInterval}ms)`)
  }

  /**
   * Detiene la verificación periódica
   */
  stopPeriodicCheck() {
    if (this.checkIntervalId) {
      clearInterval(this.checkIntervalId)
      this.checkIntervalId = null
      this.logger.info("🛑 Verificación periódica detenida")
    }
  }

  /**
   * Verifica oportunidades de arbitraje
   */
  async checkOpportunities() {
    try {
      this.logger.debug("🔍 Verificando oportunidades de arbitraje...")

      // Obtener precios de todos los pares
      const prices = await this.fetchPrices()

      // Calcular oportunidades
      const opportunities = this.calculateArbitrageOpportunities(prices)

      // Actualizar últimas oportunidades
      this.lastOpportunities = opportunities

      // Verificar si hay oportunidades viables
      const viableOpportunities = this.filterViableOpportunities(opportunities)

      if (viableOpportunities.length > 0) {
        this.logger.info(`🎯 Encontradas ${viableOpportunities.length} oportunidades viables`)

        // Enviar alerta para cada oportunidad
        for (const opportunity of viableOpportunities) {
          await this.alertManager.sendAlert(
            "OPPORTUNITY_FOUND",
            `🎯 Oportunidad: ${opportunity.pair}\n💰 Ganancia: ${opportunity.profitPercentage.toFixed(2)}%\n📈 Comprar en: ${opportunity.buyExchange}\n📉 Vender en: ${opportunity.sellExchange}`,
          )
        }

        // Ejecutar arbitraje si está en modo producción y está configurado para auto-ejecutar
        if (this.mode === "production" && this.config.STRATEGIES[this.strategy.toUpperCase()].autoExecute) {
          for (const opportunity of viableOpportunities) {
            await this.executeArbitrage(opportunity)
          }
        }
      }

      return opportunities
    } catch (error) {
      this.logger.error("❌ Error verificando oportunidades:", error.message)
      throw error
    }
  }

  /**
   * Obtiene precios de todos los exchanges
   */
  async fetchPrices() {
    const prices = {}

    for (const pair of this.tradingPairs) {
      prices[pair] = {}

      for (const exchangeName of this.exchangeManager.getEnabledExchangeNames()) {
        try {
          const ticker = await this.exchangeManager.getTicker(exchangeName, pair)

          prices[pair][exchangeName] = {
            bid: ticker.bid,
            ask: ticker.ask,
            last: ticker.last,
            volume: ticker.baseVolume,
            timestamp: ticker.timestamp,
          }
        } catch (error) {
          this.logger.warn(`⚠️ Error obteniendo precio de ${pair} en ${exchangeName}: ${error.message}`)
        }
      }
    }

    return prices
  }

  /**
   * Calcula oportunidades de arbitraje
   */
  calculateArbitrageOpportunities(prices) {
    const opportunities = []

    for (const [pair, exchangePrices] of Object.entries(prices)) {
      const exchanges = Object.keys(exchangePrices)

      if (exchanges.length < 2) {
        continue
      }

      // Encontrar mejor compra (menor ask) y mejor venta (mayor bid)
      let bestBuy = { exchange: null, price: Number.POSITIVE_INFINITY }
      let bestSell = { exchange: null, price: 0 }

      for (const [exchange, priceData] of Object.entries(exchangePrices)) {
        if (priceData.ask && priceData.ask < bestBuy.price) {
          bestBuy = { exchange, price: priceData.ask }
        }

        if (priceData.bid && priceData.bid > bestSell.price) {
          bestSell = { exchange, price: priceData.bid }
        }
      }

      // Verificar si hay oportunidad
      if (bestBuy.exchange && bestSell.exchange && bestBuy.exchange !== bestSell.exchange) {
        const profitPercentage = ((bestSell.price - bestBuy.price) / bestBuy.price) * 100
        const fees = this.calculateFees(bestBuy.exchange, bestSell.exchange, bestBuy.price, bestSell.price)
        const netProfitPercentage = profitPercentage - fees.totalFeePercentage

        opportunities.push({
          pair,
          buyExchange: bestBuy.exchange,
          sellExchange: bestSell.exchange,
          buyPrice: bestBuy.price,
          sellPrice: bestSell.price,
          profitPercentage,
          fees,
          netProfitPercentage,
          timestamp: Date.now(),
        })
      }
    }

    return opportunities
  }

  /**
   * Filtra oportunidades viables según la estrategia actual
   */
  filterViableOpportunities(opportunities) {
    const strategy = this.config.STRATEGIES[this.strategy.toUpperCase()]
    const minProfitPercentage = strategy.minProfitPercentage

    return opportunities.filter((opportunity) => {
      // Verificar si la ganancia neta supera el mínimo
      return opportunity.netProfitPercentage >= minProfitPercentage
    })
  }

  /**
   * Calcula las comisiones para una operación de arbitraje
   */
  calculateFees(buyExchange, sellExchange, buyPrice, sellPrice) {
    const buyFeeRate = this.config.EXCHANGES[buyExchange.toUpperCase()]?.fees?.taker || 0.001
    const sellFeeRate = this.config.EXCHANGES[sellExchange.toUpperCase()]?.fees?.taker || 0.001

    const buyFee = buyPrice * buyFeeRate
    const sellFee = sellPrice * sellFeeRate
    const totalFee = buyFee + sellFee
    const totalFeePercentage = (buyFeeRate + sellFeeRate) * 100

    return {
      buyFee,
      sellFee,
      totalFee,
      totalFeePercentage,
      buyFeeRate,
      sellFeeRate,
    }
  }

  /**
   * Ejecuta una operación de arbitraje
   */
  async executeArbitrage(opportunity) {
    try {
      this.logger.info(`🚀 Ejecutando arbitraje: ${opportunity.pair}`)

      // Calcular cantidad a comprar según la configuración
      const strategy = this.config.STRATEGIES[this.strategy.toUpperCase()]
      const maxInvestmentPercentage = strategy.maxInvestmentPercentage

      // Obtener balance disponible
      const balance = await this.exchangeManager.getBalance(opportunity.buyExchange, "USDT")
      const availableBalance = balance.free

      // Calcular cantidad a invertir
      const investmentAmount = availableBalance * maxInvestmentPercentage
      const buyAmount = investmentAmount / opportunity.buyPrice

      // Ejecutar compra
      let buyOrder
      if (this.mode === "production") {
        buyOrder = await this.exchangeManager.buy(opportunity.buyExchange, opportunity.pair, buyAmount)
      } else {
        // Simular compra
        buyOrder = {
          id: `sim_${Date.now()}`,
          amount: buyAmount,
          price: opportunity.buyPrice,
          cost: buyAmount * opportunity.buyPrice,
          status: "closed",
        }
      }

      // Antes de arbitrar...
async function checkOpportunity(pair, amount) {
  // 1. Revisa volumen del par (¡clave para que no muevas el precio!)
  const volume = await getPairVolume(pair);
  if (volume < amount * 10) return false; // Ejemplo: solo arbitra si hay 10x más volumen que tu operación

  // 2. Calcula fees por token y exchange (usa FEES_AND_LIMITS[exchange][token])
  const binanceFees = config.FEES_AND_LIMITS.BINANCE[pair.split('/')[0]];
  const bybitFees = config.FEES_AND_LIMITS.BYBIT[pair.split('/')[0]];
  // Aplica la lógica específica por token/fee

  // 3. Calcula si el spread - fees - slippage te deja ganancia neta positiva
  // Si no, ignora la oportunidad

  // 4. Si la red/token está suspendido o en mantenimiento (revisa cada 12h llamando a la API del exchange)
  //   - Si está suspendida, ignora el par y márcalo como inactivo
  //   - Puedes guardar un timestamp y solo volver a intentarlo después de 12h

  // 5. Si todo está OK, agrega la oportunidad a la lista de oportunidades y ejecuta
}

      this.logger.info(`✅ Compra ejecutada en ${opportunity.buyExchange}: ${buyAmount} a $${opportunity.buyPrice}`)

      // Ejecutar venta
      let sellOrder
      if (this.mode === "production") {
        sellOrder = await this.exchangeManager.sell(opportunity.sellExchange, opportunity.pair, buyAmount)
      } else {
        // Simular venta
        sellOrder = {
          id: `sim_${Date.now() + 1}`,
          amount: buyAmount,
          price: opportunity.sellPrice,
          cost: buyAmount * opportunity.sellPrice,
          status: "closed",
        }
      }

      this.logger.info(`✅ Venta ejecutada en ${opportunity.sellExchange}: ${buyAmount} a $${opportunity.sellPrice}`)

      // Calcular ganancia
      const profit = (sellOrder.price - buyOrder.price) * buyAmount
      this.totalProfit += profit
      this.totalTrades++
      this.successfulTrades++

      // Enviar alerta de operación exitosa
      await this.alertManager.sendAlert(
        "TRADE_EXECUTED",
        `💰 Arbitraje ejecutado: ${opportunity.pair}\n📈 Compra: ${buyAmount} a $${opportunity.buyPrice} en ${opportunity.buyExchange}\n📉 Venta: ${buyAmount} a $${opportunity.sellPrice} en ${opportunity.sellExchange}\n💵 Ganancia: $${profit.toFixed(2)}`,
      )

      this.emit("arbitrageExecuted", {
        opportunity,
        buyOrder,
        sellOrder,
        profit,
      })

      return {
        success: true,
        profit,
        buyOrder,
        sellOrder,
      }
    } catch (error) {
      this.logger.error(`❌ Error ejecutando arbitraje: ${error.message}`)

      this.totalTrades++
      this.failedTrades++

      // Enviar alerta de error
      await this.alertManager.sendAlert(
        "TRADE_FAILED",
        `❌ Error en arbitraje: ${opportunity.pair}\n💰 Ganancia esperada: ${opportunity.netProfitPercentage.toFixed(2)}%\n⚠️ Error: ${error.message}`,
      )

      this.emit("arbitrageFailed", {
        opportunity,
        error: error.message,
      })

      throw error
    }
  }

  /**
   * Obtiene el estado actual del bot
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      mode: this.mode,
      strategy: this.strategy,
      riskLevel: this.riskLevel,
      totalProfit: this.totalProfit,
      totalTrades: this.totalTrades,
      successfulTrades: this.successfulTrades,
      failedTrades: this.failedTrades,
      tradingPairs: this.tradingPairs,
      checkInterval: this.checkInterval,
      lastCheck: Date.now(),
      // ====== AGREGADO PARA DASHBOARD ======
      simulation: this.simulation
    }
  }

  // ====== AGREGADO PARA DASHBOARD Y API ======
  setSimulationMode(sim) {
    this.simulation = !!sim
    this.mode = this.simulation ? "simulation" : "production"
  }
  isSimulation() {
    return this.simulation
  }
  getLiveOpportunities() {
    // Devuelve las últimas oportunidades encontradas
    if (Array.isArray(this.lastOpportunities)) {
      return this.lastOpportunities
    }
    // Si está en formato objeto, convertir a array
    return Object.values(this.lastOpportunities)
  }
  isRunningBot() {
    return this.isRunning
  }
}

module.exports = ArbitrageBot;

----------------------------------------------------------------------------------------------------
async function isOpportunityProfitable(pair, amount, prices, config) {
  // 1. Revisa volumen real
  const volume = await getPairVolume(pair);
  if (volume < amount * 10) return false; // Solo arbitra si hay volumen suficiente
  
  // 2. Obtiene parámetros específicos del par o toma globales
  const parRisk = config.PAIR_RISK[pair] || config.GLOBAL_RISK;
  const feeA = config.FEES_AND_LIMITS.BINANCE[pair.split('/')[0]].withdrawal.fee;
  const feeB = config.FEES_AND_LIMITS.BYBIT[pair.split('/')[0]].withdrawal.fee;
  const spread = (prices.BYBIT - prices.BINANCE) / prices.BINANCE;
  
  // 3. Calcula la ganancia neta real (spread - fees - slippage)
  const cost = feeA + feeB + (parRisk.maxSlippage * 2) + config.TRADING_FEES.BINANCE + config.TRADING_FEES.BYBIT;
  if (spread < parRisk.minSpread + cost) return false;
  
  // 4. Revisa si la red/token está activa (llama a la API del exchange cada 12h)
  if (!await isTokenActive(pair.split('/')[0], "BINANCE") || !await isTokenActive(pair.split('/')[0], "BYBIT")) {
    return false;
  }
  // 5. Si todo OK, la oportunidad es válida
  return true;
}

------------------------------------------------------------------------------------------------------------

const { Spot } = require('@binance/connector');

const apiKey = 'qQ9F6OyRjH7uzeiThURx722WLB5LD080DS7JDG4QpAPYZLeTGjgnn1vucNqcwmm0';
const apiSecret = 'PP0l9KKVa30To898958itxWPU99auRIWxzpcrgptZ1NXURENvb8f0nCaY8JI0qQx';

const client = new Spot(apiKey, apiSecret);

async function test() {
  try {
    const resp = await client.tickerPrice();
    console.log("RESULTADO DE BINANCE:", resp.data);
    if (Array.isArray(resp.data)) {
      console.log("Primer elemento:", resp.data[0]);
    } else {
      console.log("NO ES UN ARRAY:", resp.data);
    }
  } catch (err) {
    console.error("ERROR:", err);
  }
}

test();

-----------------------------------------------------------------------------------------------------

const { RestClientV5 } = require('bybit-api');

const bybit = new RestClientV5({
  // Puedes dejar vacío para spot público
  // key: 'TU_API_KEY',
  // secret: 'TU_API_SECRET',
});

async function main() {
  try {
    // Pide TODOS los tickers spot
    const res = await bybit.getTickers({ category: "spot" });
    console.log(JSON.stringify(res, null, 2));
  } catch (err) {
    console.error("ERROR:", err);
  }
}

main();

---------------------------------------------------------------------------------------------------------

module.exports = {
  // 1. PAIRS TO MONITOR
  PAIRS: [
    "LTC/USDT", "BNB/USDT", "XRP/USDT", "ALGO/USDT", "ANIME/USDT", "APT/USDT", "ARB/USDT", "ATOM/USDT", "AVAX/USDT",
    "AXL/USDT", "BB/USDT", "BEL/USDT", "BERA/USDT", "BOME/USDT", "BONK/USDT", "C98/USDT", "CAKE/USDT", "CATI/USDT", 
    "CELO/USDT", "CGPT/USDT", "CHZ/USDT", "CYBER/USDT", "DOGS/USDT", "DOT/USDT", "DYDX/USDT", "EGLD/USDT", "ENJ/USDT",
    "FIDA/USDT", "FLOKI/USDT", "FLOW/USDT", "GMT/USDT", "GMX/USDT", "HAEDAL/USDT", "HBAR/USDT", "HMSTR/USDT", "HOME/USDT",
    "HYPER/USDT", "ICP/USDT", "ICX/USDT", "INJ/USDT", "IO/USDT", "JUP/USDT", "KAIA/USDT", "KMNO/USDT", "KSM/USDT",
    "LUNA/USDT", "MAGIC/USDT", "MANTA/USDT", "MBOX/USDT", "MINA/USDT", "NEAR/USDT", "NOT/USDT", "ONE/USDT", "OP/USDT",
    "PSG/USDT", "PYTH/USDT", "RDNT/USDT", "ROSE/USDT", "SCRT/USDT", "SEI/USDT", "SHIB/USDT", "SIGN/USDT", "STX/USDT",
    "SUI/USDT", "TIA/USDT", "TNSR/USDT", "TON/USDT", "TRUMP/USDT", "TRX/USDT", "WAXP/USDT", "WCT/USDT", "WIF/USDT",
    "WLD/USDT", "XAI/USDT", "XLM/USDT", "ZIL/USDT", "ZRO/USDT"
  ],

  BASE_ASSET: "USDT",

  // 2. DEPOSIT ADDRESSES AND NETWORKS
  DEPOSIT_ADDRESSES: {
    BINANCE: {
      USDT: { address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb", memo: "163771801", network: "TON" },
      LTC:  { address: "LiCH4dMWM6YRHFWYC78hppAk1SwUFkDAK4", network: "Litecoin" },
      BNB:  { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      XRP:  { address: "rNxp4h8apvRis6mJf9Sh8C6iRxfrDWN7AV", memo: "466152795", network: "XRP" },
      ALGO: { address: "L43SHHRVHAIYHGFGXFBKM7IMZNYT7WSLSMXPHGNH4D5NPYOBIJSK35X5OE", network: "ALGO" },
      ANIME: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" },
      APT: { address: "0x0b69478291cb55e808a716a046cc0d1ab2981e85778957da3fd519c6061ccb9e", network: "APT" },
      ARB: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" },
      ATOM: { address: "cosmos1j8pp7zvcu9z8vd882m284j29fn2dszh05cqvf9", memo: "100738176", network: "ATOM" },
      AVAX: { address: "X-avax1j2suzh09083n9cyd80dk3lsr0c3e8ry3skk27q", network: "AVAX" },
      AXL: { address: "axelar17ewha7y7fr0xsej6xfep88rq30rse9hgynll78", memo: "101408734", network: "AXL" },
      BB: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BounceBit" },
      BEL: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      BERA: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BERA" },
      BOME: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      BONK: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      C98: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      CAKE: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      CATI: { address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb", memo: "163771801", network: "TON" },
      CELO: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "CELO" },
      CGPT: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      CHZ: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "CHZ2" },
      CYBER: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "OPTIMISM" },
      DOGS: { address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb", memo: "163771801", network: "TON" },
      DOT: { address: "12zByesGXudgBh4C6ZRbF82SkEAwxC6viaTZwg6BbkWABuT5", network: "DOT" },
      DYDX: { address: "dydx1vvl7htcnzc3g0hsrysxf3vvrk6tpx70822ef6g", memo: "100903728", network: "DYDX" },
      EGLD: { address: "erd1ecw70t7jjw77c6sdmesz2quzlxwv87tv983970wlr8gchy0sqv8sp8ef3k", network: "EGLD" },
      ENJ: { address: "enExKScymYYPkj9tzvgs4UFDCEVCyWuJi7zVAdwuAsF5jokn5", network: "ENJ" },
      FIDA: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      FLOKI: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      FLOW: { address: "0x94ad1c8825ca243d", network: "FLOW" },
      GMT: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      GMX: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" },
      HAEDAL: { address: "0xd03819773837ad71e19c3903561d61a5ae7cb7035ade1c841d84f23040ea79f4", network: "SUI" },
      HBAR: { address: "0.0.1873771", memo: "103878176", network: "HBAR" },
      HMSTR: { address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb", memo: "163771801", network: "TON" },
      HOME: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      HYPER: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      ICP: { address: "3cb40b0fb786925bc5e4f5cf4e4d7c5d617a70fdefa8e483487d076b65c50151", network: "ICP" },
      ICX: { address: "hx5ff80447faff8dfb5193ff420c35b72535282f3d", network: "ICX" },
      INJ: { address: "inj1u2rajhqtptzvu23leheta9yg99k3hazf4waf43", memo: "105901031", network: "INJ" },
      IO: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      JUP: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      KAIA: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "KAIA" },
      KMNO: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      KSM: { address: "G8AjQrZs9CfPYiTCjkS75r2tHQPqxK1bNagLefLa4QvHGCQ", network: "KSM" },
      LUNA: { address: "terra1frh79vmtur5fmrghz6gfjvfhpa3u2c0uemv4af", memo: "103811345", network: "LUNA" },
      MAGIC: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" },
      MANTA: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "MANTA" },
      MBOX: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      MINA: { address: "B62qkTezzMtbX71ZnR74N4JAs1LT4jvacx2aLJR9yPFzdtDqA3dGLQD", network: "MINA" },
      NEAR: { address: "836da29a0b7172bf48cb1cb5466d29adc0aac38904a091e64b71e66539ab984b", network: "NEAR" },
      NOT: { address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb", memo: "163771801", network: "TON" },
      ONE: { address: "one1hwlkh335c6k6w8eugsj9f2qkjvxuk5q59z0m8s", network: "ONE" },
      OP: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "OPTIMISM" },
      PSG: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "CHZ2" },
      PYTH: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      RDNT: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" },
      ROSE: { address: "oasis1qz0f26wkrt5852xcghrnr52rwgk30jwxcq3lwcee", network: "ROSE" },
      SCRT: { address: "secret13fh085csr7w7e866r402cqa9xp42trsch7w269", memo: "101301675", network: "SCRT" },
      SEI: { address: "sei1zrqryvr8m40yqej95lcqzw7y0sf0662cxh0kcv", memo: "100286985", network: "SEI" },
      SHIB: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      SIGN: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "BSC" },
      STX: { address: "SP2TA4FGB43WVAS8MVS6YCWTSN2BZNQ1ASGEAKSDD", memo: "103289850", network: "STX" },
      SUI: { address: "0xd03819773837ad71e19c3903561d61a5ae7cb7035ade1c841d84f23040ea79f4", network: "SUI" },
      TIA: { address: "celestia1fd3mclxp4e2fh0wpau3eg55x2fsm7yjxzg29j2", memo: "105643806", network: "TIA" },
      TON: { address: "EQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xNJb", memo: "163771801", network: "TON" },
      TRUMP: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      TRX: { address: "TNZx9MUo2Db4xLT9zVe17NqwconpaaWwDq", network: "TRX" },
      WAXP: { address: "waxonbinance", memo: "106691034", network: "WAX" },
      WIF: { address: "9EjbLHoyqH9SzVJZhvFSPFfmoY38C4DJ78WdJtr46RKa", network: "SOL" },
      WCT: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "OPTIMISM" },
      WLD: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "OPTIMISM" },
      XAI: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" },
      XLM: { address: "GABFQIK63R2NETJM7T673EAMZN4RJLLGP3OFUEJU5SZVTGWUKULZJNL6", memo: "380362871", network: "XLM" },
      ZIL: { address: "zil1ldwp360uz36800cr5n73gtm0fjxmrn8sr4r3uq", network: "ZIL" },
      ZRO: { address: "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7", network: "ARBITRUM" }
    },
    BYBIT: {
  USDT: { address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB", network: "TON" },
  LTC: { address: "LLCxH3L5fn9ejTPVk3nWTJcqvvTWsu2LbJ", network: "Litecoin" },
  BNB: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  XRP: { address: "rJn2zAPdFA193sixJwuFixRkYDUtx3apQh", memo: "501350199", network: "XRP" },
  ALGO: { address: "U5EPBBGTH4ZHEJMSYWRRBEOTOORYTSTSTYZITGDYM2KUQPDXWTHFDJPFVY", network: "ALGO" },
  ANIME: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "ARBI" },
  APT: { address: "0x9f5ade930d03eb3fd1f0906f4e7edaddc458ac71260bf985bb61cfb61ac09191", network: "APTOS" },
  ARB: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Arbitrum One" },
  ATOM: { address: "cosmos1c8dskmuz2wj29tg3rygt8mzg92f09gwcqqyexa", network: "ATOM" },
  AVAX: { address: "X-avax1unlvn8ef6lpjsac0t37t9za6astc8a55pugnm2", network: "AVAX" },
  AXL: { address: "axelar1yzsury9fldydgk425gmphy2zyehh3emc43ds6x", memo: "10048670", network: "AXL" },
  BB: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BounceBit" },
  BEL: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  BERA: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BERA" },
  BOME: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  BONK: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  C98: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  CAKE: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  CATI: { address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB", network: "TON" },
  CELO: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "CELO" },
  CGPT: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  CHZ: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Chiliz Chain" },
  CYBER: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "OP Mainnet" },
  DOGS: { address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB", network: "TON" },
  DOT: { address: "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm", network: "DOT" },
  DYDX: { address: "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq", memo: "10178277", network: "DYDX" },
  EGLD: { address: "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4", network: "EGLD" },
  ENJ: { address: "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i", network: "Enjin" },
  FIDA: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  FLOKI: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  FLOW: { address: "0xdbb61e402a382eb3", network: "FLOW" },
  GMT: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  GMX: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "AVAXC" },
  HAEDAL: { address: "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c", network: "SUI" },
  HBAR: { address: "0.0.615422", memo: "10067078", network: "HBAR" },
  HMSTR: { address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB", network: "TON" },
  HOME: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  HYPER: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  ICP: { address: "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a", network: "ICP" },
  ICX: { address: "hx8c278a658331a569b640e925ac55a70a8e5534b6", network: "ICX" },
  INJ: { address: "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n", memo: "10014232", network: "INJ" },
  IO: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  JUP: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  KAIA: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "KAIA" },
  KMNO: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  KSM: { address: "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV", network: "KSM" },
  LUNA: { address: "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s", network: "Terra" },
  MAGIC: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Arbitrum One" },
  MANTA: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Manta Pacific Mainnet" },
  MBOX: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  MINA: { address: "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW", network: "MINA" },
  NEAR: { address: "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef", network: "NEAR" },
  NOT: { address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB", network: "TON" },
  ONE: { address: "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3", network: "ONE" },
  OP: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "OP Mainnet" },
  PSG: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Chiliz Chain" },
  PYTH: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  RDNT: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Arbitrum One" },
  ROSE: { address: "oasis1qqgk0fmqlmcr5k0d0rgknw7e6a7hlc0t3qljrnhe", network: "ROSE" },
  SCRT: { address: "secret1tsz8v9k75jeqtl4exnf0qye5nme840h5n0pldk", memo: "10120271", network: "SCRT" },
  SEI: { address: "sei10czwjwhcjdjexgz9ecn2xma5at9t04dfaxsf4t", memo: "10124250", network: "SEI" },
  SHIB: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  SIGN: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "BSC" },
  STX: { address: "SP27ANV45PCAG98PGFA2GVN9K7QYY1KWWS1V6RFSX", memo: "10167021", network: "STX" },
  SUI: { address: "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c", network: "SUI" },
  TIA: { address: "celestia12stggm53c5wzqdz6w5xn6tkrj56phnzktj7d5w", network: "Celestia" },
  TON: { address: "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB", network: "TON" },
  TRUMP: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  TRX: { address: "TAF6zJUsa3yja8p5XQTWhMaY3QXxZmZdGN", network: "TRX" },
  WAXP: { address: "bybitwaxonly", memo: "10068817", network: "WAX" },
  WIF: { address: "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8", network: "Solana" },
  WCT: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "OP Mainnet" },
  WLD: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "OP Mainnet" },
  XAI: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "Arbitrum One" },
  XLM: { address: "GDT7ARDYZRBXXYOCSQ3MUMISTITSSRWZI6KR2A5L5Q3KB4QIZHGYMTIH", memo: "11088858", network: "XLM" },
  ZIL: { address: "zil1f5xpvwltm6uheftrlrhjtxcv392uuxtejekpjs", network: "ZIL" },
  ZRO: { address: "0x4231d188a91481a8c3d39d444b7451436babee94", network: "AVAXC" }
}
  },

  // ... (AQUÍ VA TU CÓDIGO ANTERIOR: PAIRS, BASE_ASSET, DEPOSIT_ADDRESSES)

FEES_AND_LIMITS: {
  BINANCE: {
    USDT: { withdrawal: { fee: 0.3, min: 5 }, deposit: { min: 0.002 } },
    LTC: { withdrawal: { fee: 0.0001, min: 0.002 }, deposit: { min: 0.002 } },
    BNB: { withdrawal: { fee: 0.00001, min: 0.0005 }, deposit: { min: 0.000003 } },
    XRP: { withdrawal: { fee: 0.2, min: 2 }, deposit: { min: 0.001 } },
    ALGO: { withdrawal: { fee: 0.008, min: 10 }, deposit: { min: 0.007 } },
    ANIME: { withdrawal: { fee: 7.74, min: 16 }, deposit: { min: 0.00000001 } },
    APT: { withdrawal: { fee: 0.016, min: 0.06 }, deposit: { min: 0.00015 } },
    ARB: { withdrawal: { fee: 0.56, min: 1.12 }, deposit: { min: 0.01 } },
    ATOM: { withdrawal: { fee: 0.02, min: 0.04 }, deposit: { min: 0.00016 } },
    AVAX: { withdrawal: { fee: 0.008, min: 0.1 }, deposit: { min: 0.00005 } },
    AXL: { withdrawal: { fee: 0.02, min: 1 }, deposit: { min: 0.0015 } },
    BB: { withdrawal: { fee: 0.05, min: 1 }, deposit: { min: 0.06 } },
    BEL: { withdrawal: { fee: 0.051, min: 0.1 }, deposit: { min: 0.002 } },
    BERA: { withdrawal: { fee: 0.001, min: 0.1 }, deposit: { min: 0.00000002 } },
    BOME: { withdrawal: { fee: 380, min: 760 }, deposit: { min: 0.02 } },
    BONK: { withdrawal: { fee: 41657, min: 83314 }, deposit: { min: 0.02 } },
    C98: { withdrawal: { fee: 0.26, min: 0.52 }, deposit: { min: 0.007 } },
    CAKE: { withdrawal: { fee: 0.0057, min: 0.011 }, deposit: { min: 0.0006 } },
    CATI: { withdrawal: { fee: 1.08, min: 2.16 }, deposit: { min: 0.00000002 } },
    CELO: { withdrawal: { fee: 0.003, min: 0.018 }, deposit: { min: 0.02 } },
    CGPT: { withdrawal: { fee: 0.14, min: 0.28 }, deposit: { min: 0.00000002 } },
    CHZ: { withdrawal: { fee: 1, min: 2 }, deposit: { min: 0.0001 } },
    CYBER: { withdrawal: { fee: 0.019, min: 0.038 }, deposit: { min: 0.0003 } },
    DOGS: { withdrawal: { fee: 100, min: 1000 }, deposit: { min: 0.02 } },
    DOT: { withdrawal: { fee: 0.08, min: 1.3 }, deposit: { min: 1.05 } },
    DYDX: { withdrawal: { fee: 0.01, min: 0.1 }, deposit: { min: 0.0009 } },
    EGLD: { withdrawal: { fee: 8.99, min: 0.0015 }, deposit: { min: 0.00004 } },
    ENJ: { withdrawal: { fee: 0.0003, min: 1 }, deposit: { min: 0.006 } },
    FIDA: { withdrawal: { fee: 0.0003, min: 17 }, deposit: { min: 0.005 } },
    FLOKI: { withdrawal: { fee: 175, min: 350 }, deposit: { min: 0.01 } },
    FLOW: { withdrawal: { fee: 0.0001, min: 2.7 }, deposit: { min: 0.0018 } },
    GMT: { withdrawal: { fee: 0.29, min: 0.58 }, deposit: { min: 0.008 } },
    GMX: { withdrawal: { fee: 0.005, min: 0.01 }, deposit: { min: 0.00005 } },
    HAEDAL: { withdrawal: { fee: 1.44, min: 2.88 }, deposit: { min: 0.00000002 } },
    HBAR: { withdrawal: { fee: 0.06, min: 2 }, deposit: { min: 0.013 } },
    HMSTR: { withdrawal: { fee: 108, min: 216 }, deposit: { min: 0.02 } },
    HOME: { withdrawal: { fee: 0.55, min: 1.1 }, deposit: { min: 0.000002 } },
    HYPER: { withdrawal: { fee: 0.12, min: 0.24 }, deposit: { min: 0.00000002 } },
    ICP: { withdrawal: { fee: 0.0003, min: 0.001 }, deposit: { min: 0.0002 } },
    ICX: { withdrawal: { fee: 0.02, min: 0.04 }, deposit: { min: 0.008 } },
    INJ: { withdrawal: { fee: 0.01, min: 0.1 }, deposit: { min: 0.00005 } },
    IO: { withdrawal: { fee: 0.81, min: 1.62 }, deposit: { min: 0.0005 } },
    JUP: { withdrawal: { fee: 1.48, min: 2.96 }, deposit: { min: 0.0013 } },
    KAIA: { withdrawal: { fee: 0.005, min: 100 }, deposit: { min: 0.008 } },
    KMNO: { withdrawal: { fee: 8.85, min: 17 }, deposit: { min: 0.000002 } },
    KSM: { withdrawal: { fee: 0.01, min: 0.4 }, deposit: { min: 0.001 } },
    LUNA: { withdrawal: { fee: 0.01, min: 1 }, deposit: { min: 0.0026 } },
    MAGIC: { withdrawal: { fee: 1.15, min: 2.3 }, deposit: { min: 0.003 } },
    MANTA: { withdrawal: { fee: 0.15, min: 0.42 }, deposit: { min: 0.0012 } },
    MBOX: { withdrawal: { fee: 0.29, min: 0.58 }, deposit: { min: 0.0046 } },
    MINA: { withdrawal: { fee: 0.9, min: 5 }, deposit: { min: 0.004 } },
    NEAR: { withdrawal: { fee: 0.018, min: 6 }, deposit: { min: 0.0002 } },
    NOT: { withdrawal: { fee: 44, min: 88 }, deposit: { min: 0.01 } },
    ONE: { withdrawal: { fee: 0.1, min: 60 }, deposit: { min: 0.07 } },
    OP: { withdrawal: { fee: 0.045, min: 0.09 }, deposit: { min: 0.0006 } },
    PSG: { withdrawal: { fee: 0, min: 1 }, deposit: { min: 0.00000002 } },
    PYTH: { withdrawal: { fee: 0, min: 1 }, deposit: { min: 0.004 } },
    RDNT: { withdrawal: { fee: 8.26, min: 16 }, deposit: { min: 0.03 } },
    ROSE: { withdrawal: { fee: 0.1, min: 1 }, deposit: { min: 0.013 } },
    SCRT: { withdrawal: { fee: 0.1, min: 5 }, deposit: { min: 0.005 } },
    SEI: { withdrawal: { fee: 0.4, min: 5 }, deposit: { min: 0.004 } },
    SHIB: { withdrawal: { fee: 1112, min: 2224 }, deposit: { min: 1.1 } },
    SIGN: { withdrawal: { fee: 0.19, min: 0.38 }, deposit: { min: 0.00000003 } },
    STX: { withdrawal: { fee: 1, min: 5 }, deposit: { min: 0.0006 } },
    SUI: { withdrawal: { fee: 0.06, min: 1 }, deposit: { min: 0.0013 } },
    TIA: { withdrawal: { fee: 0.1, min: 0.4 }, deposit: { min: 0.00015 } },
    TON: { withdrawal: { fee: 0.02, min: 0.4 }, deposit: { min: 0.00000001 } },
    TRUMP: { withdrawal: { fee: 0.062, min: 0.12 }, deposit: { min: 0.000002 } },
    TRX: { withdrawal: { fee: 1, min: 30 }, deposit: { min: 1 } },
    WAXP: { withdrawal: { fee: 0.2, min: 7 }, deposit: { min: 2 } },
    WIF: { withdrawal: { fee: 0.76, min: 1.52 }, deposit: { min: 0.0006 } },
    WCT: { withdrawal: { fee: 0.069, min: 0.14 }, deposit: { min: 0.00000002 } },
    WLD: { withdrawal: { fee: 0.028, min: 0.056 }, deposit: { min: 0.0004 } },
    XAI: { withdrawal: { fee: 3.25, min: 6.5 }, deposit: { min: 0.0029 } },
    XLM: { withdrawal: { fee: 0.01, min: 25 }, deposit: { min: 0.02 } },
    ZIL: { withdrawal: { fee: 1, min: 2 }, deposit: { min: 0.07 } },
    ZRO: { withdrawal: { fee: 0.04, min: 0.08 }, deposit: { min: 0.00026 } }
  },

  BYBIT: {
    USDT: { withdrawal: { fee: 0.3, min: 1 }, deposit: { min: 0.001 } },
    LTC: { withdrawal: { fee: 0.0001, min: 0.001 }, deposit: { min: 0.00000001 } },
    BNB: { withdrawal: { fee: 0.0002, min: 0.0002 }, deposit: { min: 0.0 } },
    XRP: { withdrawal: { fee: 0.2, min: 1.2 }, deposit: { min: 0.01 } },
    ALGO: { withdrawal: { fee: 0.01, min: 10 }, deposit: { min: 1 } },
    ANIME: { withdrawal: { fee: 16, min: 30 }, deposit: { min: 1 } },
    APT: { withdrawal: { fee: 0.01, min: 0.01 }, deposit: { min: 1 } },
    ARB: { withdrawal: { fee: 0.4, min: 0.4 }, deposit: { min: 0.00000001 } },
    ATOM: { withdrawal: { fee: 0.005, min: 0.015 }, deposit: { min: 0.0001 } },
    AVAX: { withdrawal: { fee: 0.008, min: 0.008 }, deposit: { min: 0 } },
    AXL: { withdrawal: { fee: 0.005, min: 0.005 }, deposit: { min: 0 } },
    BB: { withdrawal: { fee: 1, min: 1 }, deposit: { min: 0 } },
    BEL: { withdrawal: { fee: 0.12, min: 0.12 }, deposit: { min: 0 } },
    BERA: { withdrawal: { fee: 0.000001, min: 0.00001 }, deposit: { min: 0 } },
    BOME: { withdrawal: { fee: 400, min: 200 }, deposit: { min: 0 } },
    BONK: { withdrawal: { fee: 40000, min: 50000 }, deposit: { min: 0 } },
    C98: { withdrawal: { fee: 0.3, min: 0.3 }, deposit: { min: 0 } },
    CAKE: { withdrawal: { fee: 0.023, min: 0.023 }, deposit: { min: 0 } },
    CATI: { withdrawal: { fee: 0.3, min: 0.3 }, deposit: { min: 0 } },
    CELO: { withdrawal: { fee: 0.001, min: 0.002 }, deposit: { min: 0 } },
    CGPT: { withdrawal: { fee: 2, min: 2 }, deposit: { min: 0 } },
    CHZ: { withdrawal: { fee: 0, min: 0.0002 }, deposit: { min: 0 } },
    CYBER: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } },
    DOGS: { withdrawal: { fee: 50, min: 50 }, deposit: { min: 0 } },
    DOT: { withdrawal: { fee: 0.08, min: 2 }, deposit: { min: 1.05 } },
    DYDX: { withdrawal: { fee: 0.2, min: 0.2 }, deposit: { min: 0.000000000000000001 } },
    EGLD: { withdrawal: { fee: 0.001, min: 0.01 }, deposit: { min: 0 } },
    ENJ: { withdrawal: { fee: 0.001, min: 0.1 }, deposit: { min: 0 } },
    FIDA: { withdrawal: { fee: 7, min: 1.5 }, deposit: { min: 0 } },
    FLOKI: { withdrawal: { fee: 2.617, min: 2.617 }, deposit: { min: 0 } },
    FLOW: { withdrawal: { fee: 0.01, min: 0.01 }, deposit: { min: 0 } },
    GMT: { withdrawal: { fee: 0.25, min: 0.25 }, deposit: { min: 0 } },
    GMX: { withdrawal: { fee: 0.006, min: 0.006 }, deposit: { min: 0 } },
    HAEDAL: { withdrawal: { fee: 1, min: 1 }, deposit: { min: 0 } },
    HBAR: { withdrawal: { fee: 1, min: 2 }, deposit: { min: 0 } },
    HMSTR: { withdrawal: { fee: 80, min: 80 }, deposit: { min: 0 } },
    HOME: { withdrawal: { fee: 20, min: 40 }, deposit: { min: 0 } },
    HYPER: { withdrawal: { fee: 5, min: 10 }, deposit: { min: 0 } },
    ICP: { withdrawal: { fee: 0.0003, min: 0.0003 }, deposit: { min: 0 } },
    ICX: { withdrawal: { fee: 0.02, min: 0.02 }, deposit: { min: 0 } },
    INJ: { withdrawal: { fee: 0.008, min: 0.008 }, deposit: { min: 0.000000000000000001 } },
    IO: { withdrawal: { fee: 1, min: 0.02 }, deposit: { min: 0 } },
    JUP: { withdrawal: { fee: 0.8, min: 0.5 }, deposit: { min: 0 } },
    KAIA: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } },
    KMNO: { withdrawal: { fee: 10, min: 10 }, deposit: { min: 0 } },
    KSM: { withdrawal: { fee: 0.01, min: 0.01 }, deposit: { min: 0 } },
    LUNA: { withdrawal: { fee: 0.01, min: 0.01 }, deposit: { min: 0 } },
    MAGIC: { withdrawal: { fee: 0.3, min: 0.3 }, deposit: { min: 12 } },
    MANTA: { withdrawal: { fee: 1, min: 2 }, deposit: { min: 0 } },
    MBOX: { withdrawal: { fee: 1, min: 1 }, deposit: { min: 0 } },
    MINA: { withdrawal: { fee: 0.5, min: 2.5 }, deposit: { min: 0 } },
    NEAR: { withdrawal: { fee: 0.01, min: 0.2 }, deposit: { min: 0 } },
    NOT: { withdrawal: { fee: 30, min: 30 }, deposit: { min: 0 } },
    ONE: { withdrawal: { fee: 0.1, min: 60 }, deposit: { min: 0 } },
    OP: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } },
    PSG: { withdrawal: { fee: 0, min: 0 }, deposit: { min: 0 } },
    PYTH: { withdrawal: { fee: 3, min: 2 }, deposit: { min: 0 } },
    RDNT: { withdrawal: { fee: 0.3, min: 0.3 }, deposit: { min: 0 } },
    ROSE: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } },
    SCRT: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } },
    SEI: { withdrawal: { fee: 0.2, min: 0.2 }, deposit: { min: 0 } },
    SHIB: { withdrawal: { fee: 7000, min: 7000 }, deposit: { min: 0 } },
    SIGN: { withdrawal: { fee: 1, min: 1 }, deposit: { min: 0 } },
    STX: { withdrawal: { fee: 1, min: 2 }, deposit: { min: 0 } },
    SUI: { withdrawal: { fee: 0.02, min: 0.02 }, deposit: { min: 0 } },
    TIA: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } },
    TON: { withdrawal: { fee: 0.02, min: 0.02 }, deposit: { min: 0.00000001 } },
    TRUMP: { withdrawal: { fee: 0.05, min: 0.1 }, deposit: { min: 0 } },
    TRX: { withdrawal: { fee: 1, min: 1 }, deposit: { min: 1 } },
    WAXP: { withdrawal: { fee: 2, min: 2 }, deposit: { min: 0 } },
    WIF: { withdrawal: { fee: 0.6, min: 0.6 }, deposit: { min: 0 } },
    WCT: { withdrawal: { fee: 1, min: 2 }, deposit: { min: 0 } },
    WLD: { withdrawal: { fee: 0.2, min: 0.2 }, deposit: { min: 0 } },
    XAI: { withdrawal: { fee: 0.1, min: 0.2 }, deposit: { min: 0 } },
    XLM: { withdrawal: { fee: 0.02, min: 8 }, deposit: { min: 0 } },
    ZIL: { withdrawal: { fee: 0.2, min: 0.4 }, deposit: { min: 0 } },
    ZRO: { withdrawal: { fee: 0.1, min: 0.1 }, deposit: { min: 0 } }
  },


 // 4. TRADING FEES
  TRADING_FEES: {
    BINANCE: 0.001, // 0.1%
    BYBIT:   0.001  // 0.1%
  },

  // 5. DEPOSIT FEES
  DEPOSIT_FEES: {
    BINANCE: 0,
    BYBIT: 0
  },

  // 6. INITIAL BALANCES
  INITIAL_BALANCE: {
    BINANCE: { USDT: 20 },
    BYBIT:   { USDT: 20 }
  },

  // 7. RISK CONTROL (global y por par)
  GLOBAL_RISK: {
    MIN_TRADE_AMOUNT: 10,
    MAX_TRADE_AMOUNT: 10,
    MIN_SPREAD: 0.002,    // 0.2% spread mínimo recomendable
    MAX_SLIPPAGE: 0.001   // 0.1% slippage máximo recomendable
  },

  // 8. EXCHANGE LIMITS
  EXCHANGE_LIMITS: {
    BINANCE: { withdrawal: "NONE", trading: "NONE", regional: "NONE" },
    BYBIT:   { withdrawal: "NONE", trading: "NONE", regional: "NONE" }
  },

  PAIR_SETTINGS: {
  "LTC/USDT":    { minTrade: 10, maxTrade: 50, minSpread: 0.0015, maxSlippage: 0.0005, fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "BNB/USDT":    { minTrade: 10, maxTrade: 30, minSpread: 0.002,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "XRP/USDT":    { minTrade: 10, maxTrade: 40, minSpread: 0.0018, maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ALGO/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ANIME/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "APT/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ARB/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ATOM/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "AVAX/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "AXL/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "BB/USDT":     { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "BEL/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "BERA/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "BOME/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "BONK/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "C98/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "CAKE/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "CATI/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "CELO/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "CGPT/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "CHZ/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "CYBER/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "DOGS/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "DOT/USDT":    { minTrade: 10, maxTrade: 40, minSpread: 0.0018, maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "DYDX/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "EGLD/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ENJ/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "FIDA/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "FLOKI/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "FLOW/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "GMT/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "GMX/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "HAEDAL/USDT": { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "HBAR/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "HMSTR/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "HOME/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "HYPER/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ICP/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ICX/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "INJ/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "IO/USDT":     { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "JUP/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "KAIA/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "KMNO/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "KSM/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "LUNA/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "MAGIC/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "MANTA/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "MBOX/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "MINA/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "NEAR/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "NOT/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ONE/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "OP/USDT":     { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "PSG/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "PYTH/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "RDNT/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ROSE/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "SCRT/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "SEI/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "SHIB/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "SIGN/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "STX/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "SUI/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "TIA/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "TNSR/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "TON/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "TRUMP/USDT":  { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "TRX/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "WAXP/USDT":   { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "WCT/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "WIF/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "WLD/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "XAI/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "XLM/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ZIL/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } },
  "ZRO/USDT":    { minTrade: 10, maxTrade: 20, minSpread: 0.001,  maxSlippage: 0.001,  fee: { BINANCE: 0.001, BYBIT: 0.001 } }
    
    },
    
  "STRATEGIES": {
    "SIMPLE": {
      "name": "Simple Arbitrage",
      "enabled": true,
      "minProfitPercentage": 0.2,
      "maxInvestmentPercentage": 0.5,
      "timeoutMs": 3000
    },
    "ADVANCED": {
      "name": "Advanced Arbitrage",
      "enabled": false,
      "minProfitPercentage": 0.3,
      "maxInvestmentPercentage": 0.3,
      "timeoutMs": 4000
    }
  },
  "AI_TRADING": {
    "ENABLED": false,
    "PREDICTION_HORIZON": 3000
  }













}
}

--------------------------------------------------------------------------------------------------------

require("dotenv").config()

console.log("=== DIAGNÓSTICO DEL ALERT MANAGER ===")

// Cargar configuración
const config = require("./src/strategies/config")

console.log("Configuración de alertas:")
console.log("ALERTS.ENABLED:", config.ALERTS.ENABLED)
console.log("EMAIL.enabled:", config.ALERTS.CHANNELS.EMAIL.enabled)
console.log("TELEGRAM.enabled:", config.ALERTS.CHANNELS.TELEGRAM.enabled)

console.log("\nConfiguración de BOT_STARTED:")
console.log("BOT_STARTED:", config.ALERTS.ALERT_TYPES.BOT_STARTED)

// Probar AlertManager
async function testAlertManager() {
  try {
    console.log("\n=== INICIALIZANDO ALERT MANAGER ===")

    const AlertManager = require("./src/alerts/alert-manager")
    const alertManager = new AlertManager(config)

    console.log("AlertManager creado")

    await alertManager.initialize()
    console.log("AlertManager inicializado")

    console.log("\n=== ENVIANDO ALERTA DE PRUEBA ===")

    // Enviar alerta que debería ir tanto a Telegram como Email
    await alertManager.sendAlert("BOT_STARTED", "🤖 Test manual - Bot iniciado")

    console.log("✅ Alerta enviada")

    // Esperar un poco para que se procese
    setTimeout(() => {
      console.log("\n=== ENVIANDO ALERTA DE ERROR (DEBE IR A EMAIL) ===")
      alertManager.sendAlert("ERROR", "❌ Test de error - Debe llegar a email y telegram")

      setTimeout(() => {
        console.log("✅ Proceso completado")
        process.exit(0)
      }, 3000)
    }, 2000)
  } catch (error) {
    console.error("❌ Error:", error)
  }
}

testAlertManager()

----------------------------------------------------------------------------------------------------------

require("dotenv").config()

console.log("=== DIAGNÓSTICO DE TELEGRAM ===")
console.log("Variables de entorno:")
console.log("TELEGRAM_BOT_TOKEN:", process.env.TELEGRAM_BOT_TOKEN ? "✅ CONFIGURADO" : "❌ NO CONFIGURADO")
console.log("TELEGRAM_CHAT_ID:", process.env.TELEGRAM_CHAT_ID ? "✅ CONFIGURADO" : "❌ NO CONFIGURADO")

if (process.env.TELEGRAM_BOT_TOKEN) {
  console.log("Token (primeros 10 caracteres):", process.env.TELEGRAM_BOT_TOKEN.substring(0, 10) + "...")
}

if (process.env.TELEGRAM_CHAT_ID) {
  console.log("Chat ID:", process.env.TELEGRAM_CHAT_ID)
}

// Probar la configuración del bot
const config = require("./src/strategies/config")
console.log("\n=== CONFIGURACIÓN DEL BOT ===")
console.log("Alertas habilitadas:", config.ALERTS.ENABLED)
console.log("Telegram habilitado:", config.ALERTS.CHANNELS.TELEGRAM.enabled)
console.log("Bot Token en config:", config.ALERTS.CHANNELS.TELEGRAM.botToken ? "✅ CONFIGURADO" : "❌ NO CONFIGURADO")
console.log("Chat ID en config:", config.ALERTS.CHANNELS.TELEGRAM.chatId ? "✅ CONFIGURADO" : "❌ NO CONFIGURADO")

// Probar envío directo
async function testDirectTelegram() {
  const https = require("https")

  const botToken = process.env.TELEGRAM_BOT_TOKEN
  const chatId = process.env.TELEGRAM_CHAT_ID

  if (!botToken || !chatId) {
    console.log("\n❌ No se puede probar: faltan credenciales")
    return
  }

  console.log("\n=== PROBANDO ENVÍO DIRECTO ===")

  const message = `🔧 Test directo: ${new Date().toLocaleString()}`

  const data = JSON.stringify({
    chat_id: chatId,
    text: message,
    parse_mode: "HTML",
  })

  const options = {
    hostname: "api.telegram.org",
    port: 443,
    path: `/bot${botToken}/sendMessage`,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": data.length,
    },
  }

  const req = https.request(options, (res) => {
    let responseData = ""

    res.on("data", (chunk) => {
      responseData += chunk
    })

    res.on("end", () => {
      try {
        const response = JSON.parse(responseData)
        if (response.ok) {
          console.log("✅ ÉXITO: Mensaje enviado a Telegram")
          console.log("Detalles:", response.result)
        } else {
          console.log("❌ ERROR de Telegram:", response.description)
        }
      } catch (error) {
        console.log("❌ Error parseando respuesta:", error.message)
        console.log("Respuesta cruda:", responseData)
      }
    })
  })

  req.on("error", (error) => {
    console.log("❌ Error de conexión:", error.message)
  })

  req.write(data)
  req.end()
}

// Ejecutar prueba
testDirectTelegram()

// Probar AlertManager
setTimeout(async () => {
  console.log("\n=== PROBANDO ALERT MANAGER ===")
  try {
    const AlertManager = require("./src/alerts/alert-manager")
    const alertManager = new AlertManager(config)

    await alertManager.initialize()
    await alertManager.sendAlert("info", "🧪 Test desde AlertManager")

    console.log("✅ AlertManager ejecutado sin errores")
  } catch (error) {
    console.log("❌ Error en AlertManager:", error.message)
  }
}, 2000)

-----------------------------------------------------------------------------------------------------------

# 🚀 GUÍA DE INICIO RÁPIDO

## 1. Instalación

```bash
# Clonar repositorio
git clone <tu-repositorio>
cd arbitrage-bot

# Instalar dependencias
npm install

# Configuración rápida
node setup.js
```

## 2. Configuración Mínima

### Opción A: Configuración Automática
```bash
node setup.js
```

### Opción B: Configuración Manual
1. Copiar `.env.example` a `.env`
2. Editar `src/strategies/config.js`
3. Configurar API keys de exchanges

## 3. Primer Uso

```bash
# Iniciar en modo simulación
npm start

# Ver dashboard
http://localhost:3000
```

## 4. Configuraciones Importantes

### Cambiar a Trading Real
```javascript
// En config.js
TRADING_MODE: "live"
```

### Ajustar Ganancia Mínima
```javascript
// En config.js
BASIC: {
    minProfitPercentage: 0.5 // 0.5% mínimo
}
```

### Configurar Alertas
```javascript
// En config.js
ALERTS: {
    CHANNELS: {
        EMAIL: { enabled: true },
        TELEGRAM: { enabled: true }
    }
}
```

## 5. Monitoreo

- **Dashboard**: http://localhost:3000
- **API**: http://localhost:3001
- **Logs**: `tail -f logs/combined.log`

## 6. Comandos Útiles

```bash
# Parar bot
Ctrl+C

# Ver logs en tiempo real
npm run logs

# Ejecutar backtest
npm run backtest

# Verificar configuración
npm run check
```

-------------------------------------------------------------------------------------------------------

// ========== CONFIGURACIÓN INICIAL ==========
require('dotenv').config();

// Chequeo de módulos requeridos
function requireSafe(modulePath, label) {
  try {
    return require(modulePath);
  } catch (e) {
    console.error(`❌ Error: No se pudo cargar el módulo "${label}" (${modulePath})`);
    process.exit(1);
  }
}

// Cargar módulo principal
let CEXArbitrageBot;
try {
  const cexModule = require('./src/core/cex-arbitrage-bot');
  CEXArbitrageBot = cexModule.CEXArbitrageBot || cexModule.default || cexModule;
  if (!CEXArbitrageBot) throw new Error("No se encontró la clase CEXArbitrageBot");
} catch (error) {
  console.error("❌ Error cargando el módulo principal:", error);
  process.exit(1);
}

// Configuración completa
const config = {
  GENERAL: {
    PORT: process.env.PORT || 8888,
    DRY_RUN: process.env.DRY_RUN === 'true'
  },
  MOBILE_API: {
    PORT: process.env.MOBILE_API_PORT || 8426
  },
  AI_TRADING: {
    ENABLED: process.env.AI_TRADING_ENABLED === 'true'
  },
  BACKTESTING: {
    ENABLED: process.env.BACKTESTING_ENABLED === 'true'
  },
  ALERTS: {
    ENABLED: true,
    CHANNELS: {
      EMAIL: false,
      TELEGRAM: false,
      DISCORD: false
    }
  },
  EXCHANGES: {
    BINANCE: {
      API_KEY: process.env.BINANCE_API_KEY,
      API_SECRET: process.env.BINANCE_API_SECRET
    },
    BYBIT: {
      API_KEY: process.env.BYBIT_API_KEY,
      API_SECRET: process.env.BYBIT_API_SECRET
    }
  },
  TRADING_PAIRS: [
    { symbol: 'LTCUSDT', minProfit: 0.002 },
    { symbol: 'BNBUSDT', minProfit: 0.003 },
    { symbol: 'XRPUSDT', minProfit: 0.005 }
  ]
};

// Cargar otros módulos con la configuración
const StrategyManager = requireSafe("./src/strategies/strategy-manager", "StrategyManager");
const { PortfolioManager } = requireSafe("./src/portfolio/portfolio-manager", "PortfolioManager");
const { MLEngine } = requireSafe("./src/ai/ml-engine", "MLEngine");
const { BacktestEngine } = requireSafe("./src/backtesting/backtest-engine", "BacktestEngine");
const AlertManager = requireSafe("./src/alerts/alert-manager", "AlertManager").AlertManager;
const { AdvancedRiskManager } = requireSafe("./src/risk/advanced-risk-manager", "AdvancedRiskManager");
const { MobileAPI } = requireSafe("./src/mobile/mobile-api", "MobileAPI");
const express = requireSafe("express", "Express");

// ========== CLASE MEJORADA DEL BOT ==========
class EnhancedArbitrageBot extends CEXArbitrageBot {
  constructor() {
    super(config);

    // Inicializar componentes con configuración
    this.strategyManager = new StrategyManager(config);
    this.portfolioManager = new PortfolioManager(config);
    this.mlEngine = new MLEngine(config);
    this.backtestEngine = new BacktestEngine(this.strategyManager, config);
    this.alertManager = new AlertManager(config);
    this.advancedRiskManager = new AdvancedRiskManager(config);
    this.mobileAPI = new MobileAPI(config);

    this.setupMobileAPI();
    this.connectAlertManager();

    console.log("🚀 Bot inicializado correctamente");
  }

  setupMobileAPI() {
    const app = express();
    app.use(express.json());
    app.use("/api/mobile", this.mobileAPI.getRouter());
    
    const port = config.MOBILE_API.PORT;
    app.listen(port, () => {
      console.log(`📱 API Móvil en puerto ${port}`);
    });
  }

  connectAlertManager() {
    this.alertManager.getBotStatus = async () => ({
      isRunning: true,
      totalProfit: 0,
      dailyTrades: 0,
      successRate: 0,
      strategy: "default"
    });
  }

  async start() {
    if (config.AI_TRADING.ENABLED) {
      await this.mlEngine.loadModels();
    }
    console.log("🤖 Bot iniciado correctamente");
  }

  async stop() {
    console.log("🛑 Bot detenido correctamente");
  }
}

// ========== INICIAR EL BOT ==========
if (require.main === module) {

  const bot = new CEXArbitrageBot(config)

  process.on("SIGINT", async () => {
    await bot.stop();
    process.exit(0);
  });

  process.on("uncaughtException", (error) => {
    console.error("💥 Error crítico:", error);
    process.exit(1);
  });

  bot.start().catch(error => {
    console.error("❌ Error al iniciar:", error);
    process.exit(1);
  });
}

module.exports = { EnhancedArbitrageBot };

-----------------------------------------------------------------------------------------------------------

Manual Completo del Bot - "La Biblia del Bot"


# 📚 MANUAL COMPLETO DEL BOT DE ARBITRAJE CEX - "LA BIBLIA DEL BOT"

## 📋 ÍNDICE

1. [Configuración General](#configuración-general)
2. [Configuración de Exchanges](#configuración-de-exchanges)
3. [Estrategias de Trading](#estrategias-de-trading)
4. [Gestión de Riesgos](#gestión-de-riesgos)
5. [Portfolio y Balances](#portfolio-y-balances)
6. [Alertas y Notificaciones](#alertas-y-notificaciones)
7. [Inteligencia Artificial](#inteligencia-artificial)
8. [Backtesting](#backtesting)
9. [API Móvil](#api-móvil)
10. [Dashboard Web](#dashboard-web)
11. [Logs y Monitoreo](#logs-y-monitoreo)
12. [Seguridad](#seguridad)
13. [Troubleshooting](#troubleshooting)

---

## 🔧 CONFIGURACIÓN GENERAL

### Archivo Principal: `/src/strategies/config.js`

```javascript
// CONFIGURACIÓN BÁSICA DEL BOT
const config = {
    // ===== CONFIGURACIÓN GENERAL =====
    BOT_NAME: "CEX Arbitrage Bot IA",
    VERSION: "2.0.0",
    ENVIRONMENT: "production", // "development" | "production" | "testing"
    
    // ===== MODO DE OPERACIÓN =====
    TRADING_MODE: "simulation", // "simulation" | "live"
    
    // ===== PARES DE TRADING =====
    TRADING_PAIRS: [
        "BTC/USDT",
        "ETH/USDT", 
        "XRP/USDT",
        "ADA/USDT",
        "DOT/USDT"
    ],
    
    // ===== INTERVALOS DE TIEMPO =====
    SCAN_INTERVAL: 5000,        // Cada 5 segundos
    PRICE_UPDATE_INTERVAL: 2000, // Cada 2 segundos
    BALANCE_CHECK_INTERVAL: 30000, // Cada 30 segundos
}
```

### ⚙️ Cómo Modificar la Configuración General

1. **Cambiar Modo de Trading**:
   ```javascript
   TRADING_MODE: "live" // Para trading real
   TRADING_MODE: "simulation" // Para simulación
   ```

2. **Añadir Nuevos Pares**:
   ```javascript
   TRADING_PAIRS: [
       "BTC/USDT",
       "ETH/USDT",
       "MATIC/USDT", // ← Nuevo par
       "LINK/USDT"   // ← Nuevo par
   ]
   ```

3. **Ajustar Velocidad del Bot**:
   ```javascript
   SCAN_INTERVAL: 3000, // Más rápido (cada 3 segundos)
   SCAN_INTERVAL: 10000, // Más lento (cada 10 segundos)
   ```

---

## 🏦 CONFIGURACIÓN DE EXCHANGES

### Configuración de APIs

```javascript
EXCHANGES: {
    BINANCE: {
        enabled: true,
        name: "Binance",
        apiKey: "TU_API_KEY_BINANCE",
        apiSecret: "TU_API_SECRET_BINANCE",
        sandbox: false, // true para testnet
        rateLimit: 1200,
        fees: {
            maker: 0.001, // 0.1%
            taker: 0.001  // 0.1%
        }
    },
    COINBASE: {
        enabled: true,
        name: "Coinbase",
        apiKey: "TU_API_KEY_COINBASE",
        apiSecret: "TU_API_SECRET_COINBASE",
        passphrase: "TU_PASSPHRASE_COINBASE",
        sandbox: false,
        rateLimit: 10,
        fees: {
            maker: 0.005, // 0.5%
            taker: 0.005  // 0.5%
        }
    }
}
```

### 🔑 Cómo Configurar APIs de Exchange

1. **Obtener API Keys**:
   - **Binance**: Spot Trading + Read Info permissions
   - **Coinbase**: View + Trade permissions
   - **Kraken**: Query Funds + Create & Modify Orders
   - **KuCoin**: General + Trade permissions

2. **Configurar Permisos Mínimos**:
   ```
   ✅ Leer información de cuenta
   ✅ Leer balances
   ✅ Crear órdenes spot
   ✅ Cancelar órdenes
   ❌ Retirar fondos (NO necesario)
   ❌ Transferir a otras cuentas (NO necesario)
   ```

3. **Habilitar/Deshabilitar Exchanges**:
   ```javascript
   BINANCE: {
       enabled: false, // ← Deshabilitar Binance
   }
   ```

### 💰 Gestión de Balances por Exchange

```javascript
PORTFOLIO: {
    INITIAL_BALANCE: 10000, // $10,000 USD total
    TARGET_ALLOCATION: {
        "Binance": 0.25,    // 25%
        "Coinbase": 0.25,   // 25%
        "Kraken": 0.25,     // 25%
        "Kucoin": 0.25      // 25%
    },
    MIN_BALANCE_PER_EXCHANGE: 100, // Mínimo $100 por exchange
    RESERVE_PERCENTAGE: 0.05 // 5% de reserva
}
```

---

## 🎯 ESTRATEGIAS DE TRADING

### Configuración de Estrategias

```javascript
STRATEGIES: {
    // ===== ARBITRAJE BÁSICO =====
    BASIC: {
        enabled: true,
        minProfitPercentage: 0.2,     // Mínimo 0.2% ganancia
        maxInvestmentPercentage: 0.1,  // Máximo 10% del balance
        maxSlippage: 0.05,            // Máximo 0.05% slippage
        executionTimeout: 30000       // 30 segundos timeout
    },
    
    // ===== ARBITRAJE TRIANGULAR =====
    TRIANGULAR: {
        enabled: true,
        minProfitPercentage: 0.15,    // Mínimo 0.15% ganancia
        maxInvestmentPercentage: 0.08, // Máximo 8% del balance
        intermediateCurrencies: ["ETH", "BNB", "USDC"],
        maxHops: 3                    // Máximo 3 saltos
    },
    
    // ===== ARBITRAJE ESTADÍSTICO =====
    STATISTICAL: {
        enabled: false,               // Deshabilitado por defecto
        minProfitPercentage: 0.1,
        lookbackPeriod: 100,          // 100 períodos históricos
        zScoreThreshold: 2.0,         // Umbral Z-Score
        meanReversionTime: 3600       // 1 hora
    },
    
    // ===== MACHINE LEARNING =====
    ML: {
        enabled: true,
        minProfitPercentage: 0.25,
        confidenceThreshold: 0.7,     // 70% confianza mínima
        modelUpdateFrequency: 86400,  // Actualizar cada 24 horas
        features: ["price", "volume", "volatility", "spread"]
    }
}
```

### 🎮 Cómo Cambiar Estrategias

1. **Habilitar/Deshabilitar Estrategias**:
   ```javascript
   BASIC: {
       enabled: false, // ← Deshabilitar arbitraje básico
   }
   ```

2. **Ajustar Rentabilidad Mínima**:
   ```javascript
   BASIC: {
       minProfitPercentage: 0.5, // ← Aumentar a 0.5% mínimo
   }
   ```

3. **Cambiar Tamaño de Inversión**:
   ```javascript
   BASIC: {
       maxInvestmentPercentage: 0.05, // ← Reducir a 5% máximo
   }
   ```

---

## ⚠️ GESTIÓN DE RIESGOS

### Configuración de Risk Management

```javascript
RISK_MANAGEMENT: {
    // ===== LÍMITES GENERALES =====
    MAX_DAILY_LOSS: 500,           // Máximo $500 pérdida diaria
    MAX_DRAWDOWN: 0.1,             // Máximo 10% drawdown
    MAX_EXPOSURE_PER_PAIR: 0.2,    // Máximo 20% por par
    MAX_EXPOSURE_PER_EXCHANGE: 0.3, // Máximo 30% por exchange
    
    // ===== STOP LOSS =====
    STOP_LOSS: {
        enabled: true,
        percentage: 0.02,           // 2% stop loss
        trailingStop: true,         // Stop loss dinámico
        trailingDistance: 0.01      // 1% distancia trailing
    },
    
    // ===== VOLATILIDAD =====
    VOLATILITY_LIMITS: {
        maxVolatility: 0.05,        // Máximo 5% volatilidad
        volatilityWindow: 24,       // Ventana de 24 horas
        pauseOnHighVolatility: true // Pausar si volatilidad alta
    },
    
    // ===== REBALANCEO =====
    REBALANCE_THRESHOLD: 0.15,     // Rebalancear si desviación > 15%
    AUTO_REBALANCE: true,          // Rebalanceo automático
    REBALANCE_FREQUENCY: 3600000   // Cada hora
}
```

### 🛡️ Cómo Ajustar el Risk Management

1. **Cambiar Límites de Pérdida**:
   ```javascript
   MAX_DAILY_LOSS: 200,    // ← Reducir a $200
   MAX_DRAWDOWN: 0.05,     // ← Reducir a 5%
   ```

2. **Configurar Stop Loss**:
   ```javascript
   STOP_LOSS: {
       enabled: true,
       percentage: 0.01,    // ← 1% stop loss más estricto
       trailingStop: false  // ← Deshabilitar trailing stop
   }
   ```

3. **Ajustar Límites de Exposición**:
   ```javascript
   MAX_EXPOSURE_PER_PAIR: 0.1,     // ← Máximo 10% por par
   MAX_EXPOSURE_PER_EXCHANGE: 0.2  // ← Máximo 20% por exchange
   ```

---

## 💼 PORTFOLIO Y BALANCES

### Configuración del Portfolio

```javascript
PORTFOLIO: {
    // ===== BALANCE INICIAL =====
    INITIAL_BALANCE: 10000,        // $10,000 USD
    
    // ===== DISTRIBUCIÓN OBJETIVO =====
    TARGET_ALLOCATION: {
        "Binance": 0.30,           // 30%
        "Coinbase": 0.25,          // 25%
        "Kraken": 0.25,            // 25%
        "Kucoin": 0.20             // 20%
    },
    
    // ===== REBALANCEO =====
    REBALANCE_FREQUENCY: 3600000,  // Cada hora
    MIN_BALANCE_PER_EXCHANGE: 100, // Mínimo $100
    RESERVE_PERCENTAGE: 0.05,      // 5% reserva
    
    // ===== AUTO-COMPOUND =====
    AUTO_COMPOUND: true,           // Reinvertir ganancias
    COMPOUND_THRESHOLD: 100        // Reinvertir cada $100 ganancia
}
```

### 💰 Cómo Gestionar el Portfolio

1. **Cambiar Balance Inicial**:
   ```javascript
   INITIAL_BALANCE: 5000, // ← Cambiar a $5,000
   ```

2. **Modificar Distribución**:
   ```javascript
   TARGET_ALLOCATION: {
       "Binance": 0.50,    // ← 50% en Binance
       "Coinbase": 0.30,   // ← 30% en Coinbase
       "Kraken": 0.20      // ← 20% en Kraken
   }
   ```

3. **Configurar Auto-Compound**:
   ```javascript
   AUTO_COMPOUND: false,        // ← Deshabilitar reinversión
   COMPOUND_THRESHOLD: 50       // ← Reinvertir cada $50
   ```

---