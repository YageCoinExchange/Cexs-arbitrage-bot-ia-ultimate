
    // Modelo de detecci√≥n de oportunidades
    this.models.set('OPPORTUNITY_DETECTION', {
      name: 'Detecci√≥n de Oportunidades',
      type: 'CLASSIFICATION',
      features: ['spread', 'volume_ratio', 'price_volatility', 'market_sentiment'],
      accuracy: 0.0,
      predictions: 0,
      correct: 0,
      lastTrained: 0,
    })

    // Modelo de gesti√≥n de riesgo
    this.models.set('RISK_ASSESSMENT', {
      name: 'Evaluaci√≥n de Riesgo',
      type: 'CLASSIFICATION',
      features: ['volatility', 'correlation', 'market_cap', 'liquidity'],
      accuracy: 0.0,
      predictions: 0,
      correct: 0,
      lastTrained: 0,
    })

    console.log('ü§ñ Modelos de ML inicializados:', Array.from(this.models.keys()))
  }

  async collectTrainingData(marketData, opportunity, result) {
    const features = this.extractFeatures(marketData, opportunity)
    
    const trainingPoint = {
      timestamp: Date.now(),
      features,
      opportunity,
      result,
      profit: result.profit || 0,
      success: result.success || false,
      executionTime: result.executionTime || 0,
    }

    this.trainingData.push(trainingPoint)

    // Mantener solo los √∫ltimos 10,000 puntos de datos
    if (this.trainingData.length > 10000) {
      this.trainingData = this.trainingData.slice(-10000)
    }

    // Entrenar modelos peri√≥dicamente
    if (this.shouldRetrain()) {
      await this.retrainModels()
    }
  }

  extractFeatures(marketData, opportunity) {
    return {
      // Caracter√≠sticas de precio
      price: opportunity.buyPrice,
      priceChange24h: marketData.priceChange24h || 0,
      volume24h: marketData.volume24h || 0,
      
      // Caracter√≠sticas t√©cnicas
      rsi: this.calculateRSI(marketData.prices || []),
      macd: this.calculateMACD(marketData.prices || []),
      bollingerPosition: this.calculateBollingerPosition(marketData.prices || []),
      
      // Caracter√≠sticas de oportunidad
      spread: opportunity.finalProfit,
      volumeRatio: this.calculateVolumeRatio(marketData),
      priceVolatility: this.calculateVolatility(marketData.prices || []),
      
      // Caracter√≠sticas de mercado
      marketSentiment: this.calculateMarketSentiment(marketData),
      liquidity: marketData.liquidity || 0,
      correlation: this.calculateCorrelation(marketData),
      
      // Caracter√≠sticas temporales
      hourOfDay: new Date().getHours(),
      dayOfWeek: new Date().getDay(),
      isWeekend: [0, 6].includes(new Date().getDay()),
    }
  }

  calculateRSI(prices, period = 14) {
    if (prices.length < period + 1) return 50

    let gains = 0
    let losses = 0

    for (let i = 1; i <= period; i++) {
      const change = prices[prices.length - i] - prices[prices.length - i - 1]
      if (change > 0) gains += change
      else losses += Math.abs(change)
    }

    const avgGain = gains / period
    const avgLoss = losses / period
    
    if (avgLoss === 0) return 100
    
    const rs = avgGain / avgLoss
    return 100 - (100 / (1 + rs))
  }

  calculateMACD(prices, fastPeriod = 12, slowPeriod = 26) {
    if (prices.length < slowPeriod) return 0

    const fastEMA = this.calculateEMA(prices, fastPeriod)
    const slowEMA = this.calculateEMA(prices, slowPeriod)
    
    return fastEMA - slowEMA
  }

  calculateEMA(prices, period) {
    if (prices.length === 0) return 0
    
    const multiplier = 2 / (period + 1)
    let ema = prices[0]
    
    for (let i = 1; i < prices.length; i++) {
      ema = (prices[i] * multiplier) + (ema * (1 - multiplier))
    }
    
    return ema
  }

  calculateBollingerPosition(prices, period = 20) {
    if (prices.length < period) return 0.5

    const recentPrices = prices.slice(-period)
    const sma = recentPrices.reduce((a, b) => a + b) / period
    const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period
    const stdDev = Math.sqrt(variance)
    
    const currentPrice = prices[prices.length - 1]
    const upperBand = sma + (2 * stdDev)
    const lowerBand = sma - (2 * stdDev)
    
    // Posici√≥n entre 0 (banda inferior) y 1 (banda superior)
    return (currentPrice - lowerBand) / (upperBand - lowerBand)
  }

  calculateVolumeRatio(marketData) {
    const currentVolume = marketData.volume24h || 0
    const avgVolume = marketData.avgVolume || currentVolume
    return avgVolume > 0 ? currentVolume / avgVolume : 1
  }

  calculateVolatility(prices, period = 20) {
    if (prices.length < period) return 0

    const recentPrices = prices.slice(-period)
    const returns = []
    
    for (let i = 1; i < recentPrices.length; i++) {
      returns.push((recentPrices[i] - recentPrices[i-1]) / recentPrices[i-1])
    }
    
    const avgReturn = returns.reduce((a, b) => a + b) / returns.length
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
    
    return Math.sqrt(variance) * Math.sqrt(365) // Volatilidad anualizada
  }

  calculateMarketSentiment(marketData) {
    // Sentimiento simplificado basado en varios factores
    let sentiment = 0.5 // Neutral

    // Ajustar por cambio de precio
    if (marketData.priceChange24h > 0) sentiment += 0.1
    else if (marketData.priceChange24h < 0) sentiment -= 0.1

    // Ajustar por volumen
    const volumeRatio = this.calculateVolumeRatio(marketData)
    if (volumeRatio > 1.2) sentiment += 0.1
    else if (volumeRatio < 0.8) sentiment -= 0.1

    return Math.max(0, Math.min(1, sentiment))
  }

  calculateCorrelation(marketData) {
    // Correlaci√≥n simplificada - en producci√≥n usar datos reales de m√∫ltiples activos
    return marketData.correlation || 0.5
  }

  shouldRetrain() {
    const now = Date.now()
    const hasEnoughData = this.trainingData.length >= 100
    const timeToRetrain = now - this.lastTraining > this.minTrainingInterval
    
    return hasEnoughData && timeToRetrain
  }

  async retrainModels() {
    console.log('üîÑ Reentrenando modelos de ML...')
    
    try {
      for (const [modelName, model] of this.models.entries()) {
        await this.trainModel(modelName, model)
      }
      
      this.lastTraining = Date.now()
      console.log('‚úÖ Modelos reentrenados exitosamente')
      
      // Guardar modelos entrenados
      await this.saveModels()
      
    } catch (error) {
      console.error('‚ùå Error reentrenando modelos:', error)
    }
  }

  async trainModel(modelName, model) {
    // Preparar datos de entrenamiento
    const trainingSet = this.prepareTrainingData(model)
    
    if (trainingSet.length < 50) {
      console.log(‚ö†Ô∏è Datos insuficientes para entrenar ${modelName}`)
      return
    }

    // Simulaci√≥n de entrenamiento (en producci√≥n usar TensorFlow.js o similar)
    const accuracy = this.simulateTraining(trainingSet, model)
    
    // Actualizar m√©tricas del modelo
    model.accuracy = accuracy
    model.lastTrained = Date.now()
    
    console.log(`üìä Modelo ${modelName} entrenado - Precisi√≥n: ${(accuracy * 100).toFixed(2)}%`)
  }

  prepareTrainingData(model) {
    return this.trainingData
      .filter(point => point.features && point.result)
      .map(point => ({
        features: model.features.map(feature => point.features[feature] || 0),
        target: this.getTarget(point, model.type),
      }))
  }

  getTarget(dataPoint, modelType) {
    switch (modelType) {
      case 'REGRESSION':
        return dataPoint.profit || 0
      case 'CLASSIFICATION':
        return dataPoint.success ? 1 : 0
      default:
        return 0
    }
  }

  simulateTraining(trainingSet, model) {
    // Simulaci√≥n simple de entrenamiento
    // En producci√≥n, aqu√≠ ir√≠a el algoritmo real de ML
    
    const correctPredictions = trainingSet.filter(point => {
      const prediction = this.makeSimplePrediction(point.features, model)
      const actual = point.target
      
      if (model.type === 'CLASSIFICATION') {
        return (prediction > 0.5 && actual === 1) || (prediction <= 0.5 && actual === 0)
      } else {
        return Math.abs(prediction - actual) < Math.abs(actual) * 0.1 // 10% de tolerancia
      }
    }).length

    return correctPredictions / trainingSet.length
  }

  makeSimplePrediction(features, model) {
    // Predicci√≥n simple basada en pesos aleatorios
    // En producci√≥n usar modelo entrenado real
    
    const weights = model.weights || features.map(() => Math.random() - 0.5)
    if (!model.weights) model.weights = weights
    
    let prediction = 0
    for (let i = 0; i < features.length; i++) {
      prediction += features[i] * weights[i]
    }
    
    return model.type === 'CLASSIFICATION' ? this.sigmoid(prediction) : prediction
  }

  sigmoid(x) {
    return 1 / (1 + Math.exp(-x))
  }

  async predictOpportunitySuccess(opportunity, marketData) {
    const features = this.extractFeatures(marketData, opportunity)
    const model = this.models.get('OPPORTUNITY_DETECTION')
    
    if (!model || model.accuracy < 0.6) {
      return { confidence: 0.5, prediction: 'UNCERTAIN', reason: 'Modelo no entrenado suficientemente' }
    }

    const featureVector = model.features.map(feature => features[feature] || 0)
    const prediction = this.makeSimplePrediction(featureVector, model)
    
    // Actualizar estad√≠sticas del modelo
    model.predictions++
    
    return {
      confidence: prediction,
      prediction: prediction > 0.7 ? 'SUCCESS' : prediction < 0.3 ? 'FAILURE' : 'UNCERTAIN',
      reason: this.explainPrediction(featureVector, model),
      modelAccuracy: model.accuracy,
    }
  }

  async predictPriceMovement(pair, marketData, timeframe = '1h') {
    const features = this.extractFeatures(marketData, { pair })
    const model = this.models.get('PRICE_PREDICTION')
    
    if (!model || model.accuracy < 0.6) {
      return { direction: 'NEUTRAL', confidence: 0.5, change: 0 }
    }

    const featureVector = model.features.map(feature => features[feature] || 0)
    const prediction = this.makeSimplePrediction(featureVector, model)
    
    return {
      direction: prediction > 0.01 ? 'UP' : prediction < -0.01 ? 'DOWN' : 'NEUTRAL',
      confidence: Math.abs(prediction),
      change: prediction,
      timeframe,
    }
  }

  async assessRisk(opportunity, marketData) {
    const features = this.extractFeatures(marketData, opportunity)
    const model = this.models.get('RISK_ASSESSMENT')
    
    if (!model || model.accuracy < 0.6) {
      return { risk: 'MEDIUM', confidence: 0.5, factors: [] }
    }

    const featureVector = model.features.map(feature => features[feature] || 0)
    const riskScore = this.makeSimplePrediction(featureVector, model)
    
    const riskLevel = riskScore > 0.7 ? 'HIGH' : riskScore < 0.3 ? 'LOW' : 'MEDIUM'
    
    return {
      risk: riskLevel,
      score: riskScore,
      confidence: model.accuracy,
      factors: this.identifyRiskFactors(features),
    }
  }

  explainPrediction(features, model) {
    const weights = model.weights || []
    const contributions = features.map((feature, i) => ({
      feature: model.features[i],
      value: feature,
      weight: weights[i] || 0,
      contribution: feature * (weights[i] || 0),
    }))

    contributions.sort((a, b) => Math.abs(b.contribution) - Math.abs(a.contribution))
    
    const topFactors = contributions.slice(0, 3)
    return `Factores principales: ${topFactors.map(f => f.feature).join(', ')}`
  }

  identifyRiskFactors(features) {
    const factors = []
    
    if (features.priceVolatility > 0.3) factors.push('Alta volatilidad')
    if (features.volumeRatio < 0.5) factors.push('Volumen bajo')
    if (features.rsi > 80) factors.push('Sobrecompra (RSI)')
    if (features.rsi < 20) factors.push('Sobreventa (RSI)')
    if (features.spread < 0.2) factors.push('Spread muy bajo')
    
    return factors
  }

  async saveModels() {
    try {
      const modelsData = {
        models: Object.fromEntries(this.models),
        lastTraining: this.lastTraining,
        trainingDataCount: this.trainingData.length,
      }
      
      const modelsPath = path.join(__dirname, 'models.json')
      await fs.writeFile(modelsPath, JSON.stringify(modelsData, null, 2))
      
      console.log('üíæ Modelos guardados exitosamente')
    } catch (error) {
      console.error('‚ùå Error guardando modelos:', error)
    }
  }

  async loadModels() {
    try {
      const modelsPath = path.join(__dirname, 'models.json')
      const data = await fs.readFile(modelsPath, 'utf8')
      const modelsData = JSON.parse(data)
      
      this.models = new Map(Object.entries(modelsData.models))
      this.lastTraining = modelsData.lastTraining || 0
      
      console.log('üìÇ Modelos cargados exitosamente')
    } catch (error) {
      console.log('‚ÑπÔ∏è No se encontraron modelos guardados, usando configuraci√≥n por defecto')
    }
  }

  getModelStats() {
    const stats = {}
    
    for (const [name, model] of this.models.entries()) {
      stats[name] = {
        name: model.name,
        type: model.type,
        accuracy: model.accuracy,
        predictions: model.predictions,
        lastTrained: model.lastTrained,
        features: model.features.length,
      }
    }
    
    return {
      models: stats,
      trainingDataPoints: this.trainingData.length,
      lastTraining: this.lastTraining,
      nextTraining: this.lastTraining + this.minTrainingInterval,
    }
  }
}

module.exports = { MLEngine }
--------------------------------------------------------------------------------------------------------------

const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');

/**
 * Asesor de Trading con IA
 * Utiliza modelos de machine learning para analizar oportunidades y hacer recomendaciones
 */
class AITradingAdvisor extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.enabled = config.AI_TRADING.ENABLED;
        this.modelPath = config.AI_TRADING.MODEL_PATH;
        this.trainingDataDays = config.AI_TRADING.TRAINING_DATA_DAYS;
        this.predictionHorizon = config.AI_TRADING.PREDICTION_HORIZON;
        this.features = config.AI_TRADING.FEATURES;
        this.models = config.AI_TRADING.MODELS;
        this.autoRetrain = config.AI_TRADING.AUTO_RETRAIN;
        this.retrainThreshold = config.AI_TRADING.RETRAIN_THRESHOLD;
        
        this.priceModel = null;
        this.opportunityModel = null;
        this.riskModel = null;
        
        this.marketData = [];
        this.lastPredictions = {};
        this.modelAccuracy = {
            priceModel: 0,
            opportunityModel: 0,
            riskModel: 0
        };
        
        this.logger = console;
    }
    
    /**
     * Inicializa el asesor de IA
     */
    async initialize() {
        if (!this.enabled) {
            this.logger.info('AI Trading Advisor deshabilitado');
            return;
        }
        
        this.logger.info('Inicializando AI Trading Advisor...');
        
        try {
            // Crear directorio de modelos si no existe
            await this.ensureModelDirectory();
            
            // Cargar modelos existentes o crear nuevos
            await this.loadModels();
            
            this.logger.info('AI Trading Advisor inicializado correctamente');
        } catch (error) {
            this.logger.error('Error inicializando AI Trading Advisor:', error);
            throw error;
        }
    }
    
    /**
     * Asegura que el directorio de modelos exista
     */
    async ensureModelDirectory() {
        try {
            await fs.mkdir(this.modelPath, { recursive: true });
        } catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
    }
    
    /**
     * Carga los modelos de ML o crea nuevos si no existen
     */
    async loadModels() {
        try {
            // En una implementaci√≥n real, aqu√≠ cargar√≠amos modelos de TensorFlow.js, ONNX, etc.
            // Para esta implementaci√≥n, usaremos modelos simulados
            
            this.priceModel = await this.loadOrCreateModel('price_prediction');
            this.opportunityModel = await this.loadOrCreateModel('opportunity_scoring');
            this.riskModel = await this.loadOrCreateModel('risk_assessment');
            
            this.logger.info('Modelos cargados correctamente');
        } catch (error) {
            this.logger.error('Error cargando modelos:', error);
            throw error;
        }
    }
    
    /**
     * Carga un modelo espec√≠fico o crea uno nuevo
     * @param {string} modelType - Tipo de modelo
     * @returns {Object} - Modelo cargado
     */
    async loadOrCreateModel(modelType) {
        const modelFilePath = path.join(this.modelPath, `${modelType}.json`);
        
        try {
            // Intentar cargar el modelo
            const modelData = await fs.readFile(modelFilePath, 'utf8');
            const model = JSON.parse(modelData);
            this.logger.info(`Modelo ${modelType} cargado correctamente`);
            return model;
        } catch (error) {
            // Si el modelo no existe, crear uno nuevo
            if (error.code === 'ENOENT') {
                this.logger.info(`Modelo ${modelType} no encontrado, creando uno nuevo...`);
                const newModel = await this.createModel(modelType);
                
                // Guardar el nuevo modelo
                await fs.writeFile(modelFilePath, JSON.stringify(newModel, null, 2));
                
                return newModel;
            }
            
            throw error;
        }
    }
    
    /**
     * Crea un nuevo modelo
     * @param {string} modelType - Tipo de modelo
     * @returns {Object} - Nuevo modelo
     */
    async createModel(modelType) {
        // En una implementaci√≥n real, aqu√≠ crear√≠amos y entrenar√≠amos un modelo real
        // Para esta implementaci√≥n, usaremos un modelo simulado
        
        switch (modelType) {
            case 'price_prediction':
                return {
                    type: 'lstm',
                    version: '1.0.0',
                    created: new Date().toISOString(),
                    weights: this.generateRandomWeights(100),
                    biases: this.generateRandomWeights(10),
                    config: this.models.PRICE_PREDICTION
                };
                
            case 'opportunity_scoring':
                return {
                    type: 'random_forest',
                    version: '1.0.0',
                    created: new Date().toISOString(),
                    trees: this.generateRandomTrees(this.models.OPPORTUNITY_SCORING.nEstimators),
                    config: this.models.OPPORTUNITY_SCORING
                };
                
            case 'risk_assessment':
                return {
                    type: 'gradient_boosting',
                    version: '1.0.0',
                    created: new Date().toISOString(),
                    trees: this.generateRandomTrees(this.models.RISK_ASSESSMENT.nEstimators),
                    config: this.models.RISK_ASSESSMENT
                };
                
            default:
                throw new Error(`Tipo de modelo desconocido: ${modelType}`);
        }
    }
    
    /**
     * Genera pesos aleatorios para simular un modelo
     * @param {number} size - Tama√±o del array
     * @returns {Array} - Array de pesos aleatorios
     */
    generateRandomWeights(size) {
        return Array.from({ length: size }, () => Math.random() * 2 - 1);
    }
    
    /**
     * Genera √°rboles aleatorios para simular un modelo de bosque
     * @param {number} numTrees - N√∫mero de √°rboles
     * @returns {Array} - Array de √°rboles aleatorios
     */
    generateRandomTrees(numTrees) {
        return Array.from({ length: numTrees }, () => ({
            depth: Math.floor(Math.random() * 10) + 3,
            nodes: Math.floor(Math.random() * 100) + 20,
            weights: this.generateRandomWeights(20)
        }));
    }
    
    /**
     * Analiza oportunidades de arbitraje usando IA
     * @param {Array} opportunities - Lista de oportunidades
     * @returns {Array} - Oportunidades analizadas con recomendaciones
     */
    async analyzeOpportunities(opportunities) {
        if (!this.enabled || !opportunities.length) {
            return opportunities;
        }
        
        try {
            // Preparar datos para el an√°lisis
            const preparedData = this.prepareDataForAnalysis(opportunities);
            
            // Predecir precios futuros
            const pricePredictions = await this.predictPrices(preparedData);
            
            // Evaluar oportunidades
            const scoredOpportunities = await this.scoreOpportunities(opportunities, pricePredictions);
            
            // Evaluar riesgos
            const riskAssessment = await this.assessRisks(scoredOpportunities);
            
            // Generar recomendaciones
            const recommendedOpportunities = this.generateRecommendations(riskAssessment);
            
            // Evaluar si se necesita cambiar de estrategia
            const strategyRecommendation = this.recommendStrategy(recommendedOpportunities);
            if (strategyRecommendation) {
                this.emit('recommendation', strategyRecommendation);
            }
            
            return recommendedOpportunities;
        } catch (error) {
            this.logger.error('Error analizando oportunidades con IA:', error);
            return opportunities; // Devolver oportunidades originales en caso de error
        }
    }
    
    /**
     * Prepara los datos para el an√°lisis
     * @param {Array} opportunities - Lista de oportunidades
     * @returns {Object} - Datos preparados
     */
    prepareDataForAnalysis(opportunities) {
        // Extraer pares √∫nicos
        const uniquePairs = [...new Set(opportunities.map(opp => opp.pair))];
        
        // Preparar datos por par
        const preparedData = {};
        
        for (const pair of uniquePairs) {
            const pairOpportunities = opportunities.filter(opp => opp.pair === pair);
            
            preparedData[pair] = {
                prices: pairOpportunities.map(opp => ({
                    exchange: opp.exchanges[0],
                    price: opp.buyPrice
                })),
                volumes: pairOpportunities.map(opp => ({
                    exchange: opp.exchanges[0],
                    volume: opp.volume || 1000 // Valor por defecto si no hay volumen
                })),
                spreads: pairOpportunities.map(opp => opp.profitPercentage),
                timestamp: Date.now()
            };
        }
        
        return preparedData;
    }
    
    /**
     * Predice precios futuros
     * @param {Object} data - Datos preparados
     * @returns {Object} - Predicciones de precios
     */
    async predictPrices(data) {
        // En una implementaci√≥n real, aqu√≠ usar√≠amos el modelo LSTM para predecir precios
        // Para esta implementaci√≥n, usaremos predicciones simuladas
        
        const predictions = {};
        
        for (const pair in data) {
            predictions[pair] = {};
            
            for (const priceData of data[pair].prices) {
                const exchange = priceData.exchange;
                const currentPrice = priceData.price;
                
                // Simular predicci√≥n con una variaci√≥n aleatoria de ¬±2%
                const randomFactor = 1 + (Math.random() * 0.04 - 0.02);
                predictions[pair][exchange] = currentPrice * randomFactor;
            }
        }
        
        return predictions;
    }
    
    /**
     * Eval√∫a y punt√∫a oportunidades
     * @param {Array} opportunities - Lista de oportunidades
     * @param {Object} pricePredictions - Predicciones de precios
     * @returns {Array} - Oportunidades puntuadas
     */
    async scoreOpportunities(opportunities, pricePredictions) {
        return opportunities.map(opportunity => {
            const { pair, exchanges } = opportunity;
            
            // Obtener predicciones para este par y exchanges
            const buyExchange = exchanges[0];
            const sellExchange = exchanges[1];
            
            let predictedProfit = opportunity.profitPercentage;
            
            // Si tenemos predicciones para ambos exchanges, calcular ganancia predicha
            if (pricePredictions[pair] && 
                pricePredictions[pair][buyExchange] && 
                pricePredictions[pair][sellExchange]) {
                
                const predictedBuyPrice = pricePredictions[pair][buyExchange];
                const predictedSellPrice = pricePredictions[pair][sellExchange];
                
                predictedProfit = ((predictedSellPrice - predictedBuyPrice) / predictedBuyPrice) * 100;
            }
            
            // Calcular puntuaci√≥n basada en ganancia actual y predicha
            const score = this.calculateOpportunityScore(opportunity, predictedProfit);
            
            return {
                ...opportunity,
                aiScore: score,
                predictedProfit
            };
        });
    }
    
    /**
     * Calcula la puntuaci√≥n de una oportunidad
     * @param {Object} opportunity - Oportunidad de arbitraje
     * @param {number} predictedProfit - Ganancia predicha
     * @returns {number} - Puntuaci√≥n (0-100)
     */
    calculateOpportunityScore(opportunity, predictedProfit) {
        // Factores para la puntuaci√≥n
        const currentProfitWeight = 0.4;
        const predictedProfitWeight = 0.3;
        const volumeWeight = 0.15;
        const exchangeReliabilityWeight = 0.15;
        
        // Normalizar ganancia actual (0-100)
        const normalizedCurrentProfit = Math.min(opportunity.profitPercentage * 20, 100);
        
        // Normalizar ganancia predicha (0-100)
        const normalizedPredictedProfit = Math.min(predictedProfit * 20, 100);
        
        // Normalizar volumen (asumiendo que mayor volumen es mejor, hasta cierto punto)
        const volume = opportunity.volume || 1000; // Valor por defecto
        const normalizedVolume = Math.min(volume / 10000 * 100, 100);
        
        // Fiabilidad de exchanges (valores simulados)
        const exchangeReliability = {
            'Binance': 95,
            'Coinbase': 90,
            'Kraken': 85,
            'Kucoin': 80
        };
        
        // Calcular fiabilidad promedio de los exchanges involucrados
        const avgExchangeReliability = opportunity.exchanges.reduce((sum, exchange) => {
            return sum + (exchangeReliability[exchange] || 70);
        }, 0) / opportunity.exchanges.length;
        
        // Calcular puntuaci√≥n final
        const score = (
            normalizedCurrentProfit * currentProfitWeight +
            normalizedPredictedProfit * predictedProfitWeight +
            normalizedVolume * volumeWeight +
            avgExchangeReliability * exchangeReliabilityWeight
        );
        
        return Math.round(score);
    }
    
    /**
     * Eval√∫a los riesgos de las oportunidades
     * @param {Array} opportunities - Oportunidades puntuadas
     * @returns {Array} - Oportunidades con evaluaci√≥n de riesgo
     */
    async assessRisks(opportunities) {
        return opportunities.map(opportunity => {
            // En una implementaci√≥n real, aqu√≠ usar√≠amos el modelo de evaluaci√≥n de riesgos
            // Para esta implementaci√≥n, usaremos una evaluaci√≥n simulada
            
            // Factores de riesgo
            const volatilityRisk = Math.random() * 40; // 0-40
            const liquidityRisk = Math.random() * 30; // 0-30
            const exchangeRisk = Math.random() * 20; // 0-20
            const timingRisk = Math.random() * 10; // 0-10
            
            // Riesgo total (0-100)
            const totalRisk = volatilityRisk + liquidityRisk + exchangeRisk + timingRisk;
            
            // Categor√≠a de riesgo
            let riskCategory;
            if (totalRisk < 30) {
                riskCategory = 'low';
            } else if (totalRisk < 60) {
                riskCategory = 'medium';
            } else {
                riskCategory = 'high';
            }
            
            return {
                ...opportunity,
                riskAssessment: {
                    volatilityRisk,
                    liquidityRisk,
                    exchangeRisk,
                    timingRisk,
                    totalRisk,
                    riskCategory
                }
            };
        });
    }
    
    /**
     * Genera recomendaciones finales
     * @param {Array} opportunities - Oportunidades con evaluaci√≥n de riesgo
     * @returns {Array} - Oportunidades con recomendaciones
     */
    generateRecommendations(opportunities) {
        return opportunities.map(opportunity => {
            // Calcular puntuaci√≥n final (score - riesgo)
            const finalScore = opportunity.aiScore - (opportunity.riskAssessment.totalRisk / 2);
            
            // Determinar acci√≥n recomendada
            let action;
            if (finalScore >= 70) {
                action = 'execute'; // Ejecutar inmediatamente
            } else if (finalScore >= 50) {
                action = 'monitor'; // Monitorear para posible ejecuci√≥n
            } else {
                action = 'ignore'; // Ignorar esta oportunidad
            }
            
            // Determinar tama√±o de inversi√≥n recomendado
            let recommendedSize;
            if (finalScore >= 80) {
                recommendedSize = 1.0; // 100% del tama√±o m√°ximo
            } else if (finalScore >= 70) {
                recommendedSize = 0.75; // 75% del tama√±o m√°ximo
            } else if (finalScore >= 60) {
                recommendedSize = 0.5; // 50% del tama√±o m√°ximo
            } else {
                recommendedSize = 0.25; // 25% del tama√±o m√°ximo
            }
            
            return {
                ...opportunity,
                aiRecommendation: {
                    finalScore,
                    action,
                    recommendedSize,
                    confidence: finalScore / 100,
                    reasoning: this.generateReasoning(opportunity, finalScore)
                }
            };
        });
    }
    
    /**
     * Genera un razonamiento para la recomendaci√≥n
     * @param {Object} opportunity - Oportunidad evaluada
     * @param {number} finalScore - Puntuaci√≥n final
     * @returns {string} - Razonamiento
     */
    generateReasoning(opportunity, finalScore) {
        const { profitPercentage, predictedProfit, riskAssessment } = opportunity;
        
        if (finalScore >= 70) {
            return `Alta probabilidad de ganancia (${profitPercentage.toFixed(2)}% actual, ${predictedProfit.toFixed(2)}% predicha) con riesgo ${riskAssessment.riskCategory}.`;
        } else if (finalScore >= 50) {
            return `Ganancia moderada (${profitPercentage.toFixed(2)}%) con algunas se√±ales de precauci√≥n. Riesgo ${riskAssessment.riskCategory}.`;
        } else {
            return `Baja probabilidad de √©xito. Ganancia insuficiente (${profitPercentage.toFixed(2)}%) para el nivel de riesgo ${riskAssessment.riskCategory}.`;
        }
    }
    
    /**
     * Recomienda cambios de estrategia basados en el an√°lisis
     * @param {Array} opportunities - Oportunidades analizadas
     * @returns {Object|null} - Recomendaci√≥n de estrategia o null
     */
    recommendStrategy(opportunities) {
        // Contar oportunidades por estrategia
        const strategyCounts = {};
        const strategyScores = {};
        
        for (const opp of opportunities) {
            if (!opp.strategy) continue;
            
            if (!strategyCounts[opp.strategy]) {
                strategyCounts[opp.strategy] = 0;
                strategyScores[opp.strategy] = 0;
            }
            
            strategyCounts[opp.strategy]++;
            strategyScores[opp.strategy] += opp.aiRecommendation.finalScore;
        }
        
        // Calcular puntuaci√≥n promedio por estrategia
        for (const strategy in strategyCounts) {
            strategyScores[strategy] /= strategyCounts[strategy];
        }
        
        // Encontrar la estrategia con mejor puntuaci√≥n
        let bestStrategy = null;
        let bestScore = 0;
        
        for (const strategy in strategyScores) {
            if (strategyScores[strategy] > bestScore) {
                bestScore = strategyScores[strategy];
                bestStrategy = strategy;
            }
        }
        
        // Si la mejor estrategia tiene una puntuaci√≥n significativamente mejor, recomendarla
        if (bestStrategy && bestScore > 60) {
            return {
                suggestedStrategy: bestStrategy,
                score: bestScore,
                reason: `La estrategia ${bestStrategy} muestra el mejor rendimiento con una puntuaci√≥n de ${bestScore.toFixed(2)}.`
            };
        }
        
        return null;
    }
    
    /**
     * Actualiza los datos de mercado para entrenamiento
     * @param {Object} marketData - Nuevos datos de mercado
     */
    updateMarketData(marketData) {
        this.marketData.push({
            ...marketData,
            timestamp: Date.now()
        });
        
        // Mantener solo los datos de los √∫ltimos N d√≠as
        const cutoffTime = Date.now() - (this.trainingDataDays * 24 * 60 * 60 * 1000);
        this.marketData = this.marketData.filter(data => data.timestamp >= cutoffTime);
        
        // Verificar si es necesario reentrenar
        if (this.autoRetrain && this.shouldRetrain()) {
            this.retrainModels();
        }
    }
    
    /**
     * Determina si es necesario reentrenar los modelos
     * @returns {boolean} - True si se debe reentrenar
     */
    shouldRetrain() {
        // Verificar si hay suficientes datos nuevos
        if (this.marketData.length < 1000) {
            return false;
        }
        
        // Verificar si la precisi√≥n ha ca√≠do por debajo del umbral
        for (const model in this.modelAccuracy) {
            if (this.modelAccuracy[model] < 1 - this.retrainThreshold) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Reentrenar los modelos con nuevos datos
     */
    async retrainModels() {
        this.logger.info('Reentrenando modelos de IA...');
        
        try {
            // En una implementaci√≥n real, aqu√≠ reentrenaremos los modelos
            // Para esta implementaci√≥n, simularemos el reentrenamiento
            
            // Simular reentrenamiento del modelo de predicci√≥n de precios
            await this.retrainPriceModel();
            
            // Simular reentrenamiento del modelo de puntuaci√≥n de oportunidades
            await this.retrainOpportunityModel();
            
            // Simular reentrenamiento del modelo de evaluaci√≥n de riesgos
            await this.retrainRiskModel();
            
            this.logger.info('Modelos reentrenados correctamente');
        } catch (error) {
            this.logger.error('Error reentrenando modelos:', error);
        }
    }
    
    /**
     * Reentrenar el modelo de predicci√≥n de precios
     */
    async retrainPriceModel() {
        // Simular reentrenamiento
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Actualizar modelo simulado
        this.priceModel.version = `${parseFloat(this.priceModel.version) + 0.1}.0`;
        this.priceModel.updated = new Date().toISOString();
        this.priceModel.weights = this.generateRandomWeights(100);
        this.priceModel.biases = this.generateRandomWeights(10);
        
        // Simular mejora en precisi√≥n
        this.modelAccuracy.priceModel = 0.85 + Math.random() * 0.1;
        
        // Guardar modelo actualizado
        await fs.writeFile(
            path.join(this.modelPath, 'price_prediction.json'),
            JSON.stringify(this.priceModel, null, 2)
        );
    }
    
    /**
     * Reentrenar el modelo de puntuaci√≥n de oportunidades
     */
    async retrainOpportunityModel() {
        // Simular reentrenamiento
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // Actualizar modelo simulado
        this.opportunityModel.version = `${parseFloat(this.opportunityModel.version) + 0.1}.0`;
        this.opportunityModel.updated = new Date().toISOString();
        this.opportunityModel.trees = this.generateRandomTrees(this.models.OPPORTUNITY_SCORING.nEstimators);
        
        // Simular mejora en precisi√≥n
        this.modelAccuracy.opportunityModel = 0.82 + Math.random() * 0.12;
        
        // Guardar modelo actualizado
        await fs.writeFile(
            path.join(this.modelPath, 'opportunity_scoring.json'),
            JSON.stringify(this.opportunityModel, null, 2)
        );
    }
    
    /**
     * Reentrenar el modelo de evaluaci√≥n de riesgos
     */
    async retrainRiskModel() {
        // Simular reentrenamiento
        await new Promise(resolve => setTimeout(resolve, 600));
        
        // Actualizar modelo simulado
        this.riskModel.version = `${parseFloat(this.riskModel.version) + 0.1}.0`;
        this.riskModel.updated = new Date().toISOString();
        this.riskModel.trees = this.generateRandomTrees(this.models.RISK_ASSESSMENT.nEstimators);
        
        // Simular mejora en precisi√≥n
        this.modelAccuracy.riskModel = 0.8 + Math.random() * 0.15;
        
        // Guardar modelo actualizado
        await fs.writeFile(
            path.join(this.modelPath, 'risk_assessment.json'),
            JSON.stringify(this.riskModel, null, 2)
        );
    }
    
    /**
     * Obtiene el estado actual del asesor de IA
     * @returns {Object} - Estado del asesor
     */
    getStatus() {
        return {
            enabled: this.enabled,
            models: {
                priceModel: {
                    version: this.priceModel?.version || 'N/A',
                    accuracy: this.modelAccuracy.priceModel || 0
                },
                opportunityModel: {
                    version: this.opportunityModel?.version || 'N/A',
                    accuracy: this.modelAccuracy.opportunityModel || 0
                },
                riskModel: {
                    version: this.riskModel?.version || 'N/A',
                    accuracy: this.modelAccuracy.riskModel || 0
                }
            },
            dataPoints: this.marketData.length,
            lastUpdated: this.marketData.length ? new Date(Math.max(...this.marketData.map(d => d.timestamp))).toISOString() : 'N/A'
        };
    }
}

module.exports = AITradingAdvisor;

------------------------------------------------------------------------------------------------------------------

ALERTS

const https = require("https")
const EventEmitter = require("events")
const nodemailer = require("nodemailer")
const axios = require("axios")

/**
 * Gestor de Alertas para el Bot de Arbitraje
 */
class AlertManager extends EventEmitter {
  constructor(config) {
    super()
    this.config = config
    this.enabled = config.ALERTS.ENABLED
    this.channels = config.ALERTS.CHANNELS
    this.alertTypes = config.ALERTS.ALERT_TYPES

    this.emailTransporter = null
    this.alertHistory = []
    this.alertQueue = []
    this.isProcessingQueue = false

    this.logger = console

    // ======= AGREGADO DASHBOARD: historial reciente de anomal√≠as =======
    this.anomalies = []
    // ======= FIN AGREGADO =======
  }

  /**
   * Inicializa el gestor de alertas
   */
  async initialize() {
    if (!this.enabled) {
      this.logger.info("Alert Manager deshabilitado")
      return
    }

    this.logger.info("Inicializando Alert Manager...")

    try {
      // Inicializar transportador de email
      if (this.channels.EMAIL.enabled) {
        await this.initializeEmailTransporter()
      }

      // Verificar configuraci√≥n de Telegram
      if (this.channels.TELEGRAM.enabled) {
        await this.verifyTelegramConfig()
      }

      // Iniciar procesamiento de cola
      this.startQueueProcessor()

      // Programar resumen diario
      this.scheduleDailySummary()

      this.logger.info("Alert Manager inicializado correctamente")

      // ENVIAR MENSAJE DE PRUEBA AL INICIALIZAR - CAMBIADO A BOT_STARTED
      await this.sendAlert("BOT_STARTED", "ü§ñ Bot de Arbitraje iniciado correctamente")
    } catch (error) {
      this.logger.error("Error inicializando Alert Manager:", error)
      throw error
    }
  }

  /**
   * Inicializa el transportador de email
   */
  async initializeEmailTransporter() {
    try {
      this.emailTransporter = nodemailer.createTransport(this.channels.EMAIL.smtp)

      // Verificar configuraci√≥n
      await this.emailTransporter.verify()
      this.logger.info("Transportador de email configurado correctamente")
    } catch (error) {
      this.logger.error("Error configurando email:", error)
      this.channels.EMAIL.enabled = false
    }
  }

  /**
   * Verifica la configuraci√≥n de Telegram
   */
  async verifyTelegramConfig() {
    try {
      const { botToken, chatId } = this.channels.TELEGRAM

      // VERIFICAR QUE LAS VARIABLES EST√âN CONFIGURADAS
      this.logger.info("=== VERIFICANDO CONFIGURACI√ìN DE TELEGRAM ===")
      this.logger.info("Bot Token:", botToken ? "CONFIGURADO" : "NO CONFIGURADO")
      this.logger.info("Chat ID:", chatId ? "CONFIGURADO" : "NO CONFIGURADO")

      if (!botToken || botToken === "") {
        throw new Error("TELEGRAM_BOT_TOKEN no est√° configurado en las variables de entorno")
      }

      if (!chatId || chatId === "") {
        throw new Error("TELEGRAM_CHAT_ID no est√° configurado en las variables de entorno")
      }

      // Verificar que el bot est√© activo
      const response = await axios.get(`https://api.telegram.org/bot${botToken}/getMe`)

      if (response.data.ok) {
        this.logger.info(`‚úÖ Bot de Telegram verificado: ${response.data.result.username}`)
      } else {
        throw new Error("Token de bot de Telegram inv√°lido")
      }
    } catch (error) {
      this.logger.error("‚ùå Error verificando Telegram:", error.message)
      // NO DESHABILITAR TELEGRAM, SOLO MOSTRAR EL ERROR
      // this.channels.TELEGRAM.enabled = false;
    }
  }

  /**
   * Inicia el procesador de cola de alertas
   */
  startQueueProcessor() {
    setInterval(async () => {
      if (!this.isProcessingQueue && this.alertQueue.length > 0) {
        await this.processAlertQueue()
      }
    }, 1000)
  }

  /**
   * Procesa la cola de alertas
   */
  async processAlertQueue() {
    this.isProcessingQueue = true

    while (this.alertQueue.length > 0) {
      const alert = this.alertQueue.shift()

      try {
        await this.sendAlertToChannels(alert)
      } catch (error) {
        this.logger.error("Error procesando alerta:", error)
      }

      // Peque√±a pausa entre alertas
      await new Promise((resolve) => setTimeout(resolve, 100))
    }

    this.isProcessingQueue = false
  }

  /**
   * Programa el resumen diario
   */
  scheduleDailySummary() {
    if (!this.alertTypes.DAILY_SUMMARY.enabled) {
      return
    }

    const summaryTime = this.alertTypes.DAILY_SUMMARY.time || "23:59"
    const [hours, minutes] = summaryTime.split(":").map(Number)

    // Calcular tiempo hasta el pr√≥ximo resumen
    const now = new Date()
    const nextSummary = new Date()
    nextSummary.setHours(hours, minutes, 0, 0)

    if (nextSummary <= now) {
      nextSummary.setDate(nextSummary.getDate() + 1)
    }

    const timeUntilSummary = nextSummary.getTime() - now.getTime()

    setTimeout(() => {
      this.sendDailySummary()

      // Programar para el d√≠a siguiente
      setInterval(
        () => {
          this.sendDailySummary()
        },
        24 * 60 * 60 * 1000,
      )
    }, timeUntilSummary)
  }

  /**
   * Env√≠a una alerta
   * @param {string} type - Tipo de alerta ('info', 'warning', 'error', 'trade', 'risk')
   * @param {string} message - Mensaje de la alerta
   * @param {Object} data - Datos adicionales
   */
  async sendAlert(type, message, data = {}) {
    if (!this.enabled) {
      this.logger.info("Alertas deshabilitadas, no se enviar√°:", message)
      return
    }

    // BUSCAR CONFIGURACI√ìN DE ALERTA O USAR VALORES POR DEFECTO
    const alertConfig = this.alertTypes[type.toUpperCase()] || {
      enabled: true,
      channels: ["telegram"],
      priority: "medium",
    }

    if (!alertConfig.enabled) {
      this.logger.info(`Tipo de alerta ${type} deshabilitado`)
      return
    }

    // Crear objeto de alerta
    const alert = {
      id: this.generateAlertId(),
      type,
      message,
      data,
      timestamp: new Date(),
      priority: alertConfig.priority || "medium",
      channels: alertConfig.channels || ["telegram"],
    }

    this.logger.info(`üì¢ Enviando alerta: ${type} - ${message}`)

    // A√±adir a la cola
    this.alertQueue.push(alert)

    // A√±adir al historial
    this.alertHistory.push(alert)

    // ======= AGREGADO DASHBOARD: guardar anomal√≠as si corresponde =======
    if (type && (type.toUpperCase().includes("ANOMALY") || type.toUpperCase().includes("ANOMALIA") || type.toUpperCase().includes("RISK") || type.toUpperCase().includes("VOLATILIDAD") || type.toUpperCase().includes("OPPORTUNITY"))) {
      this.anomalies.push({
        tipo: type,
        descripcion: message,
        timestamp: new Date().toLocaleString(),
        data: data || {},
      })
      if (this.anomalies.length > 100) {
        this.anomalies.shift()
      }
    }
    // ======= FIN AGREGADO DASHBOARD =======

    // Mantener solo las √∫ltimas 1000 alertas
    if (this.alertHistory.length > 1000) {
      this.alertHistory.shift()
    }

    // Emitir evento
    this.emit("alertSent", alert)
  }

  /**
   * Env√≠a una alerta a todos los canales configurados
   */
  async sendAlertToChannels(alert) {
    const promises = []

    for (const channel of alert.channels) {
      switch (channel.toLowerCase()) {
        case "email":
          if (this.channels.EMAIL.enabled) {
            promises.push(this.sendEmailAlert(alert))
          }
          break

        case "telegram":
          if (this.channels.TELEGRAM.enabled) {
            promises.push(this.sendTelegramAlert(alert))
          }
          break

        case "discord":
          if (this.channels.DISCORD.enabled) {
            promises.push(this.sendDiscordAlert(alert))
          }
          break

        case "slack":
          if (this.channels.SLACK.enabled) {
            promises.push(this.sendSlackAlert(alert))
          }
          break
      }
    }

    // Esperar a que se env√≠en todas las alertas
    const results = await Promise.allSettled(promises)

    // MOSTRAR RESULTADOS DE CADA CANAL
    results.forEach((result, index) => {
      if (result.status === "rejected") {
        this.logger.error(`Error enviando alerta por ${alert.channels[index]}:`, result.reason.message)
      }
    })
  }

  /**
   * Env√≠a alerta por email
   */
  async sendEmailAlert(alert) {
    if (!this.emailTransporter) {
      throw new Error("Transportador de email no inicializado")
    }

    const subject = this.formatEmailSubject(alert)
    const html = this.formatEmailBody(alert)

    const mailOptions = {
      from: this.channels.EMAIL.from,
      to: this.channels.EMAIL.to,
      subject,
      html,
    }

    await this.emailTransporter.sendMail(mailOptions)
    this.logger.info(`‚úÖ Alerta enviada por email: ${alert.type}`)
  }

  /**
   * Env√≠a alerta por Telegram
   */
  async sendTelegramAlert(alert) {
    try {
      const { botToken, chatId, parseMode } = this.channels.TELEGRAM

      // VERIFICAR CONFIGURACI√ìN ANTES DE ENVIAR
      if (!botToken || botToken === "") {
        throw new Error("TELEGRAM_BOT_TOKEN no configurado")
      }

      if (!chatId || chatId === "") {
        throw new Error("TELEGRAM_CHAT_ID no configurado")
      }

      const message = this.formatTelegramMessage(alert)
      const url = `https://api.telegram.org/bot${botToken}/sendMessage`

      this.logger.info("üì± Enviando mensaje a Telegram...")

      const response = await axios.post(url, {
        chat_id: chatId,
        text: message,
        parse_mode: parseMode || "HTML",
      })

      if (response.data.ok) {
        this.logger.info(`‚úÖ Alerta enviada por Telegram: ${alert.type}`)
      } else {
        throw new Error(`Error de Telegram: ${response.data.description}`)
      }
    } catch (error) {
      this.logger.error("‚ùå Error enviando alerta por Telegram:", error.message)

      if (error.response) {
        this.logger.error("Respuesta de Telegram:", error.response.data)
      }

      throw error
    }
  }

  /**
   * Env√≠a alerta por Discord
   */
  async sendDiscordAlert(alert) {
    const { webhookUrl } = this.channels.DISCORD
    const embed = this.formatDiscordEmbed(alert)

    await axios.post(webhookUrl, {
      embeds: [embed],
    })

    this.logger.info(`‚úÖ Alerta enviada por Discord: ${alert.type}`)
  }

  /**
   * Env√≠a alerta por Slack
   */
  async sendSlackAlert(alert) {
    const { webhookUrl } = this.channels.SLACK
    const payload = this.formatSlackMessage(alert)

    await axios.post(webhookUrl, payload)

    this.logger.info(`‚úÖ Alerta enviada por Slack: ${alert.type}`)
  }

  /**
   * Formatea el asunto del email
   */
  formatEmailSubject(alert) {
    const priorityEmoji = {
      low: "üîµ",
      medium: "üü°",
      high: "üü†",
      critical: "üî¥",
    }

    const emoji = priorityEmoji[alert.priority] || "üîµ"
    return `${emoji} Bot de Arbitraje - ${alert.type.toUpperCase()}`
  }

  /**
   * Formatea el cuerpo del email
   */
  formatEmailBody(alert) {
    return `
      <html>
      <body style="font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5;">
        <div style="max-width: 600px; margin: 0 auto; background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <h2 style="color: #333; margin-top: 0;">Bot de Arbitraje CEX</h2>
          
          <div style="background-color: ${this.getPriorityColor(alert.priority)}; color: white; padding: 10px; border-radius: 4px; margin: 20px 0;">
            <strong>Tipo:</strong> ${alert.type.toUpperCase()}
          </div>
          
          <div style="margin: 20px 0;">
            <strong>Mensaje:</strong><br>
            ${alert.message}
          </div>
          
          <div style="margin: 20px 0;">
            <strong>Timestamp:</strong> ${alert.timestamp.toLocaleString()}
          </div>
          
          ${
            alert.data && Object.keys(alert.data).length > 0
              ? `
          <div style="margin: 20px 0;">
            <strong>Datos adicionales:</strong><br>
            <pre style="background-color: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto;">${JSON.stringify(alert.data, null, 2)}</pre>
          </div>
          `
              : ""
          }
          
          <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
          
          <p style="color: #666; font-size: 12px; margin: 0;">
            Esta es una notificaci√≥n autom√°tica del Bot de Arbitraje CEX.
          </p>
        </div>
      </body>
      </html>
    `
  }

  /**
   * Formatea el mensaje de Telegram
   */
  formatTelegramMessage(alert) {
    const priorityEmoji = {
      low: "üîµ",
      medium: "üü°",
      high: "üü†",
      critical: "üî¥",
    }

    const emoji = priorityEmoji[alert.priority] || "üîµ"

    let message = `${emoji} <b>Bot de Arbitraje CEX</b>\n\n`
    message += `<b>Tipo:</b> ${alert.type.toUpperCase()}\n`
    message += `<b>Mensaje:</b> ${alert.message}\n`
    message += `<b>Timestamp:</b> ${alert.timestamp.toLocaleString()}\n`

    if (alert.data && Object.keys(alert.data).length > 0) {
      message += `\n<b>Datos:</b>\n`
      for (const [key, value] of Object.entries(alert.data)) {
        message += `‚Ä¢ ${key}: ${value}\n`
      }
    }

    return message
  }

  /**
   * Formatea el embed de Discord
   */
  formatDiscordEmbed(alert) {
    const color = this.getPriorityColorHex(alert.priority)

    const embed = {
      title: `Bot de Arbitraje CEX - ${alert.type.toUpperCase()}`,
      description: alert.message,
      color: Number.parseInt(color.replace("#", ""), 16),
      timestamp: alert.timestamp.toISOString(),
      fields: [],
    }

    if (alert.data && Object.keys(alert.data).length > 0) {
      for (const [key, value] of Object.entries(alert.data)) {
        embed.fields.push({
          name: key,
          value: String(value),
          inline: true,
        })
      }
    }

    return embed
  }

  /**
   * Formatea el mensaje de Slack
   */
  formatSlackMessage(alert) {
    const color = this.getPriorityColor(alert.priority)

    const attachment = {
      color,
      title: `Bot de Arbitraje CEX - ${alert.type.toUpperCase()}`,
      text: alert.message,
      timestamp: Math.floor(alert.timestamp.getTime() / 1000),
      fields: [],
    }

    if (alert.data && Object.keys(alert.data).length > 0) {
      for (const [key, value] of Object.entries(alert.data)) {
        attachment.fields.push({
          title: key,
          value: String(value),
          short: true,
        })
      }
    }

    return {
      attachments: [attachment],
    }
  }

  /**
   * Obtiene el color seg√∫n la prioridad
   */
  getPriorityColor(priority) {
    const colors = {
      low: "#007bff",
      medium: "#ffc107",
      high: "#fd7e14",
      critical: "#dc3545",
    }

    return colors[priority] || colors.medium
  }

  /**
   * Obtiene el color hexadecimal seg√∫n la prioridad
   */
  getPriorityColorHex(priority) {
    const colors = {
      low: "#007bff",
      medium: "#ffc107",
      high: "#fd7e14",
      critical: "#dc3545",
    }

    return colors[priority] || colors.medium
  }

  /**
   * Env√≠a el resumen diario
   */
  async sendDailySummary() {
    try {
      // Obtener alertas del d√≠a
      const today = new Date()
      today.setHours(0, 0, 0, 0)

      const todayAlerts = this.alertHistory.filter((alert) => new Date(alert.timestamp) >= today)

      // Agrupar por tipo
      const alertsByType = {}
      for (const alert of todayAlerts) {
        if (!alertsByType[alert.type]) {
          alertsByType[alert.type] = 0
        }
        alertsByType[alert.type]++
      }

      // Crear mensaje de resumen
      let summary = `üìä Resumen diario del Bot de Arbitraje CEX\n\n`
      summary += `Total de alertas: ${todayAlerts.length}\n\n`

      if (Object.keys(alertsByType).length > 0) {
        summary += `Alertas por tipo:\n`
        for (const [type, count] of Object.entries(alertsByType)) {
          summary += `‚Ä¢ ${type}: ${count}\n`
        }
      } else {
        summary += `No se generaron alertas hoy.`
      }

      // Enviar resumen
      await this.sendAlert("DAILY_SUMMARY", summary)
    } catch (error) {
      this.logger.error("Error enviando resumen diario:", error)
    }
  }

  /**
   * Genera un ID √∫nico para la alerta
   */
  generateAlertId() {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * Obtiene el historial de alertas
   */
  getAlertHistory(limit = 100) {
    return this.alertHistory.slice(-limit)
  }

  /**
   * Obtiene estad√≠sticas de alertas
   */
  getAlertStatistics() {
    const stats = {
      total: this.alertHistory.length,
      byType: {},
      byPriority: {},
      last24Hours: 0,
    }

    const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000)

    for (const alert of this.alertHistory) {
      // Por tipo
      if (!stats.byType[alert.type]) {
        stats.byType[alert.type] = 0
      }
      stats.byType[alert.type]++

      // Por prioridad
      if (!stats.byPriority[alert.priority]) {
        stats.byPriority[alert.priority] = 0
      }
      stats.byPriority[alert.priority]++

      // √öltimas 24 horas
      if (new Date(alert.timestamp) >= last24Hours) {
        stats.last24Hours++
      }
    }

    return stats
  }

  // ======= AGREGADO DASHBOARD: m√©todo para anomalias recientes =======
  getRecentAnomalies(limit = 25) {
    return this.anomalies.slice(-limit)
  }
  // ======= FIN AGREGADO DASHBOARD =======
}

module.exports = AlertManager


-------------------------------------------------------------------------------------------------------------

const nodemailer = require('nodemailer');

/**
 * Gestor de Email para el Bot de Arbitraje
 */
class EmailManager {
  constructor(config) {
    this.config = config;
    this.emailConfig = config.ALERTS.CHANNELS.EMAIL;
    this.transporter = null;
    this.logger = console;
  }

  /**
   * Inicializa el gestor de email
   */
  async initialize() {
    if (!this.emailConfig.enabled) {
      this.logger.info('Email deshabilitado en la configuraci√≥n');
      return;
    }

    try {
      this.logger.info('Inicializando EmailManager...');
      
      // Crear transporter
      this.transporter = nodemailer.createTransporter({
        host: this.emailConfig.smtp.host,
        port: this.emailConfig.smtp.port,
        secure: this.emailConfig.smtp.secure,
        auth: {
          user: this.emailConfig.smtp.auth.user,
          pass: this.emailConfig.smtp.auth.pass,
        },
      });

      // Verificar conexi√≥n
      await this.transporter.verify();
      this.logger.info('‚úÖ Conexi√≥n de email verificada correctamente');
      
      // Enviar email de prueba
      await this.sendTestEmail();
      
    } catch (error) {
      this.logger.error('‚ùå Error inicializando EmailManager:', error.message);
      throw error;
    }
  }

  /**
   * Env√≠a un email de prueba
   */
  async sendTestEmail() {
    try {
      const testMessage = {
        from: this.emailConfig.from,
        to: this.emailConfig.to,
        subject: 'ü§ñ Bot de Arbitraje - Test de Conexi√≥n',
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #2563eb;">ü§ñ Bot de Arbitraje CEX</h2>
            <p>Este es un mensaje de prueba para verificar que las notificaciones por email funcionan correctamente.</p>
            <div style="background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <p><strong>Fecha:</strong> ${new Date().toLocaleString()}</p>
              <p><strong>Estado:</strong> ‚úÖ Conexi√≥n exitosa</p>
            </div>
            <p style="color: #6b7280; font-size: 12px;">
              Este mensaje fue enviado autom√°ticamente por el sistema de alertas.
            </p>
          </div>
        `
      };

      await this.transporter.sendMail(testMessage);
      this.logger.info('‚úÖ Email de prueba enviado correctamente');
      
    } catch (error) {
      this.logger.error('‚ùå Error enviando email de prueba:', error.message);
      throw error;
    }
  }

  /**
   * Env√≠a un email de alerta
   * @param {string} type - Tipo de alerta
   * @param {string} message - Mensaje de la alerta
   * @param {Object} data - Datos adicionales
   */
  async sendAlert(type, message, data = {}) {
    if (!this.emailConfig.enabled || !this.transporter) {
      return;
    }

    try {
      const emailContent = this.formatEmailContent(type, message, data);
      
      const mailOptions = {
        from: this.emailConfig.from,
        to: this.emailConfig.to,
        subject: emailContent.subject,
        html: emailContent.html
      };

      await this.transporter.sendMail(mailOptions);
      this.logger.info(`üìß Email enviado: ${type} - ${message}`);
      
    } catch (error) {
      this.logger.error('‚ùå Error enviando email:', error.message);
    }
  }

  /**
   * Formatea el contenido del email seg√∫n el tipo
   * @param {string} type - Tipo de alerta
   * @param {string} message - Mensaje
   * @param {Object} data - Datos adicionales
   * @returns {Object} - Contenido formateado
   */
  formatEmailContent(type, message, data) {
    const timestamp = new Date().toLocaleString();
    let emoji = 'üì¢';
    let color = '#6b7280';
    let priority = 'Normal';

    switch (type) {
      case 'info':
        emoji = '‚ÑπÔ∏è';
        color = '#2563eb';
        priority = 'Informaci√≥n';
        break;
      case 'warning':
        emoji = '‚ö†Ô∏è';
        color = '#f59e0b';
        priority = 'Advertencia';
        break;
      case 'error':
        emoji = '‚ùå';
        color = '#dc2626';
        priority = 'Error';
        break;
      case 'trade':
        emoji = 'üí∞';
        color = '#059669';
        priority = 'Operaci√≥n';
        break;
      case 'risk':
        emoji = 'üö®';
        color = '#dc2626';
        priority = 'Riesgo Alto';
        break;
      case 'profit':
        emoji = 'üíµ';
        color = '#059669';
        priority = 'Ganancia';
        break;
      case 'balance':
        emoji = 'üí≥';
        color = '#7c3aed';
        priority = 'Balance';
        break;
    }

    const subject = `${emoji} Bot Arbitraje - ${priority}: ${message.substring(0, 50)}...`;

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; background-color: #ffffff;">
        <div style="background-color: ${color}; color: white; padding: 20px; text-align: center;">
          <h1 style="margin: 0; font-size: 24px;">${emoji} Bot de Arbitraje CEX</h1>
          <p style="margin: 5px 0 0 0; opacity: 0.9;">Alerta de ${priority}</p>
        </div>
        
        <div style="padding: 30px;">
          <div style="background-color: #f9fafb; border-left: 4px solid ${color}; padding: 15px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; color: ${color};">Mensaje:</h3>
            <p style="margin: 0; font-size: 16px; line-height: 1.5;">${message}</p>
          </div>

          ${data.details ? `
            <div style="background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin: 0 0 10px 0; color: #374151;">Detalles:</h4>
              <pre style="margin: 0; font-family: monospace; font-size: 12px; white-space: pre-wrap;">${JSON.stringify(data.details, null, 2)}</pre>
            </div>
          ` : ''}

          ${data.balances ? `
            <div style="background-color: #ecfdf5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin: 0 0 10px 0; color: #065f46;">üí≥ Balances Actuales:</h4>
              ${Object.entries(data.balances).map(([exchange, balance]) => 
                `<p style="margin: 5px 0;"><strong>${exchange}:</strong> $${balance.toFixed(2)}</p>`
              ).join('')}
            </div>
          ` : ''}

          ${data.profit ? `
            <div style="background-color: #ecfdf5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin: 0 0 10px 0; color: #065f46;">üí∞ Informaci√≥n de Ganancia:</h4>
              <p style="margin: 5px 0;"><strong>Ganancia:</strong> $${data.profit.toFixed(2)}</p>
              <p style="margin: 5px 0;"><strong>Porcentaje:</strong> ${data.profitPercentage?.toFixed(2)}%</p>
            </div>
          ` : ''}

          <div style="border-top: 1px solid #e5e7eb; padding-top: 15px; margin-top: 20px;">
            <p style="margin: 0; color: #6b7280; font-size: 12px;">
              <strong>Fecha:</strong> ${timestamp}<br>
              <strong>Tipo:</strong> ${priority}<br>
              <strong>Sistema:</strong> Bot de Arbitraje CEX con IA
            </p>
          </div>
        </div>

        <div style="background-color: #f9fafb; padding: 15px; text-align: center; border-top: 1px solid #e5e7eb;">
          <p style="margin: 0; color: #6b7280; font-size: 11px;">
            Este mensaje fue enviado autom√°ticamente por el sistema de alertas del Bot de Arbitraje.
          </p>
        </div>
      </div>
    `;

    return { subject, html };
  }

  /**
   * Env√≠a resumen diario por email
   * @param {Object} stats - Estad√≠sticas del d√≠a
   */
  async sendDailySummary(stats) {
    const data = {
      details: stats,
      balances: stats.balances,
      profit: stats.totalProfit
    };

    const message = `Resumen diario del bot de arbitraje:
    
üí∞ Ganancia Total: $${stats.totalProfit.toFixed(2)}
üìà Operaciones Exitosas: ${stats.successfulTrades}
üìâ Operaciones Fallidas: ${stats.failedTrades}
üéØ Tasa de √âxito: ${((stats.successfulTrades / (stats.totalTrades || 1)) * 100).toFixed(1)}%
‚ö° Latencia Promedio: ${stats.averageLatency}`;

    await this.sendAlert('info', message, data);
  }
}

module.exports = EmailManager;


----------------------------------------------------------------------------------------------------------------

BACKTESTING

// ========== MOTOR DE BACKTESTING HIST√ìRICO ==========
const fs = require('fs').promises
const path = require('path')
const config = require("../strategies/config") // ‚úÖ CORRECTO

class BacktestEngine {
  constructor(strategyManager) {
    this.strategyManager = strategyManager
    this.historicalData = new Map()
    this.backtestResults = []
    this.isRunning = false
  }

  async loadHistoricalData(pair, startDate, endDate) {
    try {
      const dataPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, `${pair.replace('/', '_')}.json`)
      
      // Intentar cargar datos existentes
      try {
        const data = await fs.readFile(dataPath, 'utf8')
        const historicalData = JSON.parse(data)
        
        // Filtrar por rango de fechas
        const filteredData = historicalData.filter(point => {
          const timestamp = new Date(point.timestamp).getTime()
          return timestamp >= startDate.getTime() && timestamp <= endDate.getTime()
        })
        
        this.historicalData.set(pair, filteredData)
        console.log(`üìä Cargados ${filteredData.length} puntos de datos hist√≥ricos para ${pair}`)
        
        return filteredData
      } catch (fileError) {
        // Si no hay datos hist√≥ricos, generar datos simulados
        console.log(`‚ö†Ô∏è No se encontraron datos hist√≥ricos para ${pair}, generando datos simulados...`)
        const simulatedData = this.generateSimulatedData(pair, startDate, endDate)
        this.historicalData.set(pair, simulatedData)
        
        // Guardar datos simulados para uso futuro
        await this.saveHistoricalData(pair, simulatedData)
        
        return simulatedData
      }
    } catch (error) {
      console.error(`‚ùå Error cargando datos hist√≥ricos para ${pair}:`, error)
      throw error
    }
  }

  generateSimulatedData(pair, startDate, endDate) {
    const data = []
    const basePrice = this.getBasePriceForPair(pair)
    let currentPrice = basePrice
    
    const totalMinutes = (endDate.getTime() - startDate.getTime()) / (1000 * 60)
    const interval = 5 // 5 minutos entre puntos de datos
    
    for (let i = 0; i < totalMinutes; i += interval) {
      const timestamp = new Date(startDate.getTime() + i * 60 * 1000)
      
      // Simular movimiento de precio con volatilidad
      const volatility = 0.02 // 2% volatilidad
      const randomChange = (Math.random() - 0.5) * volatility
      currentPrice *= (1 + randomChange)
      
      // Simular datos de ambos exchanges con spread
      const spread = (Math.random() * 0.01) + 0.001 // 0.1% - 1.1% spread
      const binancePrice = currentPrice * (1 - spread / 2)
      const kucoinPrice = currentPrice * (1 + spread / 2)
      
      data.push({
        timestamp: timestamp.toISOString(),
        pair,
        binance: {
          price: binancePrice,
          volume: Math.random() * 1000000,
        },
        kucoin: {
          price: kucoinPrice,
          volume: Math.random() * 800000,
        },
        spread: ((kucoinPrice - binancePrice) / binancePrice) * 100,
        volatility: this.calculateVolatility(data.slice(-20).map(d => d.binance.price)),
      })
    }
    
    return data
  }

  getBasePriceForPair(pair) {
    const basePrices = {
      'POL/USDT': 0.45,
      'USDC/USDT': 1.0,
      'BTC/USDT': 45000,
      'ETH/USDT': 3000,
    }
    return basePrices[pair] || 1.0
  }

  calculateVolatility(prices) {
    if (prices.length < 2) return 0
    
    const returns = []
    for (let i = 1; i < prices.length; i++) {
      returns.push((prices[i] - prices[i-1]) / prices[i-1])
    }
    
    const avgReturn = returns.reduce((a, b) => a + b) / returns.length
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
    
    return Math.sqrt(variance)
  }

  async runBacktest(options = {}) {
    const {
      pairs = config.TRADING_PAIRS.map(p => p.symbol),
      startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 d√≠as atr√°s
      endDate = new Date(),
      initialBalance = config.BACKTESTING.INITIAL_BALANCE_SIM,
      strategy = 'BALANCED',
      maxTrades = 100,
    } = options

    if (this.isRunning) {
      throw new Error('Ya hay un backtest en ejecuci√≥n')
    }

    this.isRunning = true
    console.log(`üîÑ Iniciando backtest: ${startDate.toDateString()} - ${endDate.toDateString()}`)

    try {
      const results = {
        id: Date.now(),
        startDate,
        endDate,
        strategy,
        initialBalance,
        pairs,
        trades: [],
        performance: {},
        summary: {},
        timestamp: new Date(),
      }

      // Cargar datos hist√≥ricos para todos los pares
      for (const pair of pairs) {
        await this.loadHistoricalData(pair, startDate, endDate)
      }

      // Simular trading
      const simulation = await this.simulateTrading(results, maxTrades)
      results.trades = simulation.trades
      results.performance = simulation.performance
      results.summary = this.calculateSummary(simulation)

      this.backtestResults.push(results)
      
      console.log(`‚úÖ Backtest completado: ${results.trades.length} trades simulados`)
      console.log(`üìä Rendimiento: ${results.summary.totalReturn.toFixed(2)}%`)

      // Guardar resultados
      await this.saveBacktestResults(results)

      return results
    } catch (error) {
      console.error('‚ùå Error en backtest:', error)
      throw error
    } finally {
      this.isRunning = false
    }
  }

  async simulateTrading(backtestConfig, maxTrades) {
    const trades = []
    let currentBalance = backtestConfig.initialBalance
    let totalFees = 0
    const balanceHistory = []

    // Obtener todos los puntos de datos ordenados por tiempo
    const allDataPoints = []
    for (const pair of backtestConfig.pairs) {
      const pairData = this.historicalData.get(pair) || []
      pairData.forEach(point => {
        allDataPoints.push({ ...point, pair })
      })
    }

    allDataPoints.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))

    console.log(`üìà Simulando trading con ${allDataPoints.length} puntos de datos...`)

    for (let i = 0; i < allDataPoints.length && trades.length < maxTrades; i++) {
      const dataPoint = allDataPoints[i]
      
      // Simular detecci√≥n de oportunidad
      const opportunity = this.simulateOpportunityDetection(dataPoint)
      
      if (opportunity && opportunity.profitable) {
        // Evaluar con la estrategia seleccionada
        const evaluatedOpp = this.strategyManager.strategies.get(backtestConfig.strategy)?.evaluate(opportunity)
        
        if (evaluatedOpp && currentBalance >= evaluatedOpp.tradeAmount) {
          // Simular ejecuci√≥n del trade
          const tradeResult = this.simulateTradeExecution(evaluatedOpp, dataPoint)
          
          if (tradeResult.success) {
            const fees = evaluatedOpp.tradeAmount * (config.BACKTESTING.FEE_PERCENTAGE_SIM / 100)
            const netProfit = tradeResult.profit - fees
            
            currentBalance += netProfit
            totalFees += fees
            
            trades.push({
              timestamp: dataPoint.timestamp,
              pair: dataPoint.pair,
              type: 'ARBITRAGE',
              amount: evaluatedOpp.tradeAmount,
              profit: netProfit,
              fees,
              balance: currentBalance,
              strategy: backtestConfig.strategy,
              confidence: evaluatedOpp.confidence,
            })
          }
        }
      }

      // Registrar balance cada 100 puntos
      if (i % 100 === 0) {
        balanceHistory.push({
          timestamp: dataPoint.timestamp,
          balance: currentBalance,
        })
      }
    }

    return {
      trades,
      performance: {
        initialBalance: backtestConfig.initialBalance,
        finalBalance: currentBalance,
        totalFees,
        balanceHistory,
      }
    }
  }

  simulateOpportunityDetection(dataPoint) {
    const binancePrice = dataPoint.binance.price
    const kucoinPrice = dataPoint.kucoin.price
    
    if (!binancePrice || !kucoinPrice) return null

    // Calcular oportunidad de arbitraje
    const spread = Math.abs(kucoinPrice - binancePrice)
    const spreadPercent = (spread / Math.min(binancePrice, kucoinPrice)) * 100
    
    // Determinar direcci√≥n del arbitraje
    const buyExchange = binancePrice < kucoinPrice ? 'BINANCE' : 'KUCOIN'
    const sellExchange = binancePrice < kucoinPrice ? 'KUCOIN' : 'BINANCE'
    const buyPrice = Math.min(binancePrice, kucoinPrice)
    const sellPrice = Math.max(binancePrice, kucoinPrice)
    
    // Simular fees y costos
    const tradingFees = 0.2 // 0.2% total en fees
    const netProfit = spreadPercent - tradingFees
    
    return {
      pair: dataPoint.pair,
      buyExchange,
      sellExchange,
      buyPrice,
      sellPrice,
      spread: spreadPercent,
      finalProfit: netProfit,
      profitable: netProfit > 0.1, // M√≠nimo 0.1% profit
      confidence: Math.min(0.9, Math.max(0.1, netProfit / 2)), // Confianza basada en profit
      tradeAmount: 50, // Monto fijo para simulaci√≥n
      timestamp: new Date(dataPoint.timestamp).getTime(),
    }
  }

  simulateTradeExecution(opportunity, dataPoint) {
    // Simular √©xito/fallo basado en condiciones de mercado
    const volatility = dataPoint.volatility || 0
    const volume = Math.min(dataPoint.binance.volume, dataPoint.kucoin.volume)
    
    // Factores que afectan el √©xito
    let successProbability = 0.8 // Base 80%
    
    // Reducir probabilidad con alta volatilidad
    if (volatility > 0.05) successProbability -= 0.2
    
    // Reducir probabilidad con bajo volumen
    if (volume < 100000) successProbability -= 0.1
    
    // Aumentar probabilidad con alto profit
    if (opportunity.finalProfit > 1.0) successProbability += 0.1
    
    const success = Math.random() < successProbability
    
    if (success) {
      // Simular slippage
      const slippage = Math.random() * 0.1 // Hasta 0.1% slippage
      const actualProfit = (opportunity.finalProfit - slippage) * opportunity.tradeAmount / 100
      
      return {
        success: true,
        profit: Math.max(0, actualProfit),
        executionTime: Math.random() * 30000 + 5000, // 5-35 segundos
      }
    } else {
      return {
        success: false,
        profit: 0,
        reason: 'Fallo en ejecuci√≥n simulada',
      }
    }
  }

  calculateSummary(simulation) {
    const { trades, performance } = simulation
    const { initialBalance, finalBalance, totalFees } = performance
    
    const successfulTrades = trades.filter(t => t.profit > 0)
    const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0)
    const totalReturn = ((finalBalance - initialBalance) / initialBalance) * 100
    
    const profitableTrades = trades.filter(t => t.profit > 0)
    const losingTrades = trades.filter(t => t.profit <= 0)
    
    const avgProfit = profitableTrades.length > 0 
      ? profitableTrades.reduce((sum, t) => sum + t.profit, 0) / profitableTrades.length 
      : 0
    
    const avgLoss = losingTrades.length > 0 
      ? Math.abs(losingTrades.reduce((sum, t) => sum + t.profit, 0)) / losingTrades.length 
      : 0

    const maxDrawdown = this.calculateMaxDrawdown(performance.balanceHistory)
    const sharpeRatio = this.calculateSharpeRatio(trades)
    
    return {
      totalTrades: trades.length,
      successfulTrades: successfulTrades.length,
      successRate: trades.length > 0 ? (successfulTrades.length / trades.length) * 100 : 0,
      totalProfit,
      totalReturn,
      totalFees,
      avgProfit,
      avgLoss,
      profitFactor: avgLoss > 0 ? avgProfit / avgLoss : 0,
      maxDrawdown,
      sharpeRatio,
      finalBalance,
      roi: totalReturn,
    }
  }

  calculateMaxDrawdown(balanceHistory) {
    if (balanceHistory.length < 2) return 0
    
    let maxDrawdown = 0
    let peak = balanceHistory[0].balance
    
    for (const point of balanceHistory) {
      if (point.balance > peak) {
        peak = point.balance
      } else {
        const drawdown = ((peak - point.balance) / peak) * 100
        maxDrawdown = Math.max(maxDrawdown, drawdown)
      }
    }
    
    return maxDrawdown
  }

  calculateSharpeRatio(trades) {
    if (trades.length < 2) return 0
    
    const returns = trades.map(t => (t.profit / t.amount) * 100)
    const avgReturn = returns.reduce((a, b) => a + b) / returns.length
    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length
    const stdDev = Math.sqrt(variance)
    
    return stdDev > 0 ? avgReturn / stdDev : 0
  }

  async saveHistoricalData(pair, data) {
    try {
      const dataPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, `${pair.replace('/', '_')}.json`)
      
      // Crear directorio si no existe
      await fs.mkdir(path.dirname(dataPath), { recursive: true })
      
      await fs.writeFile(dataPath, JSON.stringify(data, null, 2))
      console.log(`üíæ Datos hist√≥ricos guardados para ${pair}`)
    } catch (error) {
      console.error(`‚ùå Error guardando datos hist√≥ricos para ${pair}:`, error)
    }
  }

  async saveBacktestResults(results) {
    try {
      const resultsPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, 'backtest_results.json')
      
      // Cargar resultados existentes
      let existingResults = []
      try {
        const data = await fs.readFile(resultsPath, 'utf8')
        existingResults = JSON.parse(data)
      } catch (error) {
        // Archivo no existe, usar array vac√≠o
      }
      
      existingResults.push(results)
      
      // Mantener solo los √∫ltimos 50 resultados
      if (existingResults.length > 50) {
        existingResults = existingResults.slice(-50)
      }
      
      await fs.writeFile(resultsPath, JSON.stringify(existingResults, null, 2))
      console.log('üíæ Resultados de backtest guardados')
    } catch (error) {
      console.error('‚ùå Error guardando resultados de backtest:', error)
    }
  }

  async getBacktestHistory() {
    try {
      const resultsPath = path.join(config.BACKTESTING.HISTORICAL_DATA_PATH, 'backtest_results.json')
      const data = await fs.readFile(resultsPath, 'utf8')
      return JSON.parse(data)
    } catch (error) {
      return []
    }
  }

  compareStrategies(backtestResults) {
    const strategyPerformance = new Map()
    
    for (const result of backtestResults) {
      const strategy = result.strategy
      if (!strategyPerformance.has(strategy)) {
        strategyPerformance.set(strategy, {
          backtests: 0,
          avgReturn: 0,
          avgSharpe: 0,
          avgSuccessRate: 0,
          totalReturn: 0,
        })
      }
      
      const perf = strategyPerformance.get(strategy)
      perf.backtests++
      perf.totalReturn += result.summary.totalReturn
      perf.avgReturn = perf.totalReturn / perf.backtests
      perf.avgSharpe = (perf.avgSharpe * (perf.backtests - 1) + result.summary.sharpeRatio) / perf.backtests
      perf.avgSuccessRate = (perf.avgSuccessRate * (perf.backtests - 1) + result.summary.successRate) / perf.backtests
    }
    
    return Object.fromEntries(strategyPerformance)
  }
}

module.exports = { BacktestEngine }

-------------------------------------------------------------------------------------------------------------

const fs = require('fs').promises;
const path = require('path');
const EventEmitter = require('events');

/**
 * Motor de Backtesting
 * Permite probar estrategias con datos hist√≥ricos
 */
class BacktestEngine extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.enabled = config.BACKTESTING.ENABLED;
        this.dataSource = config.BACKTESTING.DATA_SOURCE;
        this.defaultPeriod = config.BACKTESTING.DEFAULT_PERIOD;
        this.commissionRate = config.BACKTESTING.COMMISSION_RATE;
        this.slippageRate = config.BACKTESTING.SLIPPAGE_RATE;
        this.initialCapital = config.BACKTESTING.INITIAL_CAPITAL;
        this.benchmark = config.BACKTESTING.BENCHMARK;
        this.metrics = config.BACKTESTING.METRICS;
        this.monteCarloSimulations = config.BACKTESTING.MONTE_CARLO_SIMULATIONS;
        this.confidenceIntervals = config.BACKTESTING.CONFIDENCE_INTERVALS;
        
        this.historicalData = {};
        this.backtestResults = {};
        this.currentBacktest = null;
        
        this.logger = console;
    }
    
    /**
     * Inicializa el motor de backtesting
     */
    async initialize() {
        if (!this.enabled) {
            this.logger.info('Backtesting deshabilitado');
            return;
        }
        
        this.logger.info('Inicializando motor de backtesting...');
        
        try {
            // Crear directorio de datos si no existe
            await this.ensureDataDirectory();
            
            // Cargar datos hist√≥ricos iniciales
            await this.loadInitialData();
            
            this.logger.info('Motor de backtesting inicializado correctamente');
        } catch (error) {
            this.logger.error('Error inicializando motor de backtesting:', error);
            throw error;
        }
    }
    
    /**
     * Asegura que el directorio de datos exista
     */
    async ensureDataDirectory() {
        const dataDir = path.join(__dirname, 'data');
        try {
            await fs.mkdir(dataDir, { recursive: true });
        } catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
    }
    
    /**
     * Carga datos hist√≥ricos iniciales
     */
    async loadInitialData() {
        try {
            // En una implementaci√≥n real, aqu√≠ cargar√≠amos datos hist√≥ricos de una API o archivos
            // Para esta implementaci√≥n, generaremos datos simulados
            
            const pairs = this.config.TRADING_PAIRS;
            const exchanges = Object.keys(this.config.EXCHANGES)
                .filter(key => this.config.EXCHANGES[key].enabled)
                .map(key => this.config.EXCHANGES[key].name);
            
            for (const pair of pairs) {
                this.historicalData[pair] = {};
                
                for (const exchange of exchanges) {
                    this.historicalData[pair][exchange] = await this.generateHistoricalData(pair, exchange);
                }
            }
            
            this.logger.info(`Datos hist√≥ricos cargados para ${pairs.length} pares en ${exchanges.length} exchanges`);
        } catch (error) {
            this.logger.error('Error cargando datos hist√≥ricos:', error);
            throw error;
        }
    }
    
    /**
     * Genera datos hist√≥ricos simulados
     * @param {string} pair - Par de trading
     * @param {string} exchange - Exchange
     * @returns {Array} - Datos hist√≥ricos simulados
     */
    async generateHistoricalData(pair, exchange) {
        const days = this.defaultPeriod;
        const dataPoints = days * 24 * 6; // 6 puntos por hora
        const endDate = new Date();
        const data = [];
        
        // Generar precio base seg√∫n el par
        let basePrice;
        if (pair.includes('BTC')) {
            basePrice = 30000 + Math.random() * 10000;
        } else if (pair.includes('ETH')) {
            basePrice = 2000 + Math.random() * 500;
        } else if (pair.includes('XRP')) {
            basePrice = 0.5 + Math.random() * 0.2;
        } else {
            basePrice = 10 + Math.random() * 90;
        }
        
        // A√±adir variaci√≥n por exchange
        if (exchange === 'Binance') {
            basePrice *= 1.0;
        } else if (exchange === 'Coinbase') {
            basePrice *= 1.005;
        } else if (exchange === 'Kraken') {
            basePrice *= 0.995;
        } else {
            basePrice *= 1.002;
        }
        
        // Generar serie temporal
        let currentPrice = basePrice;
        for (let i = 0; i < dataPoints; i++) {
            const timestamp = new Date(endDate.getTime() - (dataPoints - i) * 10 * 60 * 1000); // 10 minutos
            
            // Simular movimiento de precio
            const change = (Math.random() - 0.5) * 0.01; // ¬±0.5%
            currentPrice = currentPrice * (1 + change);
            
            // A√±adir algo de volatilidad seg√∫n el par
            if (pair.includes('BTC')) {
                currentPrice += (Math.random() - 0.5) * 50;
            } else if (pair.includes('ETH')) {
                currentPrice += (Math.random() - 0.5) * 10;
            } else {
                currentPrice += (Math.random() - 0.5) * 0.05;
            }
            
            // Asegurar que el precio no sea negativo
            currentPrice = Math.max(currentPrice, 0.001);
            
            // Generar volumen simulado
            let volume;
            if (pair.includes('BTC')) {
                volume = Math.random() * 10 + 1;
            } else if (pair.includes('ETH')) {
                volume = Math.random() * 50 + 5;
            } else {
                volume = Math.random() * 100000 + 10000;
            }
            
            // A√±adir datos
            data.push({
                timestamp: timestamp.toISOString(),
                open: currentPrice * (1 - 0.001),
                high: currentPrice * (1 + 0.002),
                low: currentPrice * (1 - 0.002),
                close: currentPrice,
                volume: volume,
                exchange
            });
        }
        
        return data;
    }
    
    /**
     * Ejecuta un backtest con una estrategia espec√≠fica
     * @param {Object} options - Opciones del backtest
     * @returns {Object} - Resultados del backtest
     */
    async runBacktest(options) {
        if (!this.enabled) {
            throw new Error('Backtesting est√° deshabilitado');
        }
        
        const {
            strategy = 'basic',
            pairs = this.config.TRADING_PAIRS,
            exchanges = Object.keys(this.config.EXCHANGES)
                .filter(key => this.config.EXCHANGES[key].enabled)
                .map(key => this.config.EXCHANGES[key].name),
            startDate = new Date(Date.now() - this.defaultPeriod * 24 * 60 * 60 * 1000),
            endDate = new Date(),
            initialCapital = this.initialCapital,
            parameters = {}
        } = options;
        
        this.logger.info(`Iniciando backtest para estrategia ${strategy}...`);
        
        try {
            // Crear ID √∫nico para este backtest
            const backtestId = `backtest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Inicializar estado del backtest
            this.currentBacktest = {
                id: backtestId,
                strategy,
                pairs,
                exchanges,
                startDate,
                endDate,
                initialCapital,
                parameters,
                status: 'running',
                progress: 0,
                trades: [],
                balance: initialCapital,
                equity: initialCapital,
                startTime: new Date()
            };
            
            // Emitir evento de inicio
            this.emit('backtestStarted', { id: backtestId });
            
            // Filtrar datos hist√≥ricos seg√∫n fechas y pares/exchanges
            const filteredData = await this.filterHistoricalData(pairs, exchanges, startDate, endDate);
            
            // Ejecutar simulaci√≥n
            const result = await this.simulateStrategy(strategy, filteredData, initialCapital, parameters);
            
            // Calcular m√©tricas
            const metrics = this.calculateMetrics(result);
            
            // Ejecutar simulaciones de Monte Carlo
            const monteCarloResults = await this.runMonteCarloSimulations(result);
            
            // Guardar resultados
            this.backtestResults[backtestId] = {
                ...this.currentBacktest,
                status: 'completed',
                progress: 100,
                result,
                metrics,
                monteCarloResults,
                endTime: new Date(),
                executionTime: new Date() - this.currentBacktest.startTime
            };
            
            // Emitir evento de finalizaci√≥n
            this.emit('backtestCompleted', { 
                id: backtestId,
                metrics,
                executionTime: this.backtestResults[backtestId].executionTime
            });
            
            this.currentBacktest = null;
            
            return this.backtestResults[backtestId];
        } catch (error) {
            this.logger.error('Error ejecutando backtest:', error);
            
            if (this.currentBacktest) {
                this.backtestResults[this.currentBacktest.id] = {
                    ...this.currentBacktest,
                    status: 'failed',
                    error: error.message,
                    endTime: new Date(),
                    executionTime: new Date() - this.currentBacktest.startTime
                };
                
                // Emitir evento de error
                this.emit('backtestError', { 
                    id: this.currentBacktest.id,
                    error: error.message
                });
                
                this.currentBacktest = null;
            }
            
            throw error;
        }
    }
    
    /**
     * Filtra datos hist√≥ricos seg√∫n criterios
     * @param {Array} pairs - Pares de trading
     * @param {Array} exchanges - Exchanges
     * @param {Date} startDate - Fecha de inicio
     * @param {Date} endDate - Fecha de fin
     * @returns {Object} - Datos hist√≥ricos filtrados
     */
    async filterHistoricalData(pairs, exchanges, startDate, endDate) {
        const filteredData = {};
        
        for (const pair of pairs) {
            if (!this.historicalData[pair]) continue;
            
            filteredData[pair] = {};
            
            for (const exchange of exchanges) {
                if (!this.historicalData[pair][exchange]) continue;
                
                // Filtrar por fecha
                filteredData[pair][exchange] = this.historicalData[pair][exchange].filter(data => {
                    const timestamp = new Date(data.timestamp);
                    return timestamp >= startDate && timestamp <= endDate;
                });
            }
        }
        
        return filteredData;
    }
    
    /**
     * Simula una estrategia con datos hist√≥ricos
     * @param {string} strategyName - Nombre de la estrategia
     * @param {Object} data - Datos hist√≥ricos
     * @param {number} initialCapital - Capital inicial
     * @param {Object} parameters - Par√°metros de la estrategia
     * @returns {Object} - Resultados de la simulaci√≥n
     */
    async simulateStrategy(strategyName, data, initialCapital, parameters) {
        // Obtener configuraci√≥n de la estrategia
        const strategyConfig = this.config.STRATEGIES[strategyName.toUpperCase()] || this.config.STRATEGIES.BASIC;
        
        // Inicializar resultado
        const result = {
            trades: [],
            balanceHistory: [],
            equityHistory: [],
            positions: {},
            currentBalance: initialCapital,
            maxBalance: initialCapital,
            minBalance: initialCapital,
            finalBalance: initialCapital,
            totalTrades: 0,
            successfulTrades: 0,
            failedTrades: 0,
            totalProfit: 0,
            totalLoss: 0,
            netProfit: 0,
            winRate: 0,
            maxDrawdown: 0,
            maxDrawdownPercentage: 0
        };
        
        // Ordenar todos los datos por timestamp
        const allDataPoints = [];
        
        for (const pair in data) {
            for (const exchange in data[pair]) {
                for (const point of data[pair][exchange]) {
                    allDataPoints.push({
                        ...point,
                        pair,
                        exchange
                    });
                }
            }
        }
        
        // Ordenar por timestamp
        allDataPoints.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Inicializar balance hist√≥rico
        result.balanceHistory.push({
            timestamp: allDataPoints[0]?.timestamp || new Date().toISOString(),
            balance: initialCapital
        });
        
        result.equityHistory.push({
            timestamp: allDataPoints[0]?.timestamp || new Date().toISOString(),
            equity: initialCapital
        });
        
        // Simular trading
        let lastProgressUpdate = 0;
        
        for (let i = 0; i < allDataPoints.length; i++) {
            // Actualizar progreso cada 5%
            const progress = Math.floor((i / allDataPoints.length) * 100);
            if (progress >= lastProgressUpdate + 5) {
                lastProgressUpdate = progress;
                if (this.currentBacktest) {
                    this.currentBacktest.progress = progress;
                    this.emit('backtestProgress', { 
                        id: this.currentBacktest.id,
                        progress
                    });
                }
            }
            
            const currentPoint = allDataPoints[i];
            const { pair, exchange, timestamp, close: price } = currentPoint;
            
            // Buscar oportunidades de arbitraje
            const opportunities = await this.findArbitrageOpportunities(allDataPoints, i, strategyName, strategyConfig);
            
            // Ejecutar operaciones para oportunidades encontradas
            for (const opportunity of opportunities) {
                const trade = await this.executeTrade(opportunity, result.currentBalance, timestamp);
                
                if (trade) {
                    // Actualizar balance
                    result.currentBalance += trade.profit;
                    
                    // Actualizar estad√≠sticas
                    result.totalTrades++;
                    if (trade.profit > 0) {
                        result.successfulTrades++;
                        result.totalProfit += trade.profit;
                    } else {
                        result.failedTrades++;
                        result.totalLoss += trade.profit; // Ser√° negativo
                    }
                    
                    // Actualizar m√°ximo y m√≠nimo balance
                    result.maxBalance = Math.max(result.maxBalance, result.currentBalance);
                    result.minBalance = Math.min(result.minBalance, result.currentBalance);
                    
                    // Registrar operaci√≥n
                    result.trades.push(trade);
                }
            }
            
            // Actualizar historial de balance cada hora simulada
            if (i % 6 === 0) { // Asumiendo 6 puntos por hora
                result.balanceHistory.push({
                    timestamp,
                    balance: result.currentBalance
                });
                
                // Calcular equity (balance + valor de posiciones abiertas)
                let equity = result.currentBalance;
                
                // A√±adir valor de posiciones abiertas (si las hubiera)
                for (const positionPair in result.positions) {
                    for (const positionExchange in result.positions[positionPair]) {
                        const position = result.positions[positionPair][positionExchange];
                        // En este ejemplo simplificado no manejamos posiciones abiertas
                    }
                }
                
                result.equityHistory.push({
                    timestamp,
                    equity
                });
            }
        }
        
        // Finalizar resultado
        result.finalBalance = result.currentBalance;
        result.netProfit = result.totalProfit + result.totalLoss;
        result.winRate = result.totalTrades > 0 ? result.successfulTrades / result.totalTrades : 0;
        
        // Calcular drawdown
        let peak = initialCapital;
        let maxDrawdown = 0;
        let maxDrawdownPercentage = 0;
        
        for (const point of result.balanceHistory) {
            if (point.balance > peak) {
                peak = point.balance;
            } else {
                const drawdown = peak - point.balance;
                const drawdownPercentage = drawdown / peak;
                
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                    maxDrawdownPercentage = drawdownPercentage;
                }
            }
        }
        
        result.maxDrawdown = maxDrawdown;
        result.maxDrawdownPercentage = maxDrawdownPercentage;
        
        return result;
    }
    
    /**
     * Busca oportunidades de arbitraje en datos hist√≥ricos
     * @param {Array} dataPoints - Puntos de datos hist√≥ricos
     * @param {number} currentIndex - √çndice actual
     * @param {string} strategyName - Nombre de la estrategia
     * @param {Object} strategyConfig - Configuraci√≥n de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findArbitrageOpportunities(dataPoints, currentIndex, strategyName, strategyConfig) {
        const opportunities = [];
        const currentPoint = dataPoints[currentIndex];
        const { timestamp } = currentPoint;
        
        // Obtener precios actuales para todos los pares y exchanges
        const currentPrices = {};
        
        // Buscar en un rango cercano al punto actual (simulando datos simult√°neos)
        const rangeStart = Math.max(0, currentIndex - 10);
        const rangeEnd = Math.min(dataPoints.length - 1, currentIndex + 10);
        
        for (let i = rangeStart; i <= rangeEnd; i++) {
            const point = dataPoints[i];
            const { pair, exchange, close: price } = point;
            
            if (!currentPrices[pair]) {
                currentPrices[pair] = {};
            }
            
            currentPrices[pair][exchange] = price;
        }
        
        // Buscar oportunidades seg√∫n la estrategia
        switch (strategyName.toLowerCase()) {
            case 'basic':
                return this.findBasicArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                
            case 'triangular':
                return this.findTriangularArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                
            case 'statistical':
                return this.findStatisticalArbitrageOpportunities(currentPrices, dataPoints, currentIndex, strategyConfig);
                
            case 'ml':
                return this.findMLArbitrageOpportunities(currentPrices, dataPoints, currentIndex, strategyConfig);
                
            case 'combined':
                // Combinar resultados de varias estrategias
                const basicOpps = await this.findBasicArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                const triangularOpps = await this.findTriangularArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
                const statisticalOpps = await this.findStatisticalArbitrageOpportunities(currentPrices, dataPoints, currentIndex, strategyConfig);
                
                return [...basicOpps, ...triangularOpps, ...statisticalOpps];
                
            default:
                return this.findBasicArbitrageOpportunities(currentPrices, timestamp, strategyConfig);
        }
    }
    
    /**
     * Busca oportunidades de arbitraje b√°sico
     * @param {Object} prices - Precios actuales
     * @param {string} timestamp - Timestamp actual
     * @param {Object} config - Configuraci√≥n de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findBasicArbitrageOpportunities(prices, timestamp, config) {
        const opportunities = [];
        const minProfitPercentage = config.minProfitPercentage || 0.2;
        
        for (const pair in prices) {
            const exchanges = Object.keys(prices[pair]);
            
            // Necesitamos al menos 2 exchanges para arbitraje
            if (exchanges.length < 2) continue;
            
            // Encontrar el exchange con el precio m√°s bajo y m√°s alto
            let lowestPrice = Infinity;
            let highestPrice = -Infinity;
            let buyExchange = null;
            let sellExchange = null;
            
            for (const exchange of exchanges) {
                const price = prices[pair][exchange];
                
                if (price < lowestPrice) {
                    lowestPrice = price;
                    buyExchange = exchange;
                }
                
                if (price > highestPrice) {
                    highestPrice = price;
                    sellExchange = exchange;
                }
            }
            
            // Calcular ganancia potencial
            const profitPercentage = ((highestPrice - lowestPrice) / lowestPrice) * 100;
            
            // Verificar si la ganancia supera el m√≠nimo requerido
            if (profitPercentage >= minProfitPercentage && buyExchange !== sellExchange) {
                opportunities.push({
                    type: 'basic',
                    pair,
                    buyExchange,
                    sellExchange,
                    buyPrice: lowestPrice,
                    sellPrice: highestPrice,
                    profitPercentage,
                    timestamp
                });
            }
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje triangular
     * @param {Object} prices - Precios actuales
     * @param {string} timestamp - Timestamp actual
     * @param {Object} config - Configuraci√≥n de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findTriangularArbitrageOpportunities(prices, timestamp, config) {
        // En una implementaci√≥n real, aqu√≠ buscar√≠amos oportunidades de arbitraje triangular
        // Para esta implementaci√≥n, simularemos algunas oportunidades
        
        const opportunities = [];
        const minProfitPercentage = config.minProfitPercentage || 0.15;
        
        // Simular algunas oportunidades triangulares
        if (Math.random() < 0.05) { // 5% de probabilidad de encontrar una oportunidad
            const profitPercentage = minProfitPercentage + Math.random() * 0.5;
            
            // Elegir pares y exchanges aleatorios
            const availablePairs = Object.keys(prices);
            if (availablePairs.length < 2) return opportunities;
            
            const pair1 = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            let pair2 = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            while (pair2 === pair1) {
                pair2 = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            }
            
            const availableExchanges = Object.keys(prices[pair1]);
            if (availableExchanges.length < 1) return opportunities;
            
            const exchange = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            
            opportunities.push({
                type: 'triangular',
                pairs: [pair1, pair2],
                exchange,
                steps: [
                    { pair: pair1, action: 'buy', price: prices[pair1][exchange] || 1000 },
                    { pair: pair2, action: 'sell', price: prices[pair2][exchange] || 1000 }
                ],
                profitPercentage,
                timestamp
            });
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje estad√≠stico
     * @param {Object} prices - Precios actuales
     * @param {Array} dataPoints - Puntos de datos hist√≥ricos
     * @param {number} currentIndex - √çndice actual
     * @param {Object} config - Configuraci√≥n de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findStatisticalArbitrageOpportunities(prices, dataPoints, currentIndex, config) {
        // En una implementaci√≥n real, aqu√≠ buscar√≠amos oportunidades de arbitraje estad√≠stico
        // Para esta implementaci√≥n, simularemos algunas oportunidades
        
        const opportunities = [];
        const minProfitPercentage = config.minProfitPercentage || 0.1;
        const lookbackPeriod = config.lookbackPeriod || 100;
        const zScoreThreshold = config.zScoreThreshold || 2.0;
        
        // Simular algunas oportunidades estad√≠sticas
        if (Math.random() < 0.03) { // 3% de probabilidad de encontrar una oportunidad
            const profitPercentage = minProfitPercentage + Math.random() * 0.3;
            
            // Elegir par y exchanges aleatorios
            const availablePairs = Object.keys(prices);
            if (availablePairs.length < 1) return opportunities;
            
            const pair = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            
            const availableExchanges = Object.keys(prices[pair]);
            if (availableExchanges.length < 2) return opportunities;
            
            const exchange1 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            let exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            while (exchange2 === exchange1) {
                exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            }
            
            opportunities.push({
                type: 'statistical',
                pair,
                buyExchange: exchange1,
                sellExchange: exchange2,
                buyPrice: prices[pair][exchange1] || 1000,
                sellPrice: prices[pair][exchange2] || 1000,
                zScore: zScoreThreshold + Math.random(),
                profitPercentage,
                timestamp: dataPoints[currentIndex].timestamp
            });
        }
        
        return opportunities;
    }
    
    /**
     * Busca oportunidades de arbitraje con ML
     * @param {Object} prices - Precios actuales
     * @param {Array} dataPoints - Puntos de datos hist√≥ricos
     * @param {number} currentIndex - √çndice actual
     * @param {Object} config - Configuraci√≥n de la estrategia
     * @returns {Array} - Oportunidades encontradas
     */
    async findMLArbitrageOpportunities(prices, dataPoints, currentIndex, config) {
        // En una implementaci√≥n real, aqu√≠ usar√≠amos un modelo de ML para encontrar oportunidades
        // Para esta implementaci√≥n, simularemos algunas oportunidades
        
        const opportunities = [];
        const confidenceThreshold = config.confidenceThreshold || 0.7;
        
        // Simular algunas oportunidades basadas en ML
        if (Math.random() < 0.02) { // 2% de probabilidad de encontrar una oportunidad
            const confidence = confidenceThreshold + Math.random() * (1 - confidenceThreshold);
            const profitPercentage = 0.1 + Math.random() * 0.4;
            
            // Elegir par y exchanges aleatorios
            const availablePairs = Object.keys(prices);
            if (availablePairs.length < 1) return opportunities;
            
            const pair = availablePairs[Math.floor(Math.random() * availablePairs.length)];
            
            const availableExchanges = Object.keys(prices[pair]);
            if (availableExchanges.length < 2) return opportunities;
            
            const exchange1 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            let exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            while (exchange2 === exchange1) {
                exchange2 = availableExchanges[Math.floor(Math.random() * availableExchanges.length)];
            }
            
            opportunities.push({
                type: 'ml',
                pair,
                buyExchange: exchange1,
                sellExchange: exchange2,
                buyPrice: prices[pair][exchange1] || 1000,
                sellPrice: prices[pair][exchange2] || 1000,
                confidence,
                profitPercentage,
                timestamp: dataPoints[currentIndex].timestamp
            });
        }
        
        return opportunities;
    }
    
    /**
     * Ejecuta una operaci√≥n simulada
     * @param {Object} opportunity - Oportunidad de arbitraje
     * @param {number} balance - Balance actual
     * @param {string} timestamp - Timestamp actual
     * @returns {Object|null} - Detalles de la operaci√≥n o null si no se ejecut√≥
     */
    async executeTrade(opportunity, balance, timestamp) {
        // Determinar cantidad a invertir (10% del balance)
        const investmentAmount = balance * 0.1;
        
        // Verificar si hay suficiente balance
        if (investmentAmount < 10) { // M√≠nimo $10
            return null;
        }
        
        // Calcular comisiones
        const buyCommission = investmentAmount * this.commissionRate;
        const sellCommission = (investmentAmount * (1 + opportunity.profitPercentage / 100)) * this.commissionRate;
        
        // Calcular slippage
        const buySlippage = investmentAmount * this.slippageRate;
        const sellSlippage = (investmentAmount * (1 + opportunity.profitPercentage / 100)) * this.slippageRate;
        
        // Calcular ganancia neta
        const grossProfit = investmentAmount * (opportunity.profitPercentage / 100);
        const netProfit = grossProfit - buyCommission - sellCommission - buySlippage - sellSlippage;
        
        // Simular √©xito/fallo (95% √©xito)
        const success = Math.random() > 0.05;
        
        // Si falla, perder una parte de la inversi√≥n
        const finalProfit = success ? netProfit : -investmentAmount * 0.02;
        
        return {
            timestamp,
            type: opportunity.type,
            pair: opportunity.pair || (opportunity.pairs ? opportunity.pairs[0] : 'unknown'),
            buyExchange: opportunity.buyExchange || opportunity.exchange || 'unknown',
            sellExchange: opportunity.sellExchange || opportunity.exchange || 'unknown',
            buyPrice: opportunity.buyPrice || 0,
            sellPrice: opportunity.sellPrice || 0,
            investmentAmount,
            grossProfit,
            fees: buyCommission + sellCommission,
            slippage: buySlippage + sellSlippage,
            netProfit,
            profit: finalProfit,
            profitPercentage: (finalProfit / investmentAmount) * 100,
            success
        };
    }
    
    /**
     * Calcula m√©tricas de rendimiento
     * @param {Object} result - Resultados del backtest
     * @returns {Object} - M√©tricas calculadas
     */
    calculateMetrics(result) {
        const metrics = {};
        
        // Total Return
        metrics.totalReturn = ((result.finalBalance - this.initialCapital) / this.initialCapital) * 100;
        
        // Annualized Return (asumiendo 365 d√≠as por a√±o)
        const days = result.balanceHistory.length > 1 ? 
            (new Date(result.balanceHistory[result.balanceHistory.length - 1].timestamp) - 
             new Date(result.balanceHistory[0].timestamp)) / (1000 * 60 * 60 * 24) : 1;
        
        metrics.annualizedReturn = ((1 + metrics.totalReturn / 100) ** (365 / days) - 1) * 100;
        
        // Sharpe Ratio (asumiendo tasa libre de riesgo del 2%)
        const riskFreeRate = 0.02;
        const returns = [];
        
        for (let i = 1; i < result.balanceHistory.length; i++) {
            const prevBalance = result.balanceHistory[i - 1].balance;
            const currentBalance = result.balanceHistory[i].balance;
            returns.push((currentBalance - prevBalance) / prevBalance);
        }
        
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const stdReturn = Math.sqrt(returns.reduce((sum, r) => sum + (r - avgReturn) ** 2, 0) / returns.length);
        
        metrics.sharpeRatio = stdReturn !== 0 ? 
            (avgReturn - riskFreeRate / 365) / stdReturn * Math.sqrt(365) : 0;
        
        // Max Drawdown
       metrics.maxDrawdown = result.maxDrawdown;
        metrics.maxDrawdownPercentage = result.maxDrawdownPercentage * 100;
        
        // Win Rate
        metrics.winRate = result.winRate * 100;
        
        // Profit Factor
        metrics.profitFactor = result.totalLoss !== 0 ? 
            Math.abs(result.totalProfit / result.totalLoss) : 
            (result.totalProfit > 0 ? Infinity : 0);
        
        // Calmar Ratio
        metrics.calmarRatio = metrics.maxDrawdownPercentage !== 0 ? 
            metrics.annualizedReturn / metrics.maxDrawdownPercentage : 0;
        
        // Average Trade
        metrics.averageTrade = result.totalTrades > 0 ? 
            result.netProfit / result.totalTrades : 0;
        
        // Best Trade
        metrics.bestTrade = result.trades.length > 0 ? 
            Math.max(...result.trades.map(t => t.profit)) : 0;
        
        // Worst Trade
        metrics.worstTrade = result.trades.length > 0 ? 
            Math.min(...result.trades.map(t => t.profit)) : 0;
        
        // Average Win
        const winningTrades = result.trades.filter(t => t.profit > 0);
        metrics.averageWin = winningTrades.length > 0 ? 
            winningTrades.reduce((sum, t) => sum + t.profit, 0) / winningTrades.length : 0;
        
        // Average Loss
        const losingTrades = result.trades.filter(t => t.profit < 0);
        metrics.averageLoss = losingTrades.length > 0 ? 
            losingTrades.reduce((sum, t) => sum + t.profit, 0) / losingTrades.length : 0;
        
        // Largest Winning Streak
        let currentWinStreak = 0;
        let maxWinStreak = 0;
        
        for (const trade of result.trades) {
            if (trade.profit > 0) {
                currentWinStreak++;
                maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
            } else {
                currentWinStreak = 0;
            }
        }
        
        metrics.largestWinningStreak = maxWinStreak;
        
        // Largest Losing Streak
        let currentLossStreak = 0;
        let maxLossStreak = 0;
        
        for (const trade of result.trades) {
            if (trade.profit < 0) {
                currentLossStreak++;
                maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
            } else {
                currentLossStreak = 0;
            }
        }
        
        metrics.largestLosingStreak = maxLossStreak;
        
        return metrics;
    }
    
    /**
     * Ejecuta simulaciones de Monte Carlo
     * @param {Object} result - Resultados del backtest
     * @returns {Object} - Resultados de Monte Carlo
     */
    async runMonteCarloSimulations(result) {
        const simulations = [];
        const trades = result.trades;
        
        if (trades.length === 0) {
            return { simulations: [], statistics: {} };
        }
        
        // Extraer retornos de las operaciones
        const returns = trades.map(trade => trade.profit / this.initialCapital);
        
        // Ejecutar simulaciones
        for (let sim = 0; sim < this.monteCarloSimulations; sim++) {
            let balance = this.initialCapital;
            const simulationReturns = [];
            
            // Generar secuencia aleatoria de retornos
            for (let i = 0; i < trades.length; i++) {
                const randomReturn = returns[Math.floor(Math.random() * returns.length)];
                balance += balance * randomReturn;
                simulationReturns.push((balance - this.initialCapital) / this.initialCapital);
            }
            
            simulations.push({
                finalReturn: simulationReturns[simulationReturns.length - 1],
                maxDrawdown: this.calculateSimulationDrawdown(simulationReturns),
                returns: simulationReturns
            });
        }
        
        // Calcular estad√≠sticas
        const finalReturns = simulations.map(sim => sim.finalReturn);
        const maxDrawdowns = simulations.map(sim => sim.maxDrawdown);
        
        finalReturns.sort((a, b) => a - b);
        maxDrawdowns.sort((a, b) => a - b);
        
        const statistics = {};
        
        // Intervalos de confianza para retorno final
        for (const confidence of this.confidenceIntervals) {
            const lowerIndex = Math.floor((1 - confidence) / 2 * finalReturns.length);
            const upperIndex = Math.floor((1 + confidence) / 2 * finalReturns.length);
            
            statistics[`finalReturn_${confidence * 100}%`] = {
                lower: finalReturns[lowerIndex] * 100,
                upper: finalReturns[upperIndex] * 100
            };
        }
        
        // Intervalos de confianza para m√°ximo drawdown
        for (const confidence of this.confidenceIntervals) {
            const lowerIndex = Math.floor((1 - confidence) / 2 * maxDrawdowns.length);
            const upperIndex = Math.floor((1 + confidence) / 2 * maxDrawdowns.length);
            
            statistics[`maxDrawdown_${confidence * 100}%`] = {
                lower: maxDrawdowns[lowerIndex] * 100,
                upper: maxDrawdowns[upperIndex] * 100
            };
        }
        
        // Probabilidad de p√©rdida
        const lossCount = finalReturns.filter(r => r < 0).length;
        statistics.probabilityOfLoss = (lossCount / finalReturns.length) * 100;
        
        return { simulations, statistics };
    }
    
    /**
     * Calcula el drawdown para una simulaci√≥n
     * @param {Array} returns - Retornos de la simulaci√≥n
     * @returns {number} - M√°ximo drawdown
     */
    calculateSimulationDrawdown(returns) {
        let peak = 0;
        let maxDrawdown = 0;
        
        for (const returnValue of returns) {
            if (returnValue > peak) {
                peak = returnValue;
            } else {
                const drawdown = peak - returnValue;
                maxDrawdown = Math.max(maxDrawdown, drawdown);
            }
        }
        
        return maxDrawdown;
    }
    
    /**
     * Obtiene los resultados de un backtest
     * @param {string} backtestId - ID del backtest
     * @returns {Object|null} - Resultados del backtest
     */
    getBacktestResults(backtestId) {
        return this.backtestResults[backtestId] || null;
    }
    
    /**
     * Obtiene la lista de todos los backtests
     * @returns {Array} - Lista de backtests
     */
    getAllBacktests() {
        return Object.values(this.backtestResults);
    }
    
    /**
     * Obtiene el estado del backtest actual
     * @returns {Object|null} - Estado del backtest actual
     */
    getCurrentBacktestStatus() {
        return this.currentBacktest;
    }
    
    /**
     * Cancela el backtest actual
     */
    cancelCurrentBacktest() {
        if (this.currentBacktest) {
            this.backtestResults[this.currentBacktest.id] = {
                ...this.currentBacktest,
                status: 'cancelled',
                endTime: new Date(),
                executionTime: new Date() - this.currentBacktest.startTime
            };
            
            this.emit('backtestCancelled', { id: this.currentBacktest.id });
            this.currentBacktest = null;
        }
    }
}

module.exports = BacktestEngine;

--------------------------------------------------------------------------------------------------------------

// ========== GESTOR DE DATOS HIST√ìRICOS PARA BACKTESTING ==========
const fs = require("fs").promises
const path = require("path")
const config = require("../config") // Ajusta la ruta seg√∫n tu estructura
const { ExchangeManager } = require("../exchanges") // Ajusta la ruta

class HistoricalDataManager {
  constructor(exchangeManager) {
    this.dataDir = config.BACKTESTING.HISTORICAL_DATA_PATH || "./historical_data"
    this.exchangeManager = exchangeManager || new ExchangeManager() // Puede pasarse o crearse uno nuevo
    this.ensureDataDirExists()
  }

  async ensureDataDirExists() {
    try {
      await fs.mkdir(this.dataDir, { recursive: true })
      console.log(`Directorio de datos hist√≥ricos asegurado: ${this.dataDir}`)
    } catch (error) {
      console.error(`Error creando directorio de datos hist√≥ricos ${this.dataDir}:`, error)
    }
  }

  getFilePath(exchange, pair, date) {
    // Formato de fecha YYYY-MM-DD
    const dateString = date.toISOString().split("T")[0]
    const pairFilename = pair.replace("/", "_") // BTC/USDT -> BTC_USDT
    return path.join(this.dataDir, exchange, pairFilename, `${dateString}.json`)
  }

  async saveData(exchange, pair, date, data) {
    const filePath = this.getFilePath(exchange, pair, date)
    try {
      await fs.mkdir(path.dirname(filePath), { recursive: true })
      await fs.writeFile(filePath, JSON.stringify(data, null, 2))
      console.log(`Datos guardados para ${exchange} - ${pair} en ${filePath}`)
    } catch (error) {
      console.error(`Error guardando datos en ${filePath}:`, error)
    }
  }

  async loadData(exchange, pair, date) {
    const filePath = this.getFilePath(exchange, pair, date)
    try {
      const data = await fs.readFile(filePath, "utf-8")
      return JSON.parse(data)
    } catch (error) {
      if (error.code === "ENOENT") {
        // console.log(`No se encontraron datos para ${exchange} - ${pair} en ${filePath}`);
        return null
      }
      console.error(`Error cargando datos desde ${filePath}:`, error)
      return null
    }
  }

  // Ejemplo: Obtener datos de Klines (velas)
  // Binance API: /api/v3/klines
  // KuCoin API: /api/v1/market/candles
  async fetchAndStoreCandlestickData(exchange, pair, interval = "1m", startTime, endTime) {
    // Esta funci√≥n necesitar√≠a implementaciones espec√≠ficas por exchange
    // y manejar paginaci√≥n si es necesario.
    console.log(
      `Simulando obtenci√≥n de datos de velas para ${exchange} - ${pair} de ${new Date(startTime)} a ${new Date(endTime)}`,
    )

    // Ejemplo simplificado: generar datos aleatorios para un d√≠a
    const date = new Date(startTime)
    const existingData = await this.loadData(exchange, pair, date)
    if (existingData) {
      console.log(`Datos para ${exchange} - ${pair} en ${date.toISOString().split("T")[0]} ya existen.`)
      return existingData
    }

    const mockCandles = []
    let currentTime = startTime
    while (currentTime < endTime) {
      const open = Math.random() * 100 + 1000 // Precio de apertura aleatorio
      const close = open + (Math.random() - 0.5) * 10
      const high = Math.max(open, close) + Math.random() * 5
      const low = Math.min(open, close) - Math.random() * 5
      const volume = Math.random() * 1000

      mockCandles.push([
        currentTime, // Open time
        open.toFixed(4), // Open
        high.toFixed(4), // High
        low.toFixed(4), // Low
        close.toFixed(4), // Close
        volume.toFixed(4), // Volume
        currentTime + (60000 - 1), // Close time (para intervalo de 1m)
        (volume * ((open + close) / 2)).toFixed(4), // Quote asset volume
        Math.floor(Math.random() * 100), // Number of trades
        (volume / 2).toFixed(4), // Taker buy base asset volume
        ((volume * ((open + close) / 2)) / 2).toFixed(4), // Taker buy quote asset volume
        "0", // Ignore
      ])
      currentTime += 60000 // Avanzar 1 minuto
    }

    await this.saveData(exchange, pair, date, mockCandles)
    return mockCandles
  }

  async getHistoricalRange(exchange, pair, startDate, endDate, interval = "1m") {
    let allData = []
    const currentDate = new Date(startDate)
    const finalDate = new Date(endDate)

    while (currentDate <= finalDate) {
      let dailyData = await this.loadData(exchange, pair, currentDate)
      if (!dailyData) {
        // Si no hay datos locales, intentar obtenerlos (si se implementa la l√≥gica de fetch real)
        // Por ahora, para el ejemplo, podr√≠amos simular o simplemente saltar.
        console.log(
          `No hay datos locales para ${exchange} - ${pair} en ${currentDate.toISOString().split("T")[0]}, intentando obtener...`,
        )
        dailyData = await this.fetchAndStoreCandlestickData(
          exchange,
          pair,
          interval,
          currentDate.getTime(),
          currentDate.getTime() + (24 * 60 * 60 * 1000 - 1),
        )
      }
      if (dailyData) {
        allData = allData.concat(dailyData)
      }
      currentDate.setDate(currentDate.getDate() + 1) // Siguiente d√≠a
    }
    return allData
  }
}

module.exports = { HistoricalDataManager }


-------------------------------------------------------------------------------------------------------------------

CONPONENTS

import React from "react";

export default function AlertBanner({ show, message }) {
  if (!show) return null;
  return (
    <span style={{ color: "#b22222", marginLeft: 8, fontWeight: "bold" }}>
      ‚ö†Ô∏è {message}
    </span>
  );
}

-----------------------------------------------------------------------------------------------------------------

import React, { useState } from "react";
import "./../index.css"; // Aseg√∫rate de importar los estilos

const BotControls = () => {
  const [mode, setMode] = useState("simulacion"); // "simulacion" o "produccion"
  const [botRunning, setBotRunning] = useState(false);

  return (
    <div style={{ display: "flex", gap: "12px" }}>
      <button
        className={`btn btn-primary ${mode === "simulacion" ? "btn-active" : ""}`}
        onClick={() => setMode("simulacion")}
      >
        Cambiar a Simulaci√≥n
      </button>
      <button
        className={`btn btn-primary ${mode === "produccion" ? "btn-active" : ""}`}
        onClick={() => setMode("produccion")}
      >
        Cambiar a Producci√≥n
      </button>
      <button
        className={`btn ${botRunning ? "btn-active btn-success" : "btn-success"}`}
        onClick={() => setBotRunning((prev) => !prev)}
      >
        {botRunning ? "Bot en marcha" : "Iniciar Bot"}
      </button>
    </div>
  );
};

export default BotControls;

-----------------------------------------------------------------------------------------------------------------

import React, { useState } from "react";

export default function EditTokenDialog({ pair, onEdit }) {
  const [open, setOpen] = useState(false);
  const [values, setValues] = useState({ ...pair });

  const handleChange = (field, value) => {
    setValues({ ...values, [field]: value });
  };

  const handleSave = () => {
    onEdit(values);
    setOpen(false);
  };

  return (
    <>
      <button onClick={() => setOpen(true)}>Editar</button>
      {open && (
        <div className="modal">
          <h4>Editar {pair.pair}</h4>
          <label>
            Spread Min:
            <input
              type="number"
              value={values.min_spread}
              min="0"
              step="0.0001"
              onChange={e => handleChange("min_spread", Number(e.target.value))}
            />
          </label>
          <label>
            Slippage M√°x:
            <input
              type="number"
              value={values.max_slippage}
              min="0"
              step="0.0001"
              onChange={e => handleChange("max_slippage", Number(e.target.value))}
            />
          </label>
          <label>
            Fee Trading:
            <input
              type="number"
              value={values.trading_fee}
              min="0"
              step="0.0001"
              onChange={e => handleChange("trading_fee", Number(e.target.value))}
            />
          </label>
          {/* Puedes agregar m√°s campos como min_trade, retiros, etc */}
          <button onClick={handleSave}>Guardar</button>
          <button onClick={() => setOpen(false)}>Cancelar</button>
        </div>
      )}
    </>
  );
}

---------------------------------------------------------------------------------------------------------

import React, { useEffect, useState } from "react";

const API_BASE = "http://localhost:8888/api";

export default function IAPanel() {
  const [config, setConfig] = useState(null);
  const [editConfig, setEditConfig] = useState(null);
  const [saving, setSaving] = useState(false);
  const [saveMsg, setSaveMsg] = useState("");

  // Cargar config inicial
  useEffect(() => {
    fetch(`${API_BASE}/config`)
      .then(res => res.json())
      .then(data => {
        setConfig(data);
        setEditConfig(JSON.parse(JSON.stringify(data))); // Deep clone para edici√≥n
      })
      .catch(() => setEditConfig(null));
  }, []);

  if (!editConfig) return <div className="dashboard-card">Cargando...</div>;

  // Handlers de cambio
  const handleStrategyChange = (strategy, field, value) => {
    setEditConfig(prev => ({
      ...prev,
      STRATEGIES: {
        ...prev.STRATEGIES,
        [strategy]: {
          ...prev.STRATEGIES[strategy],
          [field]: value
        }
      }
    }));
  };

  const handleIATradingChange = (field, value) => {
    setEditConfig(prev => ({
      ...prev,
      AI_TRADING: { ...prev.AI_TRADING, [field]: value }
    }));
  };

  // Guardar cambios al backend
  const handleSave = async () => {
    setSaving(true);
    setSaveMsg("");
    try {
      const res = await fetch(`${API_BASE}/config`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(editConfig),
      });
      if (res.ok) {
        setConfig(JSON.parse(JSON.stringify(editConfig)));
        setSaveMsg("‚úÖ Cambios guardados correctamente.");
      } else {
        setSaveMsg("‚ùå Error al guardar. Revisa la consola del servidor.");
      }
    } catch (e) {
      setSaveMsg("‚ùå Error de red.");
    } finally {
      setSaving(false);
    }
  };

  const strategies = editConfig.STRATEGIES || {};
  const ai = editConfig.AI_TRADING || {};

  return (
    <div className="dashboard-card">
      <div className="card-header">
        <span className="emoji">üß†</span> Panel de IA & Estrategia (Editable)
      </div>
      <form
        onSubmit={e => {
          e.preventDefault();
          handleSave();
        }}
      >
        <div style={{ marginBottom: 15 }}>
          <b>Estrategias configuradas:</b>
          <ul style={{ listStyle: "none", padding: 0 }}>
            {Object.entries(strategies).map(([key, strat]) => (
              <li key={key} style={{ marginBottom: 12, background: "#181c27", borderRadius: 8, padding: 10 }}>
                <b>{strat.name}</b>
                <div>
                  <label>
                    Activada:&nbsp;
                    <input
                      type="checkbox"
                      checked={!!strat.enabled}
                      onChange={e =>
                        handleStrategyChange(key, "enabled", e.target.checked)
                      }
                    />
                  </label>
                </div>
                {strat.minProfitPercentage !== undefined && (
                  <div>
                    <label>
                      Spread m√≠nimo (%):&nbsp;
                      <input
                        type="number"
                        step="0.01"
                        min="0"
                        style={{ width: 80 }}
                        value={strat.minProfitPercentage}
                        onChange={e =>
                          handleStrategyChange(
                            key,
                            "minProfitPercentage",
                            parseFloat(e.target.value)
                          )
                        }
                      />
                    </label>
                  </div>
                )}
                {strat.maxInvestmentPercentage !== undefined && (
                  <div>
                    <label>
                      Inversi√≥n m√°xima (%):&nbsp;
                      <input
                        type="number"
                        step="0.01"
                        min="0"
                        max="1"
                        style={{ width: 80 }}
                        value={strat.maxInvestmentPercentage}
                        onChange={e =>
                          handleStrategyChange(
                            key,
                            "maxInvestmentPercentage",
                            parseFloat(e.target.value)
                          )
                        }
                      />
                    </label>
                  </div>
                )}
                {strat.timeoutMs !== undefined && (
                  <div>
                    <label>
                      Timeout (segundos):&nbsp;
                      <input
                        type="number"
                        step="1"
                        min="0"
                        style={{ width: 80 }}
                        value={strat.timeoutMs / 1000}
                        onChange={e =>
                          handleStrategyChange(
                            key,
                            "timeoutMs",
                            parseInt(e.target.value, 10) * 1000
                          )
                        }
                      />
                    </label>
                  </div>
                )}
              </li>
            ))}
          </ul>
        </div>
        <div style={{ marginBottom: 15 }}>
          <b>IA Trading:</b>
          <div>
            <label>
              Activado:&nbsp;
              <input
                type="checkbox"
                checked={!!ai.ENABLED}
                onChange={e =>
                  handleIATradingChange("ENABLED", e.target.checked)
                }
              />
            </label>
          </div>
          <div>
            <label>
              Prediction Horizon (ms):&nbsp;
              <input
                type="number"
                min="0"
                step="1"
                style={{ width: 100 }}
                value={ai.PREDICTION_HORIZON || 0}
                onChange={e =>
                  handleIATradingChange(
                    "PREDICTION_HORIZON",
                    parseInt(e.target.value, 10)
                  )
                }
              />
            </label>
          </div>
        </div>
        <button
          type="submit"
          className="btn btn-success"
          disabled={saving}
          style={{ fontWeight: "bold", fontSize: 16 }}
        >
          {saving ? "Guardando..." : "Guardar cambios"}
        </button>
        {saveMsg && (
          <div style={{ marginTop: 14, fontWeight: "bold", color: saveMsg.startsWith("‚úÖ") ? "#0f0" : "#f44" }}>
            {saveMsg}
          </div>
        )}
      </form>
    </div>
  );
}

---------------------------------------------------------------------------------------------------------------

import { useState } from "react"
import { Link, useLocation } from "react-router-dom"
import { useAuth } from "../contexts/AuthContext"
import { useBot } from "../contexts/BotContext"

const SIDEBAR_WIDTH = 220
const SIDEBAR_WIDTH_COLLAPSED = 60

const Layout = ({ children }) => {
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false)
  const { logout, currentUser } = useAuth()
  const { botState } = useBot()
  const location = useLocation()

  const toggleSidebar = () => {
    setSidebarCollapsed(!sidebarCollapsed)
  }

  return (
    <div className="dashboard-container">
      {/* Sidebar */}
      <div className={`sidebar ${sidebarCollapsed ? "sidebar-collapsed" : ""}`}>
        <div className="sidebar-header">
          <Link to="/" className="sidebar-logo">
            <i className="bi bi-robot"></i>
            {!sidebarCollapsed && <span>CEXs Arbitrage IA</span>}
          </Link>
          <button className="sidebar-toggle" onClick={toggleSidebar}>
            <i className={`bi bi-chevron-${sidebarCollapsed ? "right" : "left"}`}></i>
          </button>
        </div>

        <ul className="nav flex-column mt-4">
          <li className="nav-item">
            <Link to="/" className={`nav-link ${location.pathname === "/" ? "active" : ""}`}>
              <i className="bi bi-speedometer2"></i>
              {!sidebarCollapsed && <span>Dashboard</span>}
            </Link>
          </li>
          <li className="nav-item">
            <Link to="/opportunities" className={`nav-link ${location.pathname === "/opportunities" ? "active" : ""}`}>
              <i className="bi bi-graph-up-arrow"></i>
              {!sidebarCollapsed && <span>Oportunidades</span>}
            </Link>
          </li>
          <li className="nav-item">
            <Link to="/ai-advisor" className={`nav-link ${location.pathname === "/ai-advisor" ? "active" : ""}`}>
              <i className="bi bi-robot"></i>
              {!sidebarCollapsed && <span>Asesor IA</span>}
            </Link>
          </li>
          <li className="nav-item">
            <Link to="/reports" className={`nav-link ${location.pathname === "/reports" ? "active" : ""}`}>
              <i className="bi bi-file-earmark-bar-graph"></i>
              {!sidebarCollapsed && <span>Reportes</span>}
            </Link>
          </li>
          <li className="nav-item">
            <Link to="/settings" className={`nav-link ${location.pathname === "/settings" ? "active" : ""}`}>
              <i className="bi bi-gear"></i>
              {!sidebarCollapsed && <span>Configuraci√≥n</span>}
            </Link>
          </li>
        </ul>

        {!sidebarCollapsed && (
          <div className="sidebar-footer">
            <div className="d-flex align-items-center mb-3">
              <div className={`badge me-2 ${botState.isRunning ? "bg-success" : "bg-danger"}`}>
                {botState.isRunning ? "Activo" : "Inactivo"}
              </div>
              <small className="text-white-50">{botState.isRunning ? "Bot en ejecuci√≥n" : "Bot detenido"}</small>
            </div>
            <button className="btn btn-sm btn-light w-100" onClick={logout}>
              <i className="bi bi-box-arrow-right me-2"></i>
              Cerrar Sesi√≥n
            </button>
          </div>
        )}
      </div>

      {/* Header */}
      <header className={`header ${sidebarCollapsed ? "header-expanded" : ""}`}>
        <div className="d-flex justify-content-between align-items-center w-100">
          <div>
            <h5 className="mb-0">
              {location.pathname === "/" && "Dashboard"}
              {location.pathname === "/opportunities" && "Oportunidades de Arbitraje"}
              {location.pathname === "/ai-advisor" && "Asesor de IA"}
              {location.pathname === "/reports" && "Reportes y An√°lisis"}
              {location.pathname === "/settings" && "Configuraci√≥n"}
            </h5>
          </div>

          <div className="d-flex align-items-center">
            {botState.isRunning && (
              <div className="me-4">
                <span className="badge bg-success me-2">
                  <i className="bi bi-play-fill"></i>
                </span>
                <span>Bot Activo</span>
              </div>
            )}

            <div className="dropdown">
              <button
                className="btn btn-sm btn-outline-secondary dropdown-toggle"
                type="button"
                id="userDropdown"
                data-bs-toggle="dropdown"
                aria-expanded="false"
              >
                <i className="bi bi-person-circle me-1"></i>
                {currentUser?.username || "Usuario"}
              </button>
              <ul className="dropdown-menu dropdown-menu-end" aria-labelledby="userDropdown">
                <li>
                  <Link className="dropdown-item" to="/settings">
                    Configuraci√≥n
                  </Link>
                </li>
                <li>
                  <hr className="dropdown-divider" />
                </li>
                <li>
                  <button className="dropdown-item" onClick={logout}>
                    Cerrar Sesi√≥n
                  </button>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main
        className={`main-content ${sidebarCollapsed ? "main-content-expanded" : ""}`}
        style={{
          marginLeft: sidebarCollapsed ? SIDEBAR_WIDTH_COLLAPSED : SIDEBAR_WIDTH,
          transition: "margin-left 0.2s"
        }}
      >
        {children}
      </main>
    </div>
  )
}

export default Layout

-------------------------------------------------------------------------------------------------------------

import React from "react";

export default function OperationHistory({ history }) {
  return (
    <div>
      <h4>Historial de operaciones</h4>
      <table>
        <thead>
          <tr>
            <th>Fecha</th>
            <th>Par</th>
            <th>Acci√≥n</th>
            <th>Resultado</th>
            <th>Motivo</th>
          </tr>
        </thead>
        <tbody>
          {history.map((h, i) => (
            <tr key={i}>
              <td>{h.date}</td>
              <td>{h.pair}</td>
              <td>{h.action}</td>
              <td>{h.success ? "‚úÖ" : "‚ùå"}</td>
              <td>{h.reason}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}


--------------------------------------------------------------------------------------------------------------

import React from "react";

// Tabla de fees y m√≠nimos para cada token/red/exchange
const FEES = {
  LTC: {
    binance: {
      withdraw: 0.0001,
      withdrawMin: 0.002,
      trade: 0.001, // 0.1%
      deposit: 0,
      depositMin: 0.002,
    },
    bybit: {
      withdraw: 0.0001,
      withdrawMin: 0.001,
      trade: 0.001,
      deposit: 0,
      depositMin: 0.00000001,
    },
  },
  BNB: {
    binance: {
      withdraw: 0.00001,
      withdrawMin: 0.0005,
      trade: 0.001,
      deposit: 0,
      depositMin: 0.000003,
    },
    bybit: {
      withdraw: 0.0002,
      withdrawMin: 0.0002,
      trade: 0.001,
      deposit: 0,
      depositMin: 0,
    },
  },
  XRP: {
    binance: {
      withdraw: 0.2,
      withdrawMin: 2,
      trade: 0.001,
      deposit: 0,
      depositMin: 0.001,
    },
    bybit: {
      withdraw: 0.2,
      withdrawMin: 1.2,
      trade: 0.001,
      deposit: 0,
      depositMin: 0.01,
    },
  },
  USDT: {
    binance: {
      withdraw: 0.2,
      withdrawMin: 10,
      trade: 0.001,
      deposit: 0,
      depositMin: 0.002,
    },
    bybit: {
      withdraw: 0.3,
      withdrawMin: 1,
      trade: 0.001,
      deposit: 0,
      depositMin: 0.001,
    },
  },
};

const STABLECOINS = ["USDT", "USDC", "BUSD", "DAI"];

// Calcula el profit neto despu√©s de comisiones y m√≠nimos
function calcProfitNeto(op, prices) {
  const [sym] = op.pair.split("/");
  const base = op.buyExchange.toLowerCase(); // binance o bybit
  const target = op.sellExchange.toLowerCase();

  // Precios de compra y venta (en USDT)
  const priceCompra = prices[sym]?.[base];
  const priceVenta = prices[sym]?.[target];
  if (!priceCompra || !priceVenta) return null;

  const monto = Number(op.amount);

  // Validar contra m√≠nimos de retiro y dep√≥sito
  if (
    monto < FEES[sym][base].withdrawMin ||
    monto < FEES[sym][target].depositMin
  )
    return null;

  // Fees
  const feeTradeBuy = monto * FEES[sym][base].trade;
  const feeRetiro = FEES[sym][base].withdraw;
  const feeTradeSell =
    (monto - feeTradeBuy - feeRetiro) * FEES[sym][target].trade;
  const totalTokenRecibido =
    monto - feeTradeBuy - feeRetiro - feeTradeSell;

  // Profit neto en USDT
  const usdtFinal = totalTokenRecibido * priceVenta;
  const usdtInicial = monto * priceCompra;
  const profitNeto = usdtFinal - usdtInicial;
  const profitNetoPct = ((profitNeto / usdtInicial) * 100).toFixed(2);

  return { profitNeto, profitNetoPct };
}

function isStablecoinPair(pair) {
  const tokens = pair.split("/");
  return (
    STABLECOINS.includes(tokens[0]) && STABLECOINS.includes(tokens[1])
  );
}

function OpportunitiesPanel({ prices }) {
  const [opps, setOpps] = React.useState([]);

  React.useEffect(() => {
    // Cambia la URL por la de tu backend real
    fetch("http://localhost:8888/api/opportunities")
      .then((res) => res.json())
      .then((res) => {
        if (Array.isArray(res)) setOpps(res);
        else if (Array.isArray(res.data)) setOpps(res.data);
        else setOpps([]);
      })
      .catch(() => setOpps([]));
  }, []);

  // Filtros realistas para bajo presupuesto y oportunidades alcanzables
  const MAX_AMOUNT = 50; // Monto m√°ximo por operaci√≥n

  const filteredOpps = Array.isArray(opps)
    ? opps
        .filter(
          (op) =>
            !isStablecoinPair(op.pair) &&
            Number(op.amount) <= MAX_AMOUNT
        )
        .map((op) => {
          const profitNet = calcProfitNeto(op, prices);
          return profitNet
            ? { ...op, profitNeto: profitNet.profitNeto, profitNetoPct: profitNet.profitNetoPct }
            : null;
        })
        .filter(
          (op) =>
            op &&
            op.profitNeto > 0.10 // Solo si el profit neto es mayor a 10 centavos
        )
    : [];

  return (
    <div className="dashboard-card">
      <div className="card-header">
        <span className="emoji">üí∞</span>Oportunidades Realistas de Arbitraje
      </div>
      <div className="table-responsive">
        <table className="dashboard-table">
          <thead>
            <tr>
              <th>Par</th>
              <th>Exchanges</th>
              <th>Profit Neto</th>
              <th>Profit Neto %</th>
              <th>Confianza</th>
              <th>Monto</th>
              <th>Tiempo</th>
            </tr>
          </thead>
          <tbody>
            {filteredOpps.length === 0 ? (
              <tr>
                <td colSpan="7" className="text-center py-4">
                  No hay oportunidades realistas en este momento.
                </td>
              </tr>
            ) : (
              filteredOpps.map((op, idx) => (
                <tr key={idx}>
                  <td>{op.pair}</td>
                  <td>
                    {op.buyExchange} ‚Üí {op.sellExchange}
                  </td>
                  <td className={op.profitNeto > 0 ? "text-success" : "text-danger"}>
                    {op.profitNeto ? op.profitNeto.toFixed(3) + " USDT" : "-"}
                  </td>
                  <td className={op.profitNetoPct > 0 ? "text-success" : "text-danger"}>
                    {op.profitNetoPct ? op.profitNetoPct + " %" : "-"}
                  </td>
                  <td>
                    <div className="progress" style={{ height: "6px" }}>
                      <div
                        className="progress-bar bg-success"
                        style={{ width: (op.confidence * 100) + "%" }}
                      ></div>
                    </div>
                    <small>{(op.confidence * 100).toFixed(1)}%</small>
                  </td>
                  <td>{op.amount} {op.pair.split("/")[0]}</td>
                  <td>{op.time}</td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
      <div style={{ fontSize: "0.9em", marginTop: 10, color: "#888" }}>
        * El profit neto ya descuenta fees de trading, retiro y m√≠nimos de cada red/exchange.<br />
        * Solo se muestran oportunidades que puedes aprovechar con bajo presupuesto.<br />
        * No se muestran oportunidades entre stablecoins.
      </div>
    </div>
  );
}

export default OpportunitiesPanel;

-----------------------------------------------------------------------------------------------------------

import React, { useState } from "react";
import TokenPairsTable from "./TokenPairsTable";
import OperationHistory from "./OperationHistory";
import pairsData from "../config/pairs_full.json";

const exampleHistory = [
  { date: "2025-06-18 13:02", pair: "LTC/USDT", action: "Buy", success: false, reason: "Spread insuficiente" },
  { date: "2025-06-18 12:42", pair: "BTC/USDT", action: "Sell", success: true, reason: "" }
];

export default function PairsPanel() {
  const [pairs, setPairs] = useState(pairsData);
  const handleEdit = (updatedPair) => {
    setPairs(pairs.map(p => p.pair === updatedPair.pair ? updatedPair : p));
    // Aqu√≠ podr√≠as hacer PUT a la API para guardar cambios en backend
  };

  return (
    <div>
      <h2>Dashboard de Pares y Tokens</h2>
      <TokenPairsTable pairs={pairs} onEdit={handleEdit} />
      <OperationHistory history={exampleHistory} />
    </div>
  );
}

--------------------------------------------------------------------------------------------------------------

import React from "react";
import { Link } from "react-router-dom";

const Sidebar = () => (
  <div className="sidebar">
    <ul>
      <li><Link to="/dashboard">Inicio</Link></li>
      <li><Link to="/general-config">Configuraci√≥n General</Link></li>
      <li><Link to="/exchanges">Exchanges</Link></li>
      <li><Link to="/strategies">Estrategias de Trading</Link></li>
      <li><Link to="/risk">Gesti√≥n de Riesgos</Link></li>
      <li><Link to="/portfolio">Portfolio y Balances</Link></li>
      <li><Link to="/alerts">Alertas y Notificaciones</Link></li>
      <li><Link to="/ai">Inteligencia Artificial</Link></li>
      <li><Link to="/backtesting">Backtesting</Link></li>
      <li><Link to="/mobile-api">API M√≥vil</Link></li>
      <li><Link to="/logs">Logs y Monitoreo</Link></li>
      <li><Link to="/security">Seguridad</Link></li>
      <li><Link to="/troubleshooting">Troubleshooting</Link></li>
    </ul>
  </div>
);

export default Sidebar;


------------------------------------------------------------------------------------------------------------

import React from "react";

export default function StatusBadge({ active }) {
  return (
    <span style={{
      color: "#fff",
      padding: "2px 8px",
      borderRadius: 4,
      backgroundColor: active ? "green" : "gray"
    }}>
      {active ? "Activo" : "Inactivo"}
    </span>
  );
}

----------------------------------------------------------------------------------------------------------------

import React, { useState } from "react";
import StatusBadge from "./StatusBadge";
import AlertBanner from "./AlertBanner";
import TokenReviewTimer from "./TokenReviewTimer";

// Cambia esto si tu API_BASE est√° en otro archivo/config
const API_BASE = "http://localhost:8888/api";

export default function TokenPairsTable({ pairs, onEdit }) {
  const [editing, setEditing] = useState({}); // {pair: {campo: valor}}

  // Cuando se empieza a editar una celda
  const startEdit = (pair, field, value) => {
    setEditing({
      ...editing,
      [pair]: { ...editing[pair], [field]: value }
    });
  };

  // Cuando se cambia el valor de input
  const handleEdit = (pair, field, value) => {
    setEditing({
      ...editing,
      [pair]: { ...editing[pair], [field]: value }
    });
  };

  // Guardar el cambio (frontend + backend)
  const handleSave = async (pair, field) => {
    if (editing[pair] && editing[pair][field] !== undefined) {
      const updatedPair = { ...pairs.find(p => p.pair === pair), [field]: editing[pair][field] };
      // Llama a la API para guardar el cambio (PUT)
      try {
        await fetch(`${API_BASE}/pairs/${pair}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(updatedPair)
        });
      } catch (e) {
        // Opcional: muestra toast de error
      }
      onEdit(updatedPair); // actualiza estado en frontend
      setEditing({ ...editing, [pair]: { ...editing[pair], [field]: undefined } });
    }
  };

  // Para mostrar valor editable o fijo en cada celda
  const renderEditableCell = (p, field, min, max, step) => {
    const isEditing = editing[p.pair] && editing[p.pair][field] !== undefined;
    return (
      <td
        className={
          field === "min_spread" && p.min_spread < 0.002
            ? "warning-cell"
            : field === "max_slippage" && p.max_slippage > 0.01
            ? "warning-cell"
            : ""
        }
        onClick={() => !isEditing && startEdit(p.pair, field, p[field])}
        style={{ cursor: "pointer", minWidth: 80 }}
      >
        {isEditing ? (
          <input
            className="inline-edit"
            type="number"
            min={min}
            max={max}
            step={step}
            value={editing[p.pair][field]}
            onChange={e => handleEdit(p.pair, field, e.target.value)}
            onBlur={() => handleSave(p.pair, field)}
            onKeyDown={e => e.key === "Enter" && handleSave(p.pair, field)}
            autoFocus
            style={{ width: 60 }}
          />
        ) : (
          <>
            {p[field]}
            {field === "min_spread" && p.min_spread < 0.002 && (
              <span style={{ color: "#ff9800", marginLeft: 4 }}>‚ö†Ô∏è Bajo</span>
            )}
            {field === "max_slippage" && p.max_slippage > 0.01 && (
              <span style={{ color: "#ff9800", marginLeft: 4 }}>‚ö†Ô∏è Alto</span>
            )}
          </>
        )}
      </td>
    );
  };

  return (
    <table className="dashboard-table">
      <thead>
        <tr>
          <th>Par</th>
          <th>Red (Binance/Bybit)</th>
          <th>Fee Trading</th>
          <th>Spread Min</th>
          <th>Slippage M√°x</th>
          <th>Fee Retiro</th>
          <th>Volumen Min</th>
          <th>Status</th>
          <th>√öltima revisi√≥n</th>
        </tr>
      </thead>
      <tbody>
        {pairs.map((p) => (
          <tr key={p.pair}
            className={
              (p.min_spread < 0.002 || p.max_slippage > 0.01) ? "warning-row" : ""
            }
          >
            <td>{p.pair}</td>
            <td>
              {p.binance.network} / {p.bybit.network}
            </td>
            <td>{p.trading_fee}</td>
            {/* Spread Min EDITABLE */}
            {renderEditableCell(p, "min_spread", 0, 1, 0.0001)}
            {/* Slippage M√°x EDITABLE */}
            {renderEditableCell(p, "max_slippage", 0, 1, 0.0001)}
            <td>
              {p.binance.withdrawal_fee} / {p.bybit.withdrawal_fee}
            </td>
            <td>{p.min_trade}</td>
            <td>
              <StatusBadge active={p.active} />
            </td>
            <td>
              <TokenReviewTimer lastReview={p.last_review} />
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}

------------------------------------------------------------------------------------------------------------

import React from "react";

export default function TokenReviewTimer({ lastReview }) {
  const last = new Date(lastReview);
  const now = new Date();
  const diffHours = Math.floor((now - last) / 1000 / 3600);
  return (
    <span>
      Hace {diffHours}h
      {diffHours >= 12 && (
        <span style={{ color: "orange", fontWeight: "bold", marginLeft: 6 }}>
          (¬°Revisi√≥n necesaria!)
        </span>
      )}
    </span>
  );
}

------------------------------------------------------------------------------------------------------------

CONFIG

[
  {
    "pair": "LTC/USDT",
    "base": "LTC",
    "quote": "USDT",
    "binance": {
      "address": "LiCH4dMWM6YRHFWYC78hppAk1SwUFkDAK4",
      "network": "Litecoin",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.002,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "LLCxH3L5fn9ejTPVk3nWTJcqvvTWsu2LbJ",
      "network": "Litecoin",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.001,
      "deposit_min": 0.00000001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 50,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BNB/USDT",
    "base": "BNB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.00001,
      "withdrawal_min": 0.0005,
      "deposit_min": 0.000003
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.0002,
      "withdrawal_min": 0.0002,
      "deposit_min": 0.0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 30,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XRP/USDT",
    "base": "XRP",
    "quote": "USDT",
    "binance": {
      "address": "rNxp4h8apvRis6mJf9Sh8C6iRxfrDWN7AV",
      "network": "XRP",
      "memo": "466152795",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "rJn2zAPdFA193sixJwuFixRkYDUtx3apQh",
      "network": "XRP",
      "memo": "501350199",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 1.2,
      "deposit_min": 0.01
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 40,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ALGO/USDT",
    "base": "ALGO",
    "quote": "USDT",
    "binance": {
      "address": "L43SHHRVHAIYHGFGXFBKM7IMZNYT7WSLSMXPHGNH4D5NPYOBIJSK35X5OE",
      "network": "ALGO",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 10,
      "deposit_min": 0.007
    },
    "bybit": {
      "address": "U5EPBBGTH4ZHEJMSYWRRBEOTOORYTSTSTYZITGDYM2KUQPDXWTHFDJPFVY",
      "network": "ALGO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 10,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ANIME/USDT",
    "base": "ANIME",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 7.74,
      "withdrawal_min": 16,
      "deposit_min": 0.00000001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "ARBI",
      "withdrawal_fee": 16,
      "withdrawal_min": 30,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "APT/USDT",
    "base": "APT",
    "quote": "USDT",
    "binance": {
      "address": "0x0b69478291cb55e808a716a046cc0d1ab2981e85778957da3fd519c6061ccb9e",
      "network": "APT",
      "withdrawal_fee": 0.016,
      "withdrawal_min": 0.06,
      "deposit_min": 0.00015
    },
    "bybit": {
      "address": "0x9f5ade930d03eb3fd1f0906f4e7edaddc458ac71260bf985bb61cfb61ac09191",
      "network": "APTOS",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ARB/USDT",
    "base": "ARB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 0.56,
      "withdrawal_min": 1.12,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.4,
      "withdrawal_min": 0.4,
      "deposit_min": 0.00000001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ATOM/USDT",
    "base": "ATOM",
    "quote": "USDT",
    "binance": {
      "address": "cosmos1j8pp7zvcu9z8vd882m284j29fn2dszh05cqvf9",
      "network": "ATOM",
      "memo": "100738176",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.04,
      "deposit_min": 0.00016
    },
    "bybit": {
      "address": "cosmos1c8dskmuz2wj29tg3rygt8mzg92f09gwcqqyexa",
      "network": "ATOM",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.015,
      "deposit_min": 0.0001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "AVAX/USDT",
    "base": "AVAX",
    "quote": "USDT",
    "binance": {
      "address": "X-avax1j2suzh09083n9cyd80dk3lsr0c3e8ry3skk27q",
      "network": "AVAX",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 0.1,
      "deposit_min": 0.00005
    },
    "bybit": {
      "address": "X-avax1unlvn8ef6lpjsac0t37t9za6astc8a55pugnm2",
      "network": "AVAX",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 0.008,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "AXL/USDT",
    "base": "AXL",
    "quote": "USDT",
    "binance": {
      "address": "axelar17ewha7y7fr0xsej6xfep88rq30rse9hgynll78",
      "network": "AXL",
      "memo": "101408734",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 1,
      "deposit_min": 0.0015
    },
    "bybit": {
      "address": "axelar1yzsury9fldydgk425gmphy2zyehh3emc43ds6x",
      "network": "AXL",
      "memo": "10048670",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BB/USDT",
    "base": "BB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BounceBit",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 1,
      "deposit_min": 0.06
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BounceBit",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BEL/USDT",
    "base": "BEL",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.051,
      "withdrawal_min": 0.1,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.12,
      "withdrawal_min": 0.12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BERA/USDT",
    "base": "BERA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BERA",
      "withdrawal_fee": 0.001,
      "withdrawal_min": 0.1,
      "deposit_min": 0.00000002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BERA",
      "withdrawal_fee": 0.000001,
      "withdrawal_min": 0.00001,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BOME/USDT",
    "base": "BOME",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 380,
      "withdrawal_min": 760,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 400,
      "withdrawal_min": 200,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BONK/USDT",
    "base": "BONK",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 41657,
      "withdrawal_min": 83314,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 40000,
      "withdrawal_min": 50000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "C98/USDT",
    "base": "C98",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.26,
      "withdrawal_min": 0.52,
      "deposit_min": 0.007
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CAKE/USDT",
    "base": "CAKE",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.0057,
      "withdrawal_min": 0.011,
      "deposit_min": 0.0006
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.023,
      "withdrawal_min": 0.023,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CATI/USDT",
    "base": "CATI",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 1.08,
      "withdrawal_min": 2.16,
      "deposit_min": 0.00000002
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
    },

  {
    "pair": "CELO/USDT",
    "base": "CELO",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "CELO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.1,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "CELO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CGPT/USDT",
    "base": "CGPT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 10,
      "withdrawal_min": 20,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 12,
      "withdrawal_min": 12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CHZ/USDT",
    "base": "CHZ",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Chiliz Chain",
      "withdrawal_fee": 20,
      "withdrawal_min": 40,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Chiliz Chain",
      "withdrawal_fee": 10,
      "withdrawal_min": 10,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CYBER/USDT",
    "base": "CYBER",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.4,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DOGS/USDT",
    "base": "DOGS",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DOT/USDT",
    "base": "DOT",
    "quote": "USDT",
    "binance": {
      "address": "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm",
      "network": "DOT",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 1.5,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm",
      "network": "DOT",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 40,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DYDX/USDT",
    "base": "DYDX",
    "quote": "USDT",
    "binance": {
      "address": "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq",
      "network": "DYDX",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq",
      "network": "DYDX",
      "withdrawal_fee": 0.09,
      "withdrawal_min": 0.09,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "EGLD/USDT",
    "base": "EGLD",
    "quote": "USDT",
    "binance": {
      "address": "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4",
      "network": "EGLD",
      "withdrawal_fee": 0.004,
      "withdrawal_min": 0.008,
      "deposit_min": 0.0005
    },
    "bybit": {
      "address": "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4",
      "network": "EGLD",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ENJ/USDT",
    "base": "ENJ",
    "quote": "USDT",
    "binance": {
      "address": "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i",
      "network": "Enjin",
      "withdrawal_fee": 15,
      "withdrawal_min": 30,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i",
      "network": "Enjin",
      "withdrawal_fee": 12,
      "withdrawal_min": 12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FIDA/USDT",
    "base": "FIDA",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FLOKI/USDT",
    "base": "FLOKI",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 210000,
      "withdrawal_min": 420000,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 200000,
      "withdrawal_min": 200000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FLOW/USDT",
    "base": "FLOW",
    "quote": "USDT",
    "binance": {
      "address": "0xdbb61e402a382eb3",
      "network": "FLOW",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.05,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0xdbb61e402a382eb3",
      "network": "FLOW",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.02,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "GMT/USDT",
    "base": "GMT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 1.2,
      "withdrawal_min": 1.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "GMX/USDT",
    "base": "GMX",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "AVAXC",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "AVAXC",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HAEDAL/USDT",
    "base": "HAEDAL",
    "quote": "USDT",
    "binance": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HBAR/USDT",
    "base": "HBAR",
    "quote": "USDT",
    "binance": {
      "address": "0.0.615422",
      "network": "HBAR",
      "memo": "10067078",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0.0.615422",
      "network": "HBAR",
      "memo": "10067078",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HMSTR/USDT",
    "base": "HMSTR",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "HOME/USDT",
    "base": "HOME",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.13,
      "withdrawal_min": 0.13,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.12,
      "withdrawal_min": 0.12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HYPER/USDT",
    "base": "HYPER",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 3,
      "withdrawal_min": 3,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 3,
      "withdrawal_min": 3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ICP/USDT",
    "base": "ICP",
    "quote": "USDT",
    "binance": {
      "address": "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a",
      "network": "ICP",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.0002,
      "deposit_min": 0.00002
    },
    "bybit": {
      "address": "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a",
      "network": "ICP",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.0001,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ICX/USDT",
    "base": "ICX",
    "quote": "USDT",
    "binance": {
      "address": "hx8c278a658331a569b640e925ac55a70a8e5534b6",
      "network": "ICX",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "hx8c278a658331a569b640e925ac55a70a8e5534b6",
      "network": "ICX",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.02,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "INJ/USDT",
    "base": "INJ",
    "quote": "USDT",
    "binance": {
      "address": "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n",
      "network": "INJ",
      "memo": "10014232",
      "withdrawal_fee": 0.002,
      "withdrawal_min": 0.005,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n",
      "network": "INJ",
      "memo": "10014232",
      "withdrawal_fee": 0.002,
      "withdrawal_min": 0.002,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "IO/USDT",
    "base": "IO",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "JUP/USDT",
    "base": "JUP",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KAIA/USDT",
    "base": "KAIA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "KAIA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "KAIA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KMNO/USDT",
    "base": "KMNO",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KSM/USDT",
    "base": "KSM",
    "quote": "USDT",
    "binance": {
      "address": "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV",
      "network": "KSM",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV",
      "network": "KSM",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "LUNA/USDT",
    "base": "LUNA",
    "quote": "USDT",
    "binance": {
      "address": "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s",
      "network": "Terra",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s",
      "network": "Terra",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MAGIC/USDT",
    "base": "MAGIC",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 0.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MANTA/USDT",
    "base": "MANTA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Manta Pacific Mainnet",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Manta Pacific Mainnet",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MBOX/USDT",
    "base": "MBOX",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 0.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MINA/USDT",
    "base": "MINA",
    "quote": "USDT",
    "binance": {
      "address": "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW",
      "network": "MINA",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.04,
      "deposit_min": 0.00005
    },
    "bybit": {
      "address": "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW",
      "network": "MINA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "NEAR/USDT",
    "base": "NEAR",
    "quote": "USDT",
    "binance": {
      "address": "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef",
      "network": "NEAR",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef",
      "network": "NEAR",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "NOT/USDT",
    "base": "NOT",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ONE/USDT",
    "base": "ONE",
    "quote": "USDT",
    "binance": {
      "address": "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3",
      "network": "ONE",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3",
      "network": "ONE",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "OP/USDT",
    "base": "OP",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "PSG/USDT",
    "base": "PSG",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 0.2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 0.05,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "PYTH/USDT",
    "base": "PYTH",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "RDNT/USDT",
    "base": "RDNT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ROSE/USDT",
    "base": "ROSE",
    "quote": "USDT",
    "binance": {
      "address": "rose1u9v2v6w437w7d2na4w4qm6t9w7yzn0hy2l8q4x",
      "network": "Oasis",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "rose1u9v2v6w437w7d2na4w4qm6t9w7yzn0hy2l8q4x",
      "network": "Oasis",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SCRT/USDT",
    "base": "SCRT",
    "quote": "USDT",
    "binance": {
      "address": "secret1g4d9f6k4z0n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Secret",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "secret1g4d9f6k4z0n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Secret",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SEI/USDT",
    "base": "SEI",
    "quote": "USDT",
    "binance": {
      "address": "sei1p6k4q8c6g36w7z0n9gx7t4z3u7e7m3a4c8l4yc8",
      "network": "SEI",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "sei1p6k4q8c6g36w7z0n9gx7t4z3u7e7m3a4c8l4yc8",
      "network": "SEI",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SHIB/USDT",
    "base": "SHIB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 2000000,
      "withdrawal_min": 4000000,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 2000000,
      "withdrawal_min": 2000000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SIGN/USDT",
    "base": "SIGN",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "STX/USDT",
    "base": "STX",
    "quote": "USDT",
    "binance": {
      "address": "SP3K8Z0E6H43N2VZ2YB6A7A5JY8X3N3N8M9TD8K4F",
      "network": "Stacks",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "SP3K8Z0E6H43N2VZ2YB6A7A5JY8X3N3N8M9TD8K4F",
      "network": "Stacks",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SUI/USDT",
    "base": "SUI",
    "quote": "USDT",
    "binance": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TIA/USDT",
    "base": "TIA",
    "quote": "USDT",
    "binance": {
      "address": "celestia1h4q4j8j3y6n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Celestia",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "celestia1h4q4j8j3y6n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Celestia",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TNSR/USDT",
    "base": "TNSR",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TON/USDT",
    "base": "TON",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TRUMP/USDT",
    "base": "TRUMP",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 1.5,
      "withdrawal_min": 1.5,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 1.5,
      "withdrawal_min": 1.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TRX/USDT",
    "base": "TRX",
    "quote": "USDT",
    "binance": {
      "address": "TQ7DuEjJXQ6gHzXfWnA3SA8k6nJk8jWZKQ",
      "network": "TRON",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "TQ7DuEjJXQ6gHzXfWnA3SA8k6nJk8jWZKQ",
      "network": "TRON",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "WAXP/USDT",
    "base": "WAXP",
    "quote": "USDT",
    "binance": {
      "address": "wax1k2v4m4rzk5ljh37u2f454p4w3ffj4qk8p3rkxf",
      "network": "WAX",
      "withdrawal_fee": 2,
      "withdrawal_min": 4,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "wax1k2v4m4rzk5ljh37u2f454p4w3ffj4qk8p3rkxf",
      "network": "WAX",
      "withdrawal_fee": 2,
      "withdrawal_min": 2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WCT/USDT",
    "base": "WCT",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WIF/USDT",
    "base": "WIF",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 55,
      "withdrawal_min": 110,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 50,
      "withdrawal_min": 50,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WLD/USDT",
    "base": "WLD",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Ethereum",
      "withdrawal_fee": 0.23,
      "withdrawal_min": 0.46,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Ethereum",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XAI/USDT",
    "base": "XAI",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.7,
      "withdrawal_min": 1.4,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XLM/USDT",
    "base": "XLM",
    "quote": "USDT",
    "binance": {
      "address": "GC3ZP2U7WJ2JK3MNHVZ4V8UIG4N2PJS4C42R7V7C6H5D2A5WA7HD6WJR",
      "network": "Stellar",
      "memo": "3574998388",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "GC3ZP2U7WJ2JK3MNHVZ4V8UIG4N2PJS4C42R7V7C6H5D2A5WA7HD6WJR",
      "network": "Stellar",
      "memo": "3574998388",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ZIL/USDT",
    "base": "ZIL",
    "quote": "USDT",
    "binance": {
      "address": "zil1hkycgdsq0zj0gkc7hlzm7s9y2q2n6g4z9v6xdh",
      "network": "Zilliqa",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "zil1hkycgdsq0zj0gkc7hlzm7s9y2q2n6g4z9v6xdh",
      "network": "Zilliqa",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ZRO/USDT",
    "base": "ZRO",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 0.04,
      "withdrawal_min": 0.08,
      "deposit_min": 0.00026
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "AVAXC",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  }
]

----------------------------------------------------------------------------------------------------------------

CONTEXT

"use client"

import { createContext, useState, useContext, useEffect } from "react"
import api from "../services/api"

const AuthContext = createContext()

export const useAuth = () => useContext(AuthContext)

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null)
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Verificar si hay un token guardado
    const token = localStorage.getItem("token")
    const userData = localStorage.getItem("user")

    if (token && userData) {
      setCurrentUser(JSON.parse(userData))
      setIsAuthenticated(true)
      api.setAuthToken(token)
    }

    setLoading(false)
  }, [])

  const login = async (username, password) => {
    try {
      setLoading(true)
      const response = await api.post("/api/login", { username, password })

      const { token, user } = response.data

      localStorage.setItem("token", token)
      localStorage.setItem("user", JSON.stringify(user))

      setCurrentUser(user)
      setIsAuthenticated(true)
      api.setAuthToken(token)

      return { success: true }
    } catch (error) {
      return {
        success: false,
        message: error.response?.data?.message || "Error de autenticaci√≥n",
      }
    } finally {
      setLoading(false)
    }
  }

  const logout = () => {
    localStorage.removeItem("token")
    localStorage.removeItem("user")
    setCurrentUser(null)
    setIsAuthenticated(false)
    api.removeAuthToken()
  }

  const value = {
    currentUser,
    isAuthenticated,
    loading,
    login,
    logout,
  }

  return <AuthContext.Provider value={value}>{!loading && children}</AuthContext.Provider>
}




--------------------------------------------------------------------------------------------------------------

"use client"

import { createContext, useState, useContext, useEffect } from "react"
import api from "../services/apiRoutes"

const BotContext = createContext()

export const useBot = () => useContext(BotContext)

export const BotProvider = ({ children, socket }) => {
  const [botState, setBotState] = useState({
    isRunning: false,
    totalTrades: 0,
    successfulTrades: 0,
    totalProfit: 0,
    dailyTrades: 0,
    dailyProfit: 0,
    dailyLoss: 0,
    cycleCount: 0,
    emergencyStop: false,
    pausedDueToAnomalies: false,
    pauseReason: "",
  })

  const [exposure, setExposure] = useState({
    total: 0,
    byPair: {},
  })

  const [balances, setBalances] = useState({
    BINANCE: {},
    KUCOIN: {},
  })

  const [opportunities, setOpportunities] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  // Cargar estado inicial
  useEffect(() => {
    const fetchInitialData = async () => {
      try {
        setLoading(true)

        // Obtener estado del bot
        const statusResponse = await api.get("/api/status")
        setBotState(statusResponse.data.botState)
        setExposure(statusResponse.data.exposure)

        // Obtener balances
        const balancesResponse = await api.get("/api/balances")
        setBalances(balancesResponse.data)

        // Obtener oportunidades
        const opportunitiesResponse = await api.get("/api/opportunities")
        setOpportunities(opportunitiesResponse.data)

        setError(null)
      } catch (error) {
        console.error("Error fetching initial data:", error)
        setError("Error cargando datos iniciales")
      } finally {
        setLoading(false)
      }
    }

    fetchInitialData()
  }, [])

  // Escuchar actualizaciones en tiempo real
  useEffect(() => {
    if (!socket) return

    socket.on("status_update", (data) => {
      setBotState(data.botState)
      setExposure(data.exposure)
    })

    socket.on("new_opportunity", (data) => {
      setOpportunities((prev) => [data, ...prev].slice(0, 20))
    })

    socket.on("balance_update", (data) => {
      setBalances(data)
    })

    return () => {
      socket.off("status_update")
      socket.off("new_opportunity")
      socket.off("balance_update")
    }
  }, [socket])

  // Iniciar el bot
  const startBot = async () => {
    try {
      const response = await api.post("/api/bot/start")
      if (response.data.success) {
        setBotState((prev) => ({ ...prev, isRunning: true }))
      }
      return response.data
    } catch (error) {
      console.error("Error starting bot:", error)
      return { success: false, message: error.response?.data?.message || "Error iniciando el bot" }
    }
  }

  // Detener el bot
  const stopBot = async () => {
    try {
      const response = await api.post("/api/bot/stop")
      if (response.data.success) {
        setBotState((prev) => ({ ...prev, isRunning: false }))
      }
      return response.data
    } catch (error) {
      console.error("Error stopping bot:", error)
      return { success: false, message: error.response?.data?.message || "Error deteniendo el bot" }
    }
  }

  // Ejecutar arbitraje manualmente
  const executeArbitrage = async (opportunityId) => {
    try {
      const response = await api.post("/api/bot/execute", { opportunityId })
      return response.data
    } catch (error) {
      console.error("Error executing arbitrage:", error)
      return { success: false, message: error.response?.data?.message || "Error ejecutando arbitraje" }
    }
  }

  // Actualizar configuraci√≥n
  const updateSettings = async (settings) => {
    try {
      const response = await api.post("/api/bot/settings", { settings })
      return response.data
    } catch (error) {
      console.error("Error updating settings:", error)
      return { success: false, message: error.response?.data?.message || "Error actualizando configuraci√≥n" }
    }
  }

  // Obtener reporte
  const getReport = async () => {
    try {
      const response = await api.get("/api/report")
      return response.data
    } catch (error) {
      console.error("Error fetching report:", error)
      throw new Error(error.response?.data?.message || "Error obteniendo reporte")
    }
  }

  // Obtener sugerencias de IA
  const getAISuggestions = async () => {
    try {
      const response = await api.get("/api/ai/suggestions")
      return response.data
    } catch (error) {
      console.error("Error fetching AI suggestions:", error)
      throw new Error(error.response?.data?.message || "Error obteniendo sugerencias de IA")
    }
  }

  const value = {
    botState,
    exposure,
    balances,
    opportunities,
    loading,
    error,
    startBot,
    stopBot,
    executeArbitrage,
    updateSettings,
    getReport,
    getAISuggestions,
    refreshOpportunities: async () => {
      try {
        const response = await api.get("/api/opportunities")
        setOpportunities(response.data)
        return { success: true }
      } catch (error) {
        console.error("Error refreshing opportunities:", error)
        return { success: false, message: error.message }
      }
    },
  }

  return <BotContext.Provider value={value}>{children}</BotContext.Provider>
}

--------------------------------------------------------------------------------------------------------


CORE 


const EventEmitter = require('events');
const nodemailer = require('nodemailer');
const axios = require('axios');

/**
 * Gestor de Alertas
 * Maneja notificaciones por email, Telegram, Discord y Slack
 */
class AlertManager extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.enabled = config.ALERTS.ENABLED;
        this.channels = config.ALERTS.CHANNELS;
        this.alertTypes = config.ALERTS.ALERT_TYPES;
        
        this.emailTransporter = null;
        this.alertHistory = [];
        this.alertQueue = [];
        this.isProcessingQueue = false;
        
        this.logger = console;
    }

    initialize() {
        // M√©todo vac√≠o para compatibilidad con el bot base
        // Agrega aqu√≠ inicializaci√≥n si la necesitas en el futuro
    }
    
    // ... (el resto de los m√©todos de AlertManager quedan igual, como en tu dump)
}

module.exports = AlertManager;

----------------------------------------------------------------------------------------------------------

const StrategyManager = require('./StrategyManager');
const AlertManager = require('./AlertManager');
const ExchangeManager = require('../exchanges/exchange-manager');

class CEXArbitrageBot {
    constructor(config) {
        this.config = config;
        this.logger = console;
        this.exchangeManager = new ExchangeManager(config);
        this.strategyManager = new StrategyManager(config);   // <-- AGREGADO
        this.alertManager = new AlertManager(config);         // <-- AGREGADO
        console.log("‚úÖ CEXArbitrageBot base inicializado");
        this.botState = {
            isRunning: false,
            totalProfit: 0
        };
    }

    async initialize() {
    this.logger.info('Iniciando bot de arbitraje...');
    if (typeof this.strategyManager.initialize === 'function') {
        this.strategyManager.initialize();
    }
    await this.alertManager.initialize();
    this.logger.info('Bot inicializado correctamente');
}

    async start() {
        console.log("‚öôÔ∏è Bot base iniciado");
        if (this.isRunning) return;
        await this.initialize();
        this.isRunning = true;
        this.logger.info('Bot arrancando ciclo de arbitraje...');
        while (this.isRunning) {
            try {
                const prices = {
                    BINANCE: Math.random() * 100 + 100,
                    KUCOIN: Math.random() * 100 + 100,
                    OKX: Math.random() * 100 + 100
                };
                const pair = "BTC/USDT";
                const opportunities = [
                    ...this.strategyManager.findBasicArbitrage(prices, pair),
                    ...this.strategyManager.findTriangularArbitrage(prices, pair),
                    ...this.strategyManager.findStatisticalArbitrage(prices, pair)
                ];
                if (opportunities.length > 0) {
                    for (const opp of opportunities) {
                        await this.alertManager.sendAlert(
                            "OPPORTUNITY",
                            `Oportunidad de arbitraje detectada: ${opp.strategy} (${opp.profitPercentage.toFixed(2)}%)`,
                            opp
                        );
                        this.strategyManager.updateStrategyPerformance(opp.strategy, {
                            success: true,
                            profit: opp.profitPercentage
                        });
                    }
                }
                await this._sleep(10000);
            } catch (error) {
                this.logger.error('Error en el ciclo principal:', error);
            }
        }
    }

    stop() {
        console.log("‚öôÔ∏è Bot base detenido");
        this.isRunning = false;
        this.logger.info('Bot detenido.');
    }

    _sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

module.exports = { CEXArbitrageBot };


------------------------------------------------------------------------------------------------------------

const EventEmitter = require('events');

/**
 * Gestor de Estrategias
 * Maneja m√∫ltiples estrategias de arbitraje y su selecci√≥n
 */
class StrategyManager extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.strategies = config.STRATEGIES;
        this.activeStrategy = 'BASIC';
        this.strategyInstances = {};
        this.strategyPerformance = {};
        this.strategyHistory = [];
        this.logger = console;
    }

    findBasicArbitrage(prices, pair) {
        // Aqu√≠ va tu l√≥gica de arbitraje b√°sico
        // Por ahora devolvemos un array vac√≠o para evitar errores
        return [];
    }

    findTriangularArbitrage(prices, pair) {
        // Aqu√≠ va tu l√≥gica de arbitraje triangular
        return [];
    }

    findStatisticalArbitrage(prices, pair) {
        // Aqu√≠ va tu l√≥gica de arbitraje estad√≠stico
        return [];
    }

    // ... (el resto de los m√©todos de StrategyManager quedan igual, como en tu dump)
}

/**
 * Clase Strategy
 * Representa una estrategia individual
 */
class Strategy {
    constructor(name, config) {
        this.name = name;
        this.config = config;
        this.isActive = false;
        this.lastExecution = null;
    }
    
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    
    execute(marketData) {
        this.lastExecution = new Date();
        // Implementaci√≥n espec√≠fica de cada estrategia
        return [];
    }
}

module.exports = StrategyManager;

----------------------------------------------------------------------------------------------------------

CSS

/* Aplica al contenedor principal del dashboard */
.dashboard-main, .main-content, .dashboard-container {
  margin-left: auto;
  margin-right: auto;
  /* Elige un ancho m√°ximo adecuado para tu dise√±o */
  max-width: 1100px;
  min-width: 900px;
  width: 100%;
  display: block;
}

---------------------------------------------------------------------------------------------------------------

.dashboard-container {
  display: flex;
  min-height: 100vh;
  background: linear-gradient(160deg, #6a11cb 0%, #2575fc 100%);
}

.sidebar {
  width: 220px;
  background: #222;
  color: #fff;
  padding: 30px 10px;
  min-height: 100vh;
}
.sidebar h2 {
  font-size: 1.2em;
  margin-bottom: 2em;
}
.sidebar ul {
  list-style: none;
  padding: 0;
}
.sidebar li {
  margin: 18px 0;
}
.sidebar a {
  color: #fff;
  text-decoration: none;
  font-weight: bold;
}

.dashboard-main {
  flex: 1;
  padding: 32px;
  display: flex;
  flex-direction: column;
}
.dashboard-row {
  display: flex;
  flex-wrap: wrap;
  gap: 22px;
  margin-bottom: 28px;
}
.panel {
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 4px 16px rgba(100,100,100,0.10);
  padding: 22px;
  flex: 1;
  min-width: 320px;
  max-width: 420px;
}
.panel h3 {
  font-size: 1.15em;
  margin-bottom: 12px;
}
.panel ul {
  margin: 0;
  padding-left: 18px;
}
button {
  margin-bottom: 10px;
  background: #2575fc;
  color: #fff;
  padding: 8px 18px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
button:disabled {
  background: #aaa;
}
input, select {
  margin: 4px 0 10px 0;
  padding: 6px 10px;
  border-radius: 4px;
  border: 1px solid #ccc;
}
.warning-cell {
  background: #fff3cd;
  color: #856404;
  font-weight: bold;
}

.success-cell {
  background: #d4edda;
  color: #155724;
}

.dashboard-table tr:hover {
  background: #e3f2fd;
  cursor: pointer;
}

.inline-edit {
  border: 1px solid #007bff;
  background: #f0f8ff;
  border-radius: 4px;
  padding: 2px 6px;
}
.warning-cell {
  background: #fff3cd !important;
  color: #856404 !important;
  font-weight: bold;
}
.warning-row {
  background: #fffbe5 !important;
}
.inline-edit {
  border: 1px solid #007bff;
  background: #f0f8ff;
  border-radius: 4px;
  padding: 2px 6px;
}


------------------------------------------------------------------------------------------------------------

DATA

[
  {
    "pair": "LTC/USDT",
    "base": "LTC",
    "quote": "USDT",
    "binance": {
      "address": "LiCH4dMWM6YRHFWYC78hppAk1SwUFkDAK4",
      "network": "Litecoin",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.002,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "LLCxH3L5fn9ejTPVk3nWTJcqvvTWsu2LbJ",
      "network": "Litecoin",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.001,
      "deposit_min": 0.00000001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 50,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BNB/USDT",
    "base": "BNB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.00001,
      "withdrawal_min": 0.0005,
      "deposit_min": 0.000003
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.0002,
      "withdrawal_min": 0.0002,
      "deposit_min": 0.0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 30,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XRP/USDT",
    "base": "XRP",
    "quote": "USDT",
    "binance": {
      "address": "rNxp4h8apvRis6mJf9Sh8C6iRxfrDWN7AV",
      "network": "XRP",
      "memo": "466152795",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "rJn2zAPdFA193sixJwuFixRkYDUtx3apQh",
      "network": "XRP",
      "memo": "501350199",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 1.2,
      "deposit_min": 0.01
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 40,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ALGO/USDT",
    "base": "ALGO",
    "quote": "USDT",
    "binance": {
      "address": "L43SHHRVHAIYHGFGXFBKM7IMZNYT7WSLSMXPHGNH4D5NPYOBIJSK35X5OE",
      "network": "ALGO",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 10,
      "deposit_min": 0.007
    },
    "bybit": {
      "address": "U5EPBBGTH4ZHEJMSYWRRBEOTOORYTSTSTYZITGDYM2KUQPDXWTHFDJPFVY",
      "network": "ALGO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 10,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ANIME/USDT",
    "base": "ANIME",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 7.74,
      "withdrawal_min": 16,
      "deposit_min": 0.00000001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "ARBI",
      "withdrawal_fee": 16,
      "withdrawal_min": 30,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "APT/USDT",
    "base": "APT",
    "quote": "USDT",
    "binance": {
      "address": "0x0b69478291cb55e808a716a046cc0d1ab2981e85778957da3fd519c6061ccb9e",
      "network": "APT",
      "withdrawal_fee": 0.016,
      "withdrawal_min": 0.06,
      "deposit_min": 0.00015
    },
    "bybit": {
      "address": "0x9f5ade930d03eb3fd1f0906f4e7edaddc458ac71260bf985bb61cfb61ac09191",
      "network": "APTOS",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ARB/USDT",
    "base": "ARB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 0.56,
      "withdrawal_min": 1.12,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.4,
      "withdrawal_min": 0.4,
      "deposit_min": 0.00000001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ATOM/USDT",
    "base": "ATOM",
    "quote": "USDT",
    "binance": {
      "address": "cosmos1j8pp7zvcu9z8vd882m284j29fn2dszh05cqvf9",
      "network": "ATOM",
      "memo": "100738176",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.04,
      "deposit_min": 0.00016
    },
    "bybit": {
      "address": "cosmos1c8dskmuz2wj29tg3rygt8mzg92f09gwcqqyexa",
      "network": "ATOM",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.015,
      "deposit_min": 0.0001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "AVAX/USDT",
    "base": "AVAX",
    "quote": "USDT",
    "binance": {
      "address": "X-avax1j2suzh09083n9cyd80dk3lsr0c3e8ry3skk27q",
      "network": "AVAX",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 0.1,
      "deposit_min": 0.00005
    },
    "bybit": {
      "address": "X-avax1unlvn8ef6lpjsac0t37t9za6astc8a55pugnm2",
      "network": "AVAX",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 0.008,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "AXL/USDT",
    "base": "AXL",
    "quote": "USDT",
    "binance": {
      "address": "axelar17ewha7y7fr0xsej6xfep88rq30rse9hgynll78",
      "network": "AXL",
      "memo": "101408734",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 1,
      "deposit_min": 0.0015
    },
    "bybit": {
      "address": "axelar1yzsury9fldydgk425gmphy2zyehh3emc43ds6x",
      "network": "AXL",
      "memo": "10048670",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BB/USDT",
    "base": "BB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BounceBit",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 1,
      "deposit_min": 0.06
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BounceBit",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BEL/USDT",
    "base": "BEL",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.051,
      "withdrawal_min": 0.1,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.12,
      "withdrawal_min": 0.12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BERA/USDT",
    "base": "BERA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BERA",
      "withdrawal_fee": 0.001,
      "withdrawal_min": 0.1,
      "deposit_min": 0.00000002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BERA",
      "withdrawal_fee": 0.000001,
      "withdrawal_min": 0.00001,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BOME/USDT",
    "base": "BOME",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 380,
      "withdrawal_min": 760,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 400,
      "withdrawal_min": 200,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BONK/USDT",
    "base": "BONK",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 41657,
      "withdrawal_min": 83314,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 40000,
      "withdrawal_min": 50000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "C98/USDT",
    "base": "C98",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.26,
      "withdrawal_min": 0.52,
      "deposit_min": 0.007
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CAKE/USDT",
    "base": "CAKE",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.0057,
      "withdrawal_min": 0.011,
      "deposit_min": 0.0006
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.023,
      "withdrawal_min": 0.023,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CATI/USDT",
    "base": "CATI",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 1.08,
      "withdrawal_min": 2.16,
      "deposit_min": 0.00000002
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
    },

  {
    "pair": "CELO/USDT",
    "base": "CELO",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "CELO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.1,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "CELO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CGPT/USDT",
    "base": "CGPT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 10,
      "withdrawal_min": 20,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 12,
      "withdrawal_min": 12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CHZ/USDT",
    "base": "CHZ",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Chiliz Chain",
      "withdrawal_fee": 20,
      "withdrawal_min": 40,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Chiliz Chain",
      "withdrawal_fee": 10,
      "withdrawal_min": 10,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CYBER/USDT",
    "base": "CYBER",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.4,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DOGS/USDT",
    "base": "DOGS",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DOT/USDT",
    "base": "DOT",
    "quote": "USDT",
    "binance": {
      "address": "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm",
      "network": "DOT",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 1.5,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm",
      "network": "DOT",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 40,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DYDX/USDT",
    "base": "DYDX",
    "quote": "USDT",
    "binance": {
      "address": "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq",
      "network": "DYDX",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq",
      "network": "DYDX",
      "withdrawal_fee": 0.09,
      "withdrawal_min": 0.09,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "EGLD/USDT",
    "base": "EGLD",
    "quote": "USDT",
    "binance": {
      "address": "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4",
      "network": "EGLD",
      "withdrawal_fee": 0.004,
      "withdrawal_min": 0.008,
      "deposit_min": 0.0005
    },
    "bybit": {
      "address": "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4",
      "network": "EGLD",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ENJ/USDT",
    "base": "ENJ",
    "quote": "USDT",
    "binance": {
      "address": "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i",
      "network": "Enjin",
      "withdrawal_fee": 15,
      "withdrawal_min": 30,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i",
      "network": "Enjin",
      "withdrawal_fee": 12,
      "withdrawal_min": 12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FIDA/USDT",
    "base": "FIDA",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FLOKI/USDT",
    "base": "FLOKI",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 210000,
      "withdrawal_min": 420000,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 200000,
      "withdrawal_min": 200000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FLOW/USDT",
    "base": "FLOW",
    "quote": "USDT",
    "binance": {
      "address": "0xdbb61e402a382eb3",
      "network": "FLOW",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.05,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0xdbb61e402a382eb3",
      "network": "FLOW",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.02,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "GMT/USDT",
    "base": "GMT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 1.2,
      "withdrawal_min": 1.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "GMX/USDT",
    "base": "GMX",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "AVAXC",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "AVAXC",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HAEDAL/USDT",
    "base": "HAEDAL",
    "quote": "USDT",
    "binance": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HBAR/USDT",
    "base": "HBAR",
    "quote": "USDT",
    "binance": {
      "address": "0.0.615422",
      "network": "HBAR",
      "memo": "10067078",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0.0.615422",
      "network": "HBAR",
      "memo": "10067078",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HMSTR/USDT",
    "base": "HMSTR",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "HOME/USDT",
    "base": "HOME",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.13,
      "withdrawal_min": 0.13,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.12,
      "withdrawal_min": 0.12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HYPER/USDT",
    "base": "HYPER",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 3,
      "withdrawal_min": 3,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 3,
      "withdrawal_min": 3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ICP/USDT",
    "base": "ICP",
    "quote": "USDT",
    "binance": {
      "address": "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a",
      "network": "ICP",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.0002,
      "deposit_min": 0.00002
    },
    "bybit": {
      "address": "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a",
      "network": "ICP",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.0001,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ICX/USDT",
    "base": "ICX",
    "quote": "USDT",
    "binance": {
      "address": "hx8c278a658331a569b640e925ac55a70a8e5534b6",
      "network": "ICX",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "hx8c278a658331a569b640e925ac55a70a8e5534b6",
      "network": "ICX",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.02,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "INJ/USDT",
    "base": "INJ",
    "quote": "USDT",
    "binance": {
      "address": "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n",
      "network": "INJ",
      "memo": "10014232",
      "withdrawal_fee": 0.002,
      "withdrawal_min": 0.005,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n",
      "network": "INJ",
      "memo": "10014232",
      "withdrawal_fee": 0.002,
      "withdrawal_min": 0.002,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "IO/USDT",
    "base": "IO",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "JUP/USDT",
    "base": "JUP",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KAIA/USDT",
    "base": "KAIA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "KAIA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "KAIA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KMNO/USDT",
    "base": "KMNO",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KSM/USDT",
    "base": "KSM",
    "quote": "USDT",
    "binance": {
      "address": "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV",
      "network": "KSM",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV",
      "network": "KSM",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "LUNA/USDT",
    "base": "LUNA",
    "quote": "USDT",
    "binance": {
      "address": "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s",
      "network": "Terra",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s",
      "network": "Terra",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MAGIC/USDT",
    "base": "MAGIC",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 0.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MANTA/USDT",
    "base": "MANTA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Manta Pacific Mainnet",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Manta Pacific Mainnet",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MBOX/USDT",
    "base": "MBOX",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 0.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MINA/USDT",
    "base": "MINA",
    "quote": "USDT",
    "binance": {
      "address": "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW",
      "network": "MINA",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.04,
      "deposit_min": 0.00005
    },
    "bybit": {
      "address": "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW",
      "network": "MINA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "NEAR/USDT",
    "base": "NEAR",
    "quote": "USDT",
    "binance": {
      "address": "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef",
      "network": "NEAR",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef",
      "network": "NEAR",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "NOT/USDT",
    "base": "NOT",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ONE/USDT",
    "base": "ONE",
    "quote": "USDT",
    "binance": {
      "address": "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3",
      "network": "ONE",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3",
      "network": "ONE",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "OP/USDT",
    "base": "OP",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "PSG/USDT",
    "base": "PSG",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 0.2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 0.05,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "PYTH/USDT",
    "base": "PYTH",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "RDNT/USDT",
    "base": "RDNT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ROSE/USDT",
    "base": "ROSE",
    "quote": "USDT",
    "binance": {
      "address": "rose1u9v2v6w437w7d2na4w4qm6t9w7yzn0hy2l8q4x",
      "network": "Oasis",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "rose1u9v2v6w437w7d2na4w4qm6t9w7yzn0hy2l8q4x",
      "network": "Oasis",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SCRT/USDT",
    "base": "SCRT",
    "quote": "USDT",
    "binance": {
      "address": "secret1g4d9f6k4z0n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Secret",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "secret1g4d9f6k4z0n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Secret",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SEI/USDT",
    "base": "SEI",
    "quote": "USDT",
    "binance": {
      "address": "sei1p6k4q8c6g36w7z0n9gx7t4z3u7e7m3a4c8l4yc8",
      "network": "SEI",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "sei1p6k4q8c6g36w7z0n9gx7t4z3u7e7m3a4c8l4yc8",
      "network": "SEI",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SHIB/USDT",
    "base": "SHIB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 2000000,
      "withdrawal_min": 4000000,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 2000000,
      "withdrawal_min": 2000000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SIGN/USDT",
    "base": "SIGN",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "STX/USDT",
    "base": "STX",
    "quote": "USDT",
    "binance": {
      "address": "SP3K8Z0E6H43N2VZ2YB6A7A5JY8X3N3N8M9TD8K4F",
      "network": "Stacks",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "SP3K8Z0E6H43N2VZ2YB6A7A5JY8X3N3N8M9TD8K4F",
      "network": "Stacks",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SUI/USDT",
    "base": "SUI",
    "quote": "USDT",
    "binance": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TIA/USDT",
    "base": "TIA",
    "quote": "USDT",
    "binance": {
      "address": "celestia1h4q4j8j3y6n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Celestia",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "celestia1h4q4j8j3y6n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Celestia",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TNSR/USDT",
    "base": "TNSR",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TON/USDT",
    "base": "TON",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TRUMP/USDT",
    "base": "TRUMP",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 1.5,
      "withdrawal_min": 1.5,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 1.5,
      "withdrawal_min": 1.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TRX/USDT",
    "base": "TRX",
    "quote": "USDT",
    "binance": {
      "address": "TQ7DuEjJXQ6gHzXfWnA3SA8k6nJk8jWZKQ",
      "network": "TRON",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "TQ7DuEjJXQ6gHzXfWnA3SA8k6nJk8jWZKQ",
      "network": "TRON",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "WAXP/USDT",
    "base": "WAXP",
    "quote": "USDT",
    "binance": {
      "address": "wax1k2v4m4rzk5ljh37u2f454p4w3ffj4qk8p3rkxf",
      "network": "WAX",
      "withdrawal_fee": 2,
      "withdrawal_min": 4,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "wax1k2v4m4rzk5ljh37u2f454p4w3ffj4qk8p3rkxf",
      "network": "WAX",
      "withdrawal_fee": 2,
      "withdrawal_min": 2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WCT/USDT",
    "base": "WCT",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WIF/USDT",
    "base": "WIF",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 55,
      "withdrawal_min": 110,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 50,
      "withdrawal_min": 50,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WLD/USDT",
    "base": "WLD",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Ethereum",
      "withdrawal_fee": 0.23,
      "withdrawal_min": 0.46,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Ethereum",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XAI/USDT",
    "base": "XAI",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.7,
      "withdrawal_min": 1.4,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XLM/USDT",
    "base": "XLM",
    "quote": "USDT",
    "binance": {
      "address": "GC3ZP2U7WJ2JK3MNHVZ4V8UIG4N2PJS4C42R7V7C6H5D2A5WA7HD6WJR",
      "network": "Stellar",
      "memo": "3574998388",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "GC3ZP2U7WJ2JK3MNHVZ4V8UIG4N2PJS4C42R7V7C6H5D2A5WA7HD6WJR",
      "network": "Stellar",
      "memo": "3574998388",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ZIL/USDT",
    "base": "ZIL",
    "quote": "USDT",
    "binance": {
      "address": "zil1hkycgdsq0zj0gkc7hlzm7s9y2q2n6g4z9v6xdh",
      "network": "Zilliqa",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "zil1hkycgdsq0zj0gkc7hlzm7s9y2q2n6g4z9v6xdh",
      "network": "Zilliqa",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ZRO/USDT",
    "base": "ZRO",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 0.04,
      "withdrawal_min": 0.08,
      "deposit_min": 0.00026
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "AVAXC",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  }
]


-------------------------------------------------------------------------------------------------------------

EXCHANGES

[
  {
    "pair": "LTC/USDT",
    "base": "LTC",
    "quote": "USDT",
    "binance": {
      "address": "LiCH4dMWM6YRHFWYC78hppAk1SwUFkDAK4",
      "network": "Litecoin",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.002,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "LLCxH3L5fn9ejTPVk3nWTJcqvvTWsu2LbJ",
      "network": "Litecoin",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.001,
      "deposit_min": 0.00000001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 50,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BNB/USDT",
    "base": "BNB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.00001,
      "withdrawal_min": 0.0005,
      "deposit_min": 0.000003
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.0002,
      "withdrawal_min": 0.0002,
      "deposit_min": 0.0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 30,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XRP/USDT",
    "base": "XRP",
    "quote": "USDT",
    "binance": {
      "address": "rNxp4h8apvRis6mJf9Sh8C6iRxfrDWN7AV",
      "network": "XRP",
      "memo": "466152795",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "rJn2zAPdFA193sixJwuFixRkYDUtx3apQh",
      "network": "XRP",
      "memo": "501350199",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 1.2,
      "deposit_min": 0.01
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 40,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ALGO/USDT",
    "base": "ALGO",
    "quote": "USDT",
    "binance": {
      "address": "L43SHHRVHAIYHGFGXFBKM7IMZNYT7WSLSMXPHGNH4D5NPYOBIJSK35X5OE",
      "network": "ALGO",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 10,
      "deposit_min": 0.007
    },
    "bybit": {
      "address": "U5EPBBGTH4ZHEJMSYWRRBEOTOORYTSTSTYZITGDYM2KUQPDXWTHFDJPFVY",
      "network": "ALGO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 10,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ANIME/USDT",
    "base": "ANIME",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 7.74,
      "withdrawal_min": 16,
      "deposit_min": 0.00000001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "ARBI",
      "withdrawal_fee": 16,
      "withdrawal_min": 30,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "APT/USDT",
    "base": "APT",
    "quote": "USDT",
    "binance": {
      "address": "0x0b69478291cb55e808a716a046cc0d1ab2981e85778957da3fd519c6061ccb9e",
      "network": "APT",
      "withdrawal_fee": 0.016,
      "withdrawal_min": 0.06,
      "deposit_min": 0.00015
    },
    "bybit": {
      "address": "0x9f5ade930d03eb3fd1f0906f4e7edaddc458ac71260bf985bb61cfb61ac09191",
      "network": "APTOS",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 1
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ARB/USDT",
    "base": "ARB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 0.56,
      "withdrawal_min": 1.12,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.4,
      "withdrawal_min": 0.4,
      "deposit_min": 0.00000001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ATOM/USDT",
    "base": "ATOM",
    "quote": "USDT",
    "binance": {
      "address": "cosmos1j8pp7zvcu9z8vd882m284j29fn2dszh05cqvf9",
      "network": "ATOM",
      "memo": "100738176",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.04,
      "deposit_min": 0.00016
    },
    "bybit": {
      "address": "cosmos1c8dskmuz2wj29tg3rygt8mzg92f09gwcqqyexa",
      "network": "ATOM",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.015,
      "deposit_min": 0.0001
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "AVAX/USDT",
    "base": "AVAX",
    "quote": "USDT",
    "binance": {
      "address": "X-avax1j2suzh09083n9cyd80dk3lsr0c3e8ry3skk27q",
      "network": "AVAX",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 0.1,
      "deposit_min": 0.00005
    },
    "bybit": {
      "address": "X-avax1unlvn8ef6lpjsac0t37t9za6astc8a55pugnm2",
      "network": "AVAX",
      "withdrawal_fee": 0.008,
      "withdrawal_min": 0.008,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "AXL/USDT",
    "base": "AXL",
    "quote": "USDT",
    "binance": {
      "address": "axelar17ewha7y7fr0xsej6xfep88rq30rse9hgynll78",
      "network": "AXL",
      "memo": "101408734",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 1,
      "deposit_min": 0.0015
    },
    "bybit": {
      "address": "axelar1yzsury9fldydgk425gmphy2zyehh3emc43ds6x",
      "network": "AXL",
      "memo": "10048670",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BB/USDT",
    "base": "BB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BounceBit",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 1,
      "deposit_min": 0.06
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BounceBit",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BEL/USDT",
    "base": "BEL",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.051,
      "withdrawal_min": 0.1,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.12,
      "withdrawal_min": 0.12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BERA/USDT",
    "base": "BERA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BERA",
      "withdrawal_fee": 0.001,
      "withdrawal_min": 0.1,
      "deposit_min": 0.00000002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BERA",
      "withdrawal_fee": 0.000001,
      "withdrawal_min": 0.00001,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BOME/USDT",
    "base": "BOME",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 380,
      "withdrawal_min": 760,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 400,
      "withdrawal_min": 200,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "BONK/USDT",
    "base": "BONK",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 41657,
      "withdrawal_min": 83314,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 40000,
      "withdrawal_min": 50000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "C98/USDT",
    "base": "C98",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.26,
      "withdrawal_min": 0.52,
      "deposit_min": 0.007
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CAKE/USDT",
    "base": "CAKE",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.0057,
      "withdrawal_min": 0.011,
      "deposit_min": 0.0006
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.023,
      "withdrawal_min": 0.023,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CATI/USDT",
    "base": "CATI",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 1.08,
      "withdrawal_min": 2.16,
      "deposit_min": 0.00000002
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
    },

  {
    "pair": "CELO/USDT",
    "base": "CELO",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "CELO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.1,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "CELO",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CGPT/USDT",
    "base": "CGPT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 10,
      "withdrawal_min": 20,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 12,
      "withdrawal_min": 12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CHZ/USDT",
    "base": "CHZ",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Chiliz Chain",
      "withdrawal_fee": 20,
      "withdrawal_min": 40,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Chiliz Chain",
      "withdrawal_fee": 10,
      "withdrawal_min": 10,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "CYBER/USDT",
    "base": "CYBER",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.4,
      "deposit_min": 0.002
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DOGS/USDT",
    "base": "DOGS",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DOT/USDT",
    "base": "DOT",
    "quote": "USDT",
    "binance": {
      "address": "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm",
      "network": "DOT",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 1.5,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "13zhBAjXq6XWusrrDw8LpYBNaeG4gAXjFtSm8Dw81LV4wAqm",
      "network": "DOT",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 40,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "DYDX/USDT",
    "base": "DYDX",
    "quote": "USDT",
    "binance": {
      "address": "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq",
      "network": "DYDX",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "dydx1plrw2mur00y6mh94vc4u5y9wz56ktdnt6ep4gq",
      "network": "DYDX",
      "withdrawal_fee": 0.09,
      "withdrawal_min": 0.09,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "EGLD/USDT",
    "base": "EGLD",
    "quote": "USDT",
    "binance": {
      "address": "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4",
      "network": "EGLD",
      "withdrawal_fee": 0.004,
      "withdrawal_min": 0.008,
      "deposit_min": 0.0005
    },
    "bybit": {
      "address": "erd1ld8ylfwe0dj72mkeq73fz9x36tn0p943cmfv6fwzft9jt0rjf0xs5xdfu4",
      "network": "EGLD",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ENJ/USDT",
    "base": "ENJ",
    "quote": "USDT",
    "binance": {
      "address": "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i",
      "network": "Enjin",
      "withdrawal_fee": 15,
      "withdrawal_min": 30,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "enCbjnvB5Zpu26ciGoMPaNVSWXWKqtbGptKpDj1UUsZqF2o6i",
      "network": "Enjin",
      "withdrawal_fee": 12,
      "withdrawal_min": 12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FIDA/USDT",
    "base": "FIDA",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FLOKI/USDT",
    "base": "FLOKI",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 210000,
      "withdrawal_min": 420000,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 200000,
      "withdrawal_min": 200000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "FLOW/USDT",
    "base": "FLOW",
    "quote": "USDT",
    "binance": {
      "address": "0xdbb61e402a382eb3",
      "network": "FLOW",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.05,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0xdbb61e402a382eb3",
      "network": "FLOW",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.02,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "GMT/USDT",
    "base": "GMT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.02
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 1.2,
      "withdrawal_min": 1.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "GMX/USDT",
    "base": "GMX",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "AVAXC",
      "withdrawal_fee": 0.005,
      "withdrawal_min": 0.005,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "AVAXC",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HAEDAL/USDT",
    "base": "HAEDAL",
    "quote": "USDT",
    "binance": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HBAR/USDT",
    "base": "HBAR",
    "quote": "USDT",
    "binance": {
      "address": "0.0.615422",
      "network": "HBAR",
      "memo": "10067078",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0.0.615422",
      "network": "HBAR",
      "memo": "10067078",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HMSTR/USDT",
    "base": "HMSTR",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "HOME/USDT",
    "base": "HOME",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.13,
      "withdrawal_min": 0.13,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.12,
      "withdrawal_min": 0.12,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "HYPER/USDT",
    "base": "HYPER",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 3,
      "withdrawal_min": 3,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 3,
      "withdrawal_min": 3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ICP/USDT",
    "base": "ICP",
    "quote": "USDT",
    "binance": {
      "address": "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a",
      "network": "ICP",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.0002,
      "deposit_min": 0.00002
    },
    "bybit": {
      "address": "dc8d5fcdfee8c6afe59bd85155fa18b0cbc1fee57e6b7f66ef10220d25d4bc1a",
      "network": "ICP",
      "withdrawal_fee": 0.0001,
      "withdrawal_min": 0.0001,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ICX/USDT",
    "base": "ICX",
    "quote": "USDT",
    "binance": {
      "address": "hx8c278a658331a569b640e925ac55a70a8e5534b6",
      "network": "ICX",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "hx8c278a658331a569b640e925ac55a70a8e5534b6",
      "network": "ICX",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.02,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "INJ/USDT",
    "base": "INJ",
    "quote": "USDT",
    "binance": {
      "address": "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n",
      "network": "INJ",
      "memo": "10014232",
      "withdrawal_fee": 0.002,
      "withdrawal_min": 0.005,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "inj1vmqxkjmruu2q06qlfg7sjqe8chhsejy7mh6j6n",
      "network": "INJ",
      "memo": "10014232",
      "withdrawal_fee": 0.002,
      "withdrawal_min": 0.002,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "IO/USDT",
    "base": "IO",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "JUP/USDT",
    "base": "JUP",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KAIA/USDT",
    "base": "KAIA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "KAIA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "KAIA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KMNO/USDT",
    "base": "KMNO",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "KSM/USDT",
    "base": "KSM",
    "quote": "USDT",
    "binance": {
      "address": "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV",
      "network": "KSM",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "GJR9MqPoddfpZxotFsX8v77qubfeW5jpCD7eYT8CpZKiaMV",
      "network": "KSM",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "LUNA/USDT",
    "base": "LUNA",
    "quote": "USDT",
    "binance": {
      "address": "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s",
      "network": "Terra",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "terra188gwmnvl8zv4n5639hghms4l5s00s6z7e48t6s",
      "network": "Terra",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MAGIC/USDT",
    "base": "MAGIC",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 0.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MANTA/USDT",
    "base": "MANTA",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Manta Pacific Mainnet",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Manta Pacific Mainnet",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MBOX/USDT",
    "base": "MBOX",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.5,
      "withdrawal_min": 0.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "MINA/USDT",
    "base": "MINA",
    "quote": "USDT",
    "binance": {
      "address": "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW",
      "network": "MINA",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.04,
      "deposit_min": 0.00005
    },
    "bybit": {
      "address": "B62qnEPLBPPnRi71NyExqDM9Et9rrvK4bB2GapNhhgM9DvgGipKLNEW",
      "network": "MINA",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "NEAR/USDT",
    "base": "NEAR",
    "quote": "USDT",
    "binance": {
      "address": "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef",
      "network": "NEAR",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "7e156143ead7675a8e85234ca5f3d3358b7edd2ae0948bc41106aab78af508ef",
      "network": "NEAR",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "NOT/USDT",
    "base": "NOT",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ONE/USDT",
    "base": "ONE",
    "quote": "USDT",
    "binance": {
      "address": "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3",
      "network": "ONE",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "one1xqeje970edyrw5j6t2vykcs45cse663ml3pwe3",
      "network": "ONE",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "OP/USDT",
    "base": "OP",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "OP Mainnet",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "PSG/USDT",
    "base": "PSG",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 0.2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 0.05,
      "withdrawal_min": 0.05,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "PYTH/USDT",
    "base": "PYTH",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "RDNT/USDT",
    "base": "RDNT",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ROSE/USDT",
    "base": "ROSE",
    "quote": "USDT",
    "binance": {
      "address": "rose1u9v2v6w437w7d2na4w4qm6t9w7yzn0hy2l8q4x",
      "network": "Oasis",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "rose1u9v2v6w437w7d2na4w4qm6t9w7yzn0hy2l8q4x",
      "network": "Oasis",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SCRT/USDT",
    "base": "SCRT",
    "quote": "USDT",
    "binance": {
      "address": "secret1g4d9f6k4z0n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Secret",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "secret1g4d9f6k4z0n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Secret",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SEI/USDT",
    "base": "SEI",
    "quote": "USDT",
    "binance": {
      "address": "sei1p6k4q8c6g36w7z0n9gx7t4z3u7e7m3a4c8l4yc8",
      "network": "SEI",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "sei1p6k4q8c6g36w7z0n9gx7t4z3u7e7m3a4c8l4yc8",
      "network": "SEI",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SHIB/USDT",
    "base": "SHIB",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 2000000,
      "withdrawal_min": 4000000,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 2000000,
      "withdrawal_min": 2000000,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SIGN/USDT",
    "base": "SIGN",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "STX/USDT",
    "base": "STX",
    "quote": "USDT",
    "binance": {
      "address": "SP3K8Z0E6H43N2VZ2YB6A7A5JY8X3N3N8M9TD8K4F",
      "network": "Stacks",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "SP3K8Z0E6H43N2VZ2YB6A7A5JY8X3N3N8M9TD8K4F",
      "network": "Stacks",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "SUI/USDT",
    "base": "SUI",
    "quote": "USDT",
    "binance": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x17cbbf04d589fda59d51ffde92501894fa643de3be3e447f7cabeca7aa90082c",
      "network": "SUI",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TIA/USDT",
    "base": "TIA",
    "quote": "USDT",
    "binance": {
      "address": "celestia1h4q4j8j3y6n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Celestia",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.02,
      "deposit_min": 0.001
    },
    "bybit": {
      "address": "celestia1h4q4j8j3y6n9gx7t4z3u7e7m3a4c8l4yc8c9vj",
      "network": "Celestia",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TNSR/USDT",
    "base": "TNSR",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TON/USDT",
    "base": "TON",
    "quote": "USDT",
    "binance": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "bybit": {
      "address": "UQCT1S9xDKxJV7zpOYNpnof-_xym-dG7W3TYxeGLxLKSSSvB",
      "network": "TON",
      "withdrawal_fee": 0.3,
      "withdrawal_min": 0.3,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TRUMP/USDT",
    "base": "TRUMP",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "BSC",
      "withdrawal_fee": 1.5,
      "withdrawal_min": 1.5,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "BSC",
      "withdrawal_fee": 1.5,
      "withdrawal_min": 1.5,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "TRX/USDT",
    "base": "TRX",
    "quote": "USDT",
    "binance": {
      "address": "TQ7DuEjJXQ6gHzXfWnA3SA8k6nJk8jWZKQ",
      "network": "TRON",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "TQ7DuEjJXQ6gHzXfWnA3SA8k6nJk8jWZKQ",
      "network": "TRON",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },

  {
    "pair": "WAXP/USDT",
    "base": "WAXP",
    "quote": "USDT",
    "binance": {
      "address": "wax1k2v4m4rzk5ljh37u2f454p4w3ffj4qk8p3rkxf",
      "network": "WAX",
      "withdrawal_fee": 2,
      "withdrawal_min": 4,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "wax1k2v4m4rzk5ljh37u2f454p4w3ffj4qk8p3rkxf",
      "network": "WAX",
      "withdrawal_fee": 2,
      "withdrawal_min": 2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WCT/USDT",
    "base": "WCT",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.2,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WIF/USDT",
    "base": "WIF",
    "quote": "USDT",
    "binance": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 55,
      "withdrawal_min": 110,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "3j8DNJSqBz5wzPTmhhLkfCNRvSJ5bqdRC8zGrSHLXMX8",
      "network": "Solana",
      "withdrawal_fee": 50,
      "withdrawal_min": 50,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "WLD/USDT",
    "base": "WLD",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Ethereum",
      "withdrawal_fee": 0.23,
      "withdrawal_min": 0.46,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Ethereum",
      "withdrawal_fee": 0.2,
      "withdrawal_min": 0.2,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XAI/USDT",
    "base": "XAI",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "Arbitrum One",
      "withdrawal_fee": 0.7,
      "withdrawal_min": 1.4,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "Arbitrum One",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "XLM/USDT",
    "base": "XLM",
    "quote": "USDT",
    "binance": {
      "address": "GC3ZP2U7WJ2JK3MNHVZ4V8UIG4N2PJS4C42R7V7C6H5D2A5WA7HD6WJR",
      "network": "Stellar",
      "memo": "3574998388",
      "withdrawal_fee": 0.02,
      "withdrawal_min": 0.1,
      "deposit_min": 0.0001
    },
    "bybit": {
      "address": "GC3ZP2U7WJ2JK3MNHVZ4V8UIG4N2PJS4C42R7V7C6H5D2A5WA7HD6WJR",
      "network": "Stellar",
      "memo": "3574998388",
      "withdrawal_fee": 0.01,
      "withdrawal_min": 0.01,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ZIL/USDT",
    "base": "ZIL",
    "quote": "USDT",
    "binance": {
      "address": "zil1hkycgdsq0zj0gkc7hlzm7s9y2q2n6g4z9v6xdh",
      "network": "Zilliqa",
      "withdrawal_fee": 1,
      "withdrawal_min": 2,
      "deposit_min": 0.01
    },
    "bybit": {
      "address": "zil1hkycgdsq0zj0gkc7hlzm7s9y2q2n6g4z9v6xdh",
      "network": "Zilliqa",
      "withdrawal_fee": 1,
      "withdrawal_min": 1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  },
  {
    "pair": "ZRO/USDT",
    "base": "ZRO",
    "quote": "USDT",
    "binance": {
      "address": "0xe5b10a8fa449155d5b4b657dab4e856815d52bd7",
      "network": "ARBITRUM",
      "withdrawal_fee": 0.04,
      "withdrawal_min": 0.08,
      "deposit_min": 0.00026
    },
    "bybit": {
      "address": "0x4231d188a91481a8c3d39d444b7451436babee94",
      "network": "AVAXC",
      "withdrawal_fee": 0.1,
      "withdrawal_min": 0.1,
      "deposit_min": 0
    },
    "trading_fee": 0.001,
    "min_trade": 10,
    "max_trade": 20,
    "min_spread": 0.002,
    "max_slippage": 0.001
  }
]


----------------------------------------------------------------------------------------------------------

// ========== M√ìDULO DE GESTI√ìN DE EXCHANGES ==========
const axios = require("axios")
const crypto = require("crypto")
const EventEmitter = require('events')
const config = require('../strategies/config');

class ExchangeManager extends EventEmitter {
  constructor(config) {
    super();
    this.config = config;
    this.exchanges = {
      BINANCE: {
        name: "Binance",
        baseURL: config.EXCHANGES.BINANCE.testnet || config.EXCHANGES.BINANCE.baseURL,
        apiKey: config.EXCHANGES.BINANCE.apiKey,
        apiSecret: config.EXCHANGES.BINANCE.apiSecret,
      },
      KUCOIN: {
        name: "KuCoin",
        baseURL: config.EXCHANGES.KUCOIN.testnet || config.EXCHANGES.KUCOIN.baseURL,
        apiKey: config.EXCHANGES.KUCOIN.apiKey,
        apiSecret: config.EXCHANGES.KUCOIN.apiSecret,
        passphrase: config.EXCHANGES.KUCOIN.passphrase,
      },
    }

    console.log(`üîÑ Exchange Manager inicializado: ${Object.keys(this.exchanges).join(", ")}`)
    console.log(`üß™ Modo testnet: ${config.TRADING_MODE === 'simulation' ? "Activado" : "Desactivado"}`)
  }

  // Obtener precios de todos los pares en todos los exchanges
  async getAllPrices() {
    const allPrices = {}

    for (const pair of config.TRADING_PAIRS) {
      allPrices[pair.symbol] = {}

      for (const exchangeName of Object.keys(this.exchanges)) {
        try {
          const price = await this.getPrice(exchangeName, pair.symbol)
          allPrices[pair.symbol][exchangeName] = price
        } catch (error) {
          console.error(`Error obteniendo precio de ${pair.symbol} en ${exchangeName}:`, error.message)
        }
      }
    }

    return allPrices
  }

  // Obtener precio de un par en un exchange espec√≠fico
  async getPrice(exchangeName, symbol) {
    if (exchangeName === "BINANCE") {
      return this.getBinancePrice(symbol)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinPrice(symbol)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener precio en Binance
  async getBinancePrice(symbol) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/ticker/price`, {
        params: { symbol: formattedSymbol },
      })

      return Number.parseFloat(response.data.price)
    } catch (error) {
      throw new Error(`Error en Binance: ${error.message}`)
    }
  }

  // Obtener precio en KuCoin
  async getKucoinPrice(symbol) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POL-USDT)
      const formattedSymbol = symbol.replace("/", "-")

      // Usar endpoint p√∫blico sin autenticaci√≥n para evitar problemas SSL
      const response = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1`, {
        params: { symbol: formattedSymbol },
        timeout: 10000,
        headers: {
          "User-Agent": "CEX-Arbitrage-Bot/1.0",
        },
      })

      // KuCoin devuelve precio en data.data.price
      return Number.parseFloat(response.data.data.price)
    } catch (error) {
      // Si falla KuCoin, usar precio simulado
      console.warn(`‚ö†Ô∏è Usando precio simulado para ${symbol} en KuCoin`)
      return this.getSimulatedPrice(symbol)
    }
  }

  // Calcular spread entre dos precios
  calculateSpread(price1, price2) {
    return Math.abs((price1 - price2) / Math.min(price1, price2)) * 100
  }

  // Obtener balances en un exchange
  async getBalances(exchangeName) {
    if (config.BOT.DRY_RUN) {
      // En modo simulaci√≥n, devolver balances iniciales
      return this.getSimulatedBalances(exchangeName)
    }

    if (exchangeName === "BINANCE") {
      return this.getBinanceBalances()
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinBalances()
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Balances simulados para modo DRY_RUN
  getSimulatedBalances(exchangeName) {
    const initialBalances = config.INITIAL_BALANCES[exchangeName]
    const balances = {}

    for (const [asset, amount] of Object.entries(initialBalances)) {
      balances[asset] = {
        free: amount,
        locked: 0,
        total: amount,
      }
    }

    return balances
  }

  // Obtener balances en Binance
  async getBinanceBalances() {
    try {
      const timestamp = Date.now()
      const queryString = `timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/account`, {
        params: {
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      const balances = {}
      response.data.balances.forEach((balance) => {
        const free = Number.parseFloat(balance.free)
        const locked = Number.parseFloat(balance.locked)
        const total = free + locked

        if (total > 0) {
          balances[balance.asset] = {
            free,
            locked,
            total,
          }
        }
      })

      return balances
    } catch (error) {
      throw new Error(`Error obteniendo balances de Binance: ${error.message}`)
    }
  }

  // Obtener balances en KuCoin
  async getKucoinBalances() {
    try {
      // Primero necesitamos obtener un token de KuCoin
      const timestamp = Date.now()
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "GET" + "/api/v1/accounts")
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}/api/v1/accounts`, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
        },
      })

      const balances = {}
      response.data.data.forEach((balance) => {
        const free = Number.parseFloat(balance.available)
        const locked = Number.parseFloat(balance.holds)
        const total = free + locked

        if (total > 0) {
          balances[balance.currency] = {
            free,
            locked,
            total,
          }
        }
      })

      return balances
    } catch (error) {
      throw new Error(`Error obteniendo balances de KuCoin: ${error.message}`)
    }
  }

  // Colocar orden en un exchange
  async placeOrder(exchangeName, symbol, side, amount) {
    if (config.BOT.DRY_RUN) {
      // En modo simulaci√≥n, simular la orden
      return this.simulateOrder(exchangeName, symbol, side, amount)
    }

    if (exchangeName === "BINANCE") {
      return this.placeBinanceOrder(symbol, side, amount)
    } else if (exchangeName === "KUCOIN") {
      return this.placeKucoinOrder(symbol, side, amount)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Simular orden para modo DRY_RUN
  async simulateOrder(exchangeName, symbol, side, amount) {
    try {
      const price = await this.getPrice(exchangeName, symbol)
      const executedQty = side === "buy" ? amount / price : amount
      const orderId = `sim-${Date.now()}-${Math.floor(Math.random() * 1000)}`

      console.log(
        `üß™ SIMULACI√ìN: Orden ${side} de ${amount} ${symbol} en ${exchangeName} a precio ${price} (ID: ${orderId})`,
      )

      return {
        orderId,
        status: "FILLED",
        executedQty,
        price,
      }
    } catch (error) {
      throw new Error(`Error simulando orden: ${error.message}`)
    }
  }

  // Colocar orden en Binance
  async placeBinanceOrder(symbol, side, amount) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const timestamp = Date.now()
      const params = {
        symbol: formattedSymbol,
        side: side.toUpperCase(),
        type: "MARKET",
        quantity: amount,
        timestamp,
      }

      const queryString = Object.entries(params)
        .map(([key, value]) => `${key}=${value}`)
        .join("&")

      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.post(`${this.exchanges.BINANCE.baseURL}/api/v3/order`, null, {
        params: {
          ...params,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        orderId: response.data.orderId,
        status: response.data.status,
        executedQty: Number.parseFloat(response.data.executedQty),
        price: Number.parseFloat(response.data.price),
      }
    } catch (error) {
      throw new Error(`Error colocando orden en Binance: ${error.message}`)
    }
  }

  // Colocar orden en KuCoin
  async placeKucoinOrder(symbol, side, amount) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POL-USDT)
      const formattedSymbol = symbol.replace("/", "-")

      const timestamp = Date.now()
      const data = {
        clientOid: `bot-${timestamp}`,
        side: side.toUpperCase(),
        symbol: formattedSymbol,
        type: "market",
        size: amount,
      }

      const dataString = JSON.stringify(data)
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "POST" + "/api/v1/orders" + dataString)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.post(`${this.exchanges.KUCOIN.baseURL}/api/v1/orders`, data, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
          "Content-Type": "application/json",
        },
      })

      // KuCoin devuelve solo el ID de la orden, necesitamos consultar el estado
      const orderId = response.data.data.orderId
      const orderDetails = await this.getKucoinOrderDetails(orderId)

      return {
        orderId,
        status: orderDetails.status,
        executedQty: Number.parseFloat(orderDetails.executedQty),
        price: Number.parseFloat(orderDetails.price),
      }
    } catch (error) {
      throw new Error(`Error colocando orden en KuCoin: ${error.message}`)
    }
  }

  // Obtener detalles de una orden en KuCoin
  async getKucoinOrderDetails(orderId) {
    try {
      const timestamp = Date.now()
      const endpoint = `/api/v1/orders/${orderId}`
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "GET" + endpoint)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}${endpoint}`, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
        },
      })

      const order = response.data.data
      return {
        status: order.isActive ? "ACTIVE" : "FILLED",
        executedQty: order.dealSize,
        price: order.dealFunds / order.dealSize, // Precio promedio
      }
    } catch (error) {
      throw new Error(`Error obteniendo detalles de orden en KuCoin: ${error.message}`)
    }
  }

  // Obtener estado de una orden
  async getOrderStatus(exchangeName, orderId, symbol) {
    if (config.BOT.DRY_RUN) {
      // En modo simulaci√≥n, devolver estado completado
      return {
        status: "FILLED",
        executedQty: 1,
        price: 1,
      }
    }

    if (exchangeName === "BINANCE") {
      return this.getBinanceOrderStatus(orderId, symbol)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinOrderDetails(orderId)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener estado de una orden en Binance
  async getBinanceOrderStatus(orderId, symbol) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const timestamp = Date.now()
      const queryString = `symbol=${formattedSymbol}&orderId=${orderId}&timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/order`, {
        params: {
          symbol: formattedSymbol,
          orderId,
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        status: response.data.status,
        executedQty: Number.parseFloat(response.data.executedQty),
        price: Number.parseFloat(response.data.price),
      }
    } catch (error) {
      throw new Error(`Error obteniendo estado de orden en Binance: ${error.message}`)
    }
  }

  // Obtener direcci√≥n de dep√≥sito
  async getDepositAddress(exchangeName, asset, network) {
    if (config.BOT.DRY_RUN) {
      // En modo simulaci√≥n, devolver direcci√≥n simulada
      return {
        address: `sim-${exchangeName.toLowerCase()}-${asset.toLowerCase()}-address`,
        tag: null,
      }
    }

    if (exchangeName === "BINANCE") {
      return this.getBinanceDepositAddress(asset, network)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinDepositAddress(asset, network)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener direcci√≥n de dep√≥sito en Binance
  async getBinanceDepositAddress(asset, network) {
    try {
      const timestamp = Date.now()
      const queryString = `coin=${asset}&network=${network}&timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/sapi/v1/capital/deposit/address`, {
        params: {
          coin: asset,
          network,
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        address: response.data.address,
        tag: response.data.tag,
      }
    } catch (error) {
      throw new Error(`Error obteniendo direcci√≥n de dep√≥sito en Binance: ${error.message}`)
    }
  }

  // Obtener direcci√≥n de dep√≥sito en KuCoin
  async getKucoinDepositAddress(asset, network) {
    try {
      const timestamp = Date.now()
      const endpoint = `/api/v1/deposit-addresses`
      const queryString = `currency=${asset}&network=${network}`
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "GET" + endpoint + "?" + queryString)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}${endpoint}`, {
        params: {
          currency: asset,
          network,
        },
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
        },
      })

      return {
        address: response.data.data.address,
        tag: response.data.data.memo,
      }
    } catch (error) {
      throw new Error(`Error obteniendo direcci√≥n de dep√≥sito en KuCoin: ${error.message}`)
    }
  }

  // Realizar retiro
  async withdraw(exchangeName, asset, amount, address, network) {
    if (config.BOT.DRY_RUN) {
      // En modo simulaci√≥n, simular retiro
      const withdrawId = `sim-withdraw-${Date.now()}`
      console.log(`üß™ SIMULACI√ìN: Retiro de ${amount} ${asset} desde ${exchangeName} a ${address} (ID: ${withdrawId})`)
      return { withdrawId }
    }

    if (exchangeName === "BINANCE") {
      return this.binanceWithdraw(asset, amount, address, network)
    } else if (exchangeName === "KUCOIN") {
      return this.kucoinWithdraw(asset, amount, address, network)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Realizar retiro en Binance
  async binanceWithdraw(asset, amount, address, network) {
    try {
      const timestamp = Date.now()
      const queryString = `coin=${asset}&address=${address}&amount=${amount}&network=${network}&timestamp=${timestamp}`
      const signature = crypto.createHmac("sha256", this.exchanges.BINANCE.apiSecret).update(queryString).digest("hex")

      const response = await axios.post(`${this.exchanges.BINANCE.baseURL}/sapi/v1/capital/withdraw/apply`, null, {
        params: {
          coin: asset,
          address,
          amount,
          network,
          timestamp,
          signature,
        },
        headers: {
          "X-MBX-APIKEY": this.exchanges.BINANCE.apiKey,
        },
      })

      return {
        withdrawId: response.data.id,
      }
    } catch (error) {
      throw new Error(`Error realizando retiro en Binance: ${error.message}`)
    }
  }

  // Realizar retiro en KuCoin
  async kucoinWithdraw(asset, amount, address, network) {
    try {
      const timestamp = Date.now()
      const data = {
        currency: asset,
        address,
        amount: amount.toString(),
        network,
      }

      const dataString = JSON.stringify(data)
      const signature = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(timestamp + "POST" + "/api/v1/withdrawals" + dataString)
        .digest("base64")

      const passphrase = crypto
        .createHmac("sha256", this.exchanges.KUCOIN.apiSecret)
        .update(this.exchanges.KUCOIN.passphrase)
        .digest("base64")

      const response = await axios.post(`${this.exchanges.KUCOIN.baseURL}/api/v1/withdrawals`, data, {
        headers: {
          "KC-API-KEY": this.exchanges.KUCOIN.apiKey,
          "KC-API-SIGN": signature,
          "KC-API-TIMESTAMP": timestamp,
          "KC-API-PASSPHRASE": passphrase,
          "KC-API-KEY-VERSION": "2",
          "Content-Type": "application/json",
        },
      })

      return {
        withdrawId: response.data.data.withdrawalId,
      }
    } catch (error) {
      throw new Error(`Error realizando retiro en KuCoin: ${error.message}`)
    }
  }

  // Obtener order book
  async getOrderBook(exchangeName, symbol) {
    if (exchangeName === "BINANCE") {
      return this.getBinanceOrderBook(symbol)
    } else if (exchangeName === "KUCOIN") {
      return this.getKucoinOrderBook(symbol)
    } else {
      throw new Error(`Exchange no soportado: ${exchangeName}`)
    }
  }

  // Obtener order book en Binance
  async getBinanceOrderBook(symbol) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POLUSDT)
      const formattedSymbol = symbol.replace("/", "")

      const response = await axios.get(`${this.exchanges.BINANCE.baseURL}/api/v3/depth`, {
        params: {
          symbol: formattedSymbol,
          limit: 20,
        },
      })

      return {
        bids: response.data.bids.map((bid) => [Number.parseFloat(bid[0]), Number.parseFloat(bid[1])]),
        asks: response.data.asks.map((ask) => [Number.parseFloat(ask[0]), Number.parseFloat(ask[1])]),
      }
    } catch (error) {
      throw new Error(`Error obteniendo order book en Binance: ${error.message}`)
    }
  }

  // Obtener order book en KuCoin
  async getKucoinOrderBook(symbol) {
    try {
      // Convertir formato de s√≠mbolo (POL/USDT -> POL-USDT)
      const formattedSymbol = symbol.replace("/", "-")

      const response = await axios.get(`${this.exchanges.KUCOIN.baseURL}/api/v1/market/orderbook/level2_20`, {
        params: {
          symbol: formattedSymbol,
        },
      })

      return {
        bids: response.data.data.bids.map((bid) => [Number.parseFloat(bid[0]), Number.parseFloat(bid[1])]),
        asks: response.data.data.asks.map((ask) => [Number.parseFloat(ask[0]), Number.parseFloat(ask[1])]),
      }
    } catch (error) {
      throw new Error(`Error obteniendo order book en KuCoin: ${error.message}`)
    }
  }

  // M√©todo auxiliar para generar precios simulados
  getSimulatedPrice(symbol) {
    // Precios base simulados
    const basePrices = {
      "POL/USDT": 0.45,
      "USDC/USDT": 1.0001,
    }

    const basePrice = basePrices[symbol] || 1.0
    // Agregar variaci√≥n aleatoria del ¬±0.1%
    const variation = (Math.random() - 0.5) * 0.002
    return basePrice * (1 + variation)
  }
}

module.exports = ExchangeManager


--------------------------------------------------------------------------------------------------------

const ccxt = require("ccxt")

/**
 * Fetcher de precios reales para Binance y Bybit
 */
class RealPriceFetcher {
  constructor(config) {
    this.config = config
    this.exchanges = {}
    this.lastPrices = {}
    this.isInitialized = false

    this.logger = console
  }

  /**
   * Inicializa las conexiones a los exchanges
   */
  async initialize() {
    try {
      this.logger.info("üîÑ Inicializando conexiones a exchanges...")

      // Configurar Binance
if (this.config.EXCHANGES.BINANCE.enabled) {
   this.exchanges.binance = new ccxt.binance({
    apiKey: this.config.EXCHANGES.BINANCE.apiKey,
    secret: this.config.EXCHANGES.BINANCE.apiSecret,
    sandbox: this.config.EXCHANGES.BINANCE.sandbox,
    enableRateLimit: true,
    rateLimit: this.config.EXCHANGES.BINANCE.rateLimit,
  });

  await this.exchanges.binance.loadMarkets();
  this.logger.info("‚úÖ Binance conectado");
}

      // Configurar Bybit (NUEVO - reemplaza Kucoin)
      if (this.config.EXCHANGES.BYBIT.enabled) {
        this.exchanges.bybit = new ccxt.bybit({
          apiKey: this.config.EXCHANGES.BYBIT.apiKey,
          secret: this.config.EXCHANGES.BYBIT.apiSecret,
          sandbox: this.config.EXCHANGES.BYBIT.sandbox,
          enableRateLimit: true,
          rateLimit: this.config.EXCHANGES.BYBIT.rateLimit,
        })

        await this.exchanges.bybit.loadMarkets()
        this.logger.info("‚úÖ Bybit conectado")
      }

      this.isInitialized = true
      this.logger.info("üéâ RealPriceFetcher inicializado correctamente")
    } catch (error) {
      this.logger.error("‚ùå Error inicializando RealPriceFetcher:", error.message)
      throw error
    }
  }

  /**
   * Obtiene precios reales de todos los exchanges para un par espec√≠fico
   */
  async fetchPricesForPair(pair) {
    if (!this.isInitialized) {
      throw new Error("RealPriceFetcher no est√° inicializado")
    }

    const prices = {}

    for (const [exchangeName, exchange] of Object.entries(this.exchanges)) {
      try {
        // Verificar si el par est√° disponible
        if (!exchange.markets[pair]) {
          this.logger.warn(`‚ö†Ô∏è  Par ${pair} no disponible en ${exchangeName}`)
          continue
        }

        // Obtener ticker
        const ticker = await exchange.fetchTicker(pair)

        prices[exchangeName] = {
          price: ticker.last,
          bid: ticker.bid,
          ask: ticker.ask,
          volume: ticker.baseVolume,
          timestamp: ticker.timestamp,
          lastUpdate: Date.now(),
        }

        this.logger.debug(`üìä ${exchangeName}: ${pair} = $${ticker.last?.toFixed(4)}`)
      } catch (error) {
        this.logger.error(`‚ùå Error obteniendo precio de ${pair} en ${exchangeName}:`, error.message)
      }
    }

    // Guardar en cach√©
    this.lastPrices[pair] = prices

    return prices
  }

  /**
   * Obtiene precios de todos los pares configurados
   */
  async fetchAllPrices() {
    const allPrices = {}

    for (const pair of this.config.TRADING_PAIRS) {
      try {
        allPrices[pair] = await this.fetchPricesForPair(pair)

        // Peque√±a pausa para evitar rate limits
        await new Promise((resolve) => setTimeout(resolve, 100))
      } catch (error) {
        this.logger.error(`‚ùå Error obteniendo precios para ${pair}:`, error.message)
      }
    }

    return allPrices
  }

  /**
   * Calcula oportunidades de arbitraje
   */
  calculateArbitrageOpportunities(prices) {
    const opportunities = {}

    for (const [pair, exchangePrices] of Object.entries(prices)) {
      const exchanges = Object.keys(exchangePrices)

      if (exchanges.length < 2) {
        continue
      }

      let bestBuy = null
      let bestSell = null
      let lowestAsk = Number.POSITIVE_INFINITY
      let highestBid = 0

      // Encontrar mejor compra (menor ask) y mejor venta (mayor bid)
      for (const [exchangeName, priceData] of Object.entries(exchangePrices)) {
        if (priceData.ask && priceData.ask < lowestAsk) {
          lowestAsk = priceData.ask
          bestBuy = { exchange: exchangeName, price: priceData.ask }
        }

        if (priceData.bid && priceData.bid > highestBid) {
          highestBid = priceData.bid
          bestSell = { exchange: exchangeName, price: priceData.bid }
        }
      }

      if (bestBuy && bestSell && bestBuy.exchange !== bestSell.exchange) {
        const profitPercentage = ((bestSell.price - bestBuy.price) / bestBuy.price) * 100

        opportunities[pair] = {
          exchanges: exchangePrices,
          bestBuy,
          bestSell,
          profitPercentage,
          isOpportunity: profitPercentage >= this.config.STRATEGIES.BASIC.minProfitPercentage,
          minProfitThreshold: this.config.STRATEGIES.BASIC.minProfitPercentage,
        }
      }
    }

    return opportunities
  }

  /**
   * Obtiene los √∫ltimos precios del cach√©
   */
  getLastPrices() {
    return this.lastPrices
  }

  /**
   * Verifica el estado de las conexiones
   */
  async checkConnections() {
    const status = {}

    for (const [exchangeName, exchange] of Object.entries(this.exchanges)) {
      try {
        const exchangeStatus = await exchange.fetchStatus()
        status[exchangeName] = {
          connected: true,
          status: exchangeStatus.status || "active",
          updated: exchangeStatus.updated,
        }
      } catch (error) {
        status[exchangeName] = {
          connected: false,
          error: error.message,
        }
      }
    }

    return status
  }
}

module.exports = RealPriceFetcher


------------------------------------------------------------------------------------------------------------

MOBILE

// Versi√≥n simplificada sin dependencias
class MobileAPI {
  constructor(config) {
    this.enabled = false;
    console.log('üì± Mobile API disabled (firebase-admin no instalado)');
  }
  
  start() {
    // No hacer nada
    return;
  }
  
  stop() {
    // No hacer nada
    return;
  }
  
  sendNotification() {
    // No hacer nada
    return;
  }
}

module.exports = MobileAPI;

----------------------------------------------------------------------------------------------------------

const express = require('express');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const admin = require('firebase-admin');

/**
 * API M√≥vil para el Bot de Arbitraje
 * Proporciona endpoints para la aplicaci√≥n m√≥vil
 */
class MobileAPI {
    constructor(config) {
        this.config = config;
        this.enabled = config.MOBILE_API.ENABLED;
        this.port = config.MOBILE_API.PORT;
        this.jwtSecret = config.MOBILE_API.JWT_SECRET;
        this.jwtExpiry = config.MOBILE_API.JWT_EXPIRY;
        this.rateLimitConfig = config.MOBILE_API.RATE_LIMIT;
        this.corsConfig = config.MOBILE_API.CORS;
        this.endpoints = config.MOBILE_API.ENDPOINTS;
        this.pushNotifications = config.MOBILE_API.PUSH_NOTIFICATIONS;
        
        this.app = express();
        this.server = null;
        this.bot = null;
        this.authenticatedUsers = new Map();
        
        this.logger = console;
    }
    
    /**
     * Inicializa la API m√≥vil
     */
    async initialize() {
        if (!this.enabled) {
            this.logger.info('Mobile API deshabilitada');
            return;
        }
        
        this.logger.info('Inicializando Mobile API...');
        
        try {
            // Configurar middleware
            this.setupMiddleware();
            
            // Configurar rutas
            this.setupRoutes();
            
            // Inicializar Firebase para notificaciones push
            if (this.pushNotifications.enabled) {
                await this.initializeFirebase();
            }
            
            // Iniciar servidor
            await this.startServer();
            
            this.logger.info(`Mobile API inicializada en puerto ${this.port}`);
        } catch (error) {
            this.logger.error('Error inicializando Mobile API:', error);
            throw error;
        }
    }
    
    /**
     * Configura el middleware de Express
     */
    setupMiddleware() {
        // CORS
        this.app.use(cors(this.corsConfig));
        
        // Rate limiting
        const limiter = rateLimit(this.rateLimitConfig);
        this.app.use(limiter);
        
        // Body parser
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true }));
        
        // Logging middleware
        this.app.use((req, res, next) => {
            this.logger.info(`${req.method} ${req.path} - ${req.ip}`);
            next();
        });
        
        // Error handling middleware
        this.app.use((error, req, res, next) => {
            this.logger.error('API Error:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        });
    }
    
    /**
     * Configura las rutas de la API
     */
    setupRoutes() {
        // Ruta de autenticaci√≥n
        this.app.post('/api/mobile/auth/login', this.handleLogin.bind(this));
        this.app.post('/api/mobile/auth/logout', this.authenticateToken.bind(this), this.handleLogout.bind(this));
        this.app.post('/api/mobile/auth/refresh', this.handleRefreshToken.bind(this));
        
        // Rutas protegidas
        this.app.use('/api/mobile/*', this.authenticateToken.bind(this));
        
        // Estado del bot
        this.app.get(this.endpoints.STATUS, this.handleGetStatus.bind(this));
        
        // Operaciones
        this.app.get(this.endpoints.TRADES, this.handleGetTrades.bind(this));
        this.app.get('/api/mobile/trades/:id', this.handleGetTradeDetails.bind(this));
        
        // Portfolio
        this.app.get(this.endpoints.PORTFOLIO, this.handleGetPortfolio.bind(this));
        this.app.get('/api/mobile/portfolio/history', this.handleGetPortfolioHistory.bind(this));
        
        // Alertas
        this.app.get(this.endpoints.ALERTS, this.handleGetAlerts.bind(this));
        this.app.post('/api/mobile/alerts/mark-read', this.handleMarkAlertsRead.bind(this));
        
        // Configuraci√≥n
        this.app.get(this.endpoints.SETTINGS, this.handleGetSettings.bind(this));
        this.app.put(this.endpoints.SETTINGS, this.handleUpdateSettings.bind(this));
        
        // Control del bot
        this.app.post('/api/mobile/bot/start', this.handleStartBot.bind(this));
        this.app.post('/api/mobile/bot/stop', this.handleStopBot.bind(this));
        this.app.post('/api/mobile/bot/strategy', this.handleChangeStrategy.bind(this));
        
        // Estad√≠sticas
        this.app.get('/api/mobile/stats/summary', this.handleGetStatsSummary.bind(this));
        this.app.get('/api/mobile/stats/performance', this.handleGetPerformanceStats.bind(this));
        
        // Notificaciones push
        this.app.post('/api/mobile/notifications/register', this.handleRegisterDevice.bind(this));
        this.app.post('/api/mobile/notifications/unregister', this.handleUnregisterDevice.bind(this));
        
        // Health check
        this.app.get('/api/mobile/health', (req, res) => {
            res.json({ status: 'ok', timestamp: new Date().toISOString() });
        });
    }
    
    /**
     * Inicializa Firebase para notificaciones push
     */
    async initializeFirebase() {
        try {
            if (!this.pushNotifications.fcmServerKey) {
                throw new Error('FCM Server Key no configurado');
            }
            
            // En una implementaci√≥n real, aqu√≠ inicializar√≠amos Firebase Admin SDK
            this.logger.info('Firebase inicializado para notificaciones push');
        } catch (error) {
            this.logger.error('Error inicializando Firebase:', error);
            this.pushNotifications.enabled = false;
        }
    }
    
    /**
     * Inicia el servidor
     */
    async startServer() {
        return new Promise((resolve, reject) => {
            this.server = this.app.listen(this.port, (error) => {
                if (error) {
                    reject(error);
                } else {
                    resolve();
                }
            });
        });
    }
    
    /**
     * Middleware de autenticaci√≥n
     */
    authenticateToken(req, res, next) {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];
        
        if (!token) {
            return res.status(401).json({
                success: false,
                error: 'Token de acceso requerido'
            });
        }
        
        jwt.verify(token, this.jwtSecret, (error, user) => {
            if (error) {
                return res.status(403).json({
                    success: false,
                    error: 'Token inv√°lido'
                });
            }
            
            req.user = user;
            next();
        });
    }
    
    /**
     * Maneja el login
     */
    async handleLogin(req, res) {
        try {
            const { username, password } = req.body;
            
            // En una implementaci√≥n real, aqu√≠ verificar√≠amos las credenciales
            // Para esta implementaci√≥n, usaremos credenciales hardcodeadas
            if (username === 'admin' && password === 'admin123') {
                const user = {
                    id: 1,
                    username: 'admin',
                    role: 'admin'
                };
                
                const token = jwt.sign(user, this.jwtSecret, { expiresIn: this.jwtExpiry });
                const refreshToken = jwt.sign(user, this.jwtSecret + '_refresh', { expiresIn: '7d' });
                
                // Guardar usuario autenticado
                this.authenticatedUsers.set(user.id, {
                    ...user,
                    token,
                    refreshToken,
                    loginTime: new Date()
                });
                
                res.json({
                    success: true,
                    data: {
                        user,
                        token,
                        refreshToken
                    }
                });
            } else {
                res.status(401).json({
                    success: false,
                    error: 'Credenciales inv√°lidas'
                });
            }
        } catch (error) {
            this.logger.error('Error en login:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Maneja el logout
     */
    async handleLogout(req, res) {
        try {
            const userId = req.user.id;
            
            // Remover usuario autenticado
            this.authenticatedUsers.delete(userId);
            
            res.json({
                success: true,
                message: 'Logout exitoso'
            });
        } catch (error) {
            this.logger.error('Error en logout:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Maneja la renovaci√≥n de token
     */
    async handleRefreshToken(req, res) {
        try {
            const { refreshToken } = req.body;
            
            if (!refreshToken) {
                return res.status(401).json({
                    success: false,
                    error: 'Refresh token requerido'
                });
            }
            
            jwt.verify(refreshToken, this.jwtSecret + '_refresh', (error, user) => {
                if (error) {
                    return res.status(403).json({
                        success: false,
                        error: 'Refresh token inv√°lido'
                    });
                }
                
                const newToken = jwt.sign(
                    { id: user.id, username: user.username, role: user.role },
                    this.jwtSecret,
                    { expiresIn: this.jwtExpiry }
                );
                
                res.json({
                    success: true,
                    data: { token: newToken }
                });
            });
        } catch (error) {
            this.logger.error('Error renovando token:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene el estado del bot
     */
    async handleGetStatus(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const status = this.bot.getStatus();
            const riskAnalysis = this.bot.getRiskAnalysis();
            
            res.json({
                success: true,
                data: {
                    ...status,
                    riskAnalysis
                }
            });
        } catch (error) {
            this.logger.error('Error obteniendo estado:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene las operaciones
     */
    async handleGetTrades(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { page = 1, limit = 20, type, status } = req.query;
            const offset = (page - 1) * limit;
            
            let trades = this.bot.getTradeHistory();
            
            // Filtrar por tipo si se especifica
            if (type) {
                trades = trades.filter(trade => trade.type === type);
            }
            
            // Filtrar por estado si se especifica
            if (status) {
                trades = trades.filter(trade => 
                    status === 'success' ? trade.success : !trade.success
                );
            }
            
            // Paginar
            const total = trades.length;
            const paginatedTrades = trades.slice(offset, offset + parseInt(limit));
            
            res.json({
                success: true,
                data: {
                    trades: paginatedTrades,
                    pagination: {
                        page: parseInt(page),
                        limit: parseInt(limit),
                        total,
                        pages: Math.ceil(total / limit)
                    }
                }
            });
        } catch (error) {
            this.logger.error('Error obteniendo operaciones:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene detalles de una operaci√≥n espec√≠fica
     */
    async handleGetTradeDetails(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { id } = req.params;
            const trades = this.bot.getTradeHistory();
            const trade = trades.find(t => t.id === id);
            
            if (!trade) {
                return res.status(404).json({
                    success: false,
                    error: 'Operaci√≥n no encontrada'
                });
            }
            
            res.json({
                success: true,
                data: trade
            });
        } catch (error) {
            this.logger.error('Error obteniendo detalles de operaci√≥n:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene informaci√≥n del portfolio
     */
    async handleGetPortfolio(req, res) {
        try {
            // En una implementaci√≥n real, obtendr√≠amos datos del portfolio manager
            const portfolioData = {
                totalValue: 10500.75,
                totalProfit: 500.75,
                totalProfitPercentage: 5.01,
                balances: {
                    'Binance': 2625.19,
                    'Coinbase': 2631.25,
                    'Kraken': 2622.15,
                    'Kucoin': 2622.16
                },
                allocation: {
                    'Binance': 25.0,
                    'Coinbase': 25.1,
                    'Kraken': 24.9,
                    'Kucoin': 25.0
                },
                lastUpdate: new Date().toISOString()
            };
            
            res.json({
                success: true,
                data: portfolioData
            });
        } catch (error) {
            this.logger.error('Error obteniendo portfolio:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene historial del portfolio
     */
    async handleGetPortfolioHistory(req, res) {
        try {
            const { period = '7d' } = req.query;
            
            // Simular datos hist√≥ricos
            const history = [];
            const now = new Date();
            let days;
            
            switch (period) {
                case '1d':
                    days = 1;
                    break;
                case '7d':
                    days = 7;
                    break;
                case '30d':
                    days = 30;
                    break;
                default:
                    days = 7;
            }
            
            for (let i = days; i >= 0; i--) {
                const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
                history.push({
                    timestamp: date.toISOString(),
                    value: 10000 + Math.random() * 1000,
                    profit: Math.random() * 100 - 50
                });
            }
            
            res.json({
                success: true,
                data: history
            });
        } catch (error) {
            this.logger.error('Error obteniendo historial de portfolio:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene alertas
     */
    async handleGetAlerts(req, res) {
        try {
            // En una implementaci√≥n real, obtendr√≠amos alertas del alert manager
            const alerts = [
                {
                    id: 'alert_1',
                    type: 'trade_executed',
                    message: 'Arbitraje ejecutado: BTC/USDT - Ganancia: 0.5%',
                    timestamp: new Date().toISOString(),
                    priority: 'medium',
                    read: false
                },
                {
                    id: 'alert_2',
                    type: 'risk_warning',
                    message: 'Volatilidad alta detectada en el mercado',
                    timestamp: new Date(Date.now() - 3600000).toISOString(),
                    priority: 'high',
                    read: true
                }
            ];
            
            res.json({
                success: true,
                data: alerts
            });
        } catch (error) {
            this.logger.error('Error obteniendo alertas:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Marca alertas como le√≠das
     */
    async handleMarkAlertsRead(req, res) {
        try {
            const { alertIds } = req.body;
            
            // En una implementaci√≥n real, marcar√≠amos las alertas como le√≠das
            this.logger.info(`Marcando alertas como le√≠das: ${alertIds.join(', ')}`);
            
            res.json({
                success: true,
                message: 'Alertas marcadas como le√≠das'
            });
        } catch (error) {
            this.logger.error('Error marcando alertas como le√≠das:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene configuraci√≥n
     */
    async handleGetSettings(req, res) {
        try {
            const settings = {
                riskLevel: 'medium',
                maxExposure: 20,
                strategies: ['basic', 'triangular'],
                notifications: {
                    trades: true,
                    alerts: true,
                    dailySummary: false
                },
                autoRebalance: true
            };
            
            res.json({
                success: true,
                data: settings
            });
        } catch (error) {
            this.logger.error('Error obteniendo configuraci√≥n:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Actualiza configuraci√≥n
     */
    async handleUpdateSettings(req, res) {
        try {
            const settings = req.body;
            
            // En una implementaci√≥n real, actualizar√≠amos la configuraci√≥n del bot
            this.logger.info('Actualizando configuraci√≥n:', settings);
            
            res.json({
                success: true,
                message: 'Configuraci√≥n actualizada correctamente'
            });
        } catch (error) {
            this.logger.error('Error actualizando configuraci√≥n:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Inicia el bot
     */
    async handleStartBot(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { mode = 'simulation' } = req.body;
            
            await this.bot.start(mode);
            
            // Enviar notificaci√≥n push
            if (this.pushNotifications.enabled) {
                await this.sendPushNotification(req.user.id, {
                    title: 'Bot Iniciado',
                    body: `Bot iniciado en modo ${mode}`,
                    data: { type: 'bot_started', mode }
                });
            }
            
            res.json({
                success: true,
                message: 'Bot iniciado correctamente'
            });
        } catch (error) {
            this.logger.error('Error iniciando bot:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    /**
     * Detiene el bot
     */
    async handleStopBot(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            await this.bot.stop();
            
            // Enviar notificaci√≥n push
            if (this.pushNotifications.enabled) {
                await this.sendPushNotification(req.user.id, {
                    title: 'Bot Detenido',
                    body: 'Bot detenido correctamente',
                    data: { type: 'bot_stopped' }
                });
            }
            
            res.json({
                success: true,
                message: 'Bot detenido correctamente'
            });
        } catch (error) {
            this.logger.error('Error deteniendo bot:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    /**
     * Cambia la estrategia del bot
     */
    async handleChangeStrategy(req, res) {
        try {
            if (!this.bot) {
                return res.status(503).json({
                    success: false,
                    error: 'Bot no disponible'
                });
            }
            
            const { strategy } = req.body;
            
            this.bot.changeStrategy(strategy);
            
            res.json({
                success: true,
                message: `Estrategia cambiada a ${strategy}`
            });
        } catch (error) {
            this.logger.error('Error cambiando estrategia:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    /**
     * Obtiene resumen de estad√≠sticas
     */
    async handleGetStatsSummary(req, res) {
        try {
            const stats = {
                totalTrades: 156,
                successfulTrades: 142,
                failedTrades: 14,
                winRate: 91.03,
                totalProfit: 1250.75,
                averageProfit: 8.79,
                bestTrade: 45.20,
                worstTrade: -12.30,
                sharpeRatio: 1.85,
                maxDrawdown: 3.2
            };
            
            res.json({
                success: true,
                data: stats
            });
        } catch (error) {
            this.logger.error('Error obteniendo estad√≠sticas:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    
    /**
     * Obtiene estad√≠sticas de rendimiento
     */
    async handleGetPerformanceStats(req, res) {
        try {
            const { period = '30d' } = req.query;
            
            // Simular datos de rendimiento
            const performance = {
                period,
                totalReturn: 12.5,
                annualizedReturn: 156.2,
                volatility: 8.3,
                sharpeRatio: 1.85,
                maxDrawdown: 3.2,
                calmarRatio: 48.8,
                winRate: 91.03,
                profitFactor: 6.45,
                averageTrade: 8.79,
                tradesPerDay: 5.2
            };
            
            res.json({
                success: true,
                data: performance
            });
        } catch (error) {
            this.logger.error('Error obteniendo estad√≠sticas de rendimiento:', error);
            res.status(500).json({
                success: false,
                error: 'Error interno del servidor'
            });
        }
    }
    